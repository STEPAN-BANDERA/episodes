/*!
 * jQuery Cookie Plugin v1.4.1
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(jQuery);
    }
}(function ($) {
    var pluses = /\+/g;

    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }
        try {
            s = decodeURIComponent(s.replace(pluses, ' '));
            return config.json ? JSON.parse(s) : s;
        } catch (e) {
        }
    }

    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }

    var config = $.cookie = function (key, value, options) {
        if (value !== undefined && !$.isFunction(value)) {
            options = $.extend({}, config.defaults, options);
            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setTime(+t + days * 864e+5);
            }
            return (document.cookie = [
                encode(key), '=', stringifyCookieValue(value),
                options.expires ? '; expires=' + options.expires.toUTCString() : '',
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }
        var result = key ? undefined : {};
        var cookies = document.cookie ? document.cookie.split('; ') : [];
        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = parts.join('=');
            if (key && key === name) {
                result = read(cookie, value);
                break;
            }
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }
        return result;
    };
    config.defaults = {};
    $.removeCookie = function (key, options) {
        if ($.cookie(key) === undefined) {
            return false;
        }
        $.cookie(key, '', $.extend({}, options, {expires: -1}));
        return !$.cookie(key);
    };
}));
/************************************************************************
 @Name :        jRating - jQuery Plugin
 @Revison :        3.1
 *************************************************************************/
(function ($) {
    $.fn.jRating = function (op) {
        var defaults = {
            /** String vars **/
            bigStarsPath: 'jquery/icons/stars.png',
            smallStarsPath: 'jquery/icons/small.png',
            phpPath: 'php/jRating.php',
            type: 'big',
            step: false,
            isDisabled: false,
            showRateInfo: true,
            canRateAgain: false,
            sendRequest: true,
            length: 5,
            decimalLength: 0,
            rateMax: 20,
            rateInfosX: -45,
            rateInfosY: 5,
            nbRates: 1,
            onSuccess: null,
            onError: null,
            onClick: null
        };
        if (this.length > 0)
            return this.each(function () {
                var opts = $.extend(defaults, op),
                    newWidth = 0,
                    starWidth = 0,
                    starHeight = 0,
                    bgPath = '',
                    hasRated = false,
                    globalWidth = 0,
                    nbOfRates = opts.nbRates;
                if ($(this).hasClass('jDisabled') || opts.isDisabled)
                    var jDisabled = true;
                else
                    var jDisabled = false;
                getStarWidth();
                $(this).height(starHeight);
                var dataAverage = parseFloat($(this).attr('data-average')); // get the average of all rates
                if (isNaN(dataAverage)) {
                    dataAverage = 0;
                }
                var ratingList = {
                    0: 'невыбрано',
                    1: 'ничтожно',
                    2: 'ужасно',
                    3: 'плохо',
                    4: 'никак',
                    5: 'посредственно',
                    6: 'неплохо',
                    7: 'хорошо',
                    8: 'очень хорошо',
                    9: 'великолепно',
                    10: 'шедевр'
                };
                var idBox = parseInt($(this).attr('data-id')), // get the id of the box
                    widthRatingContainer = starWidth * opts.length, // Width of the Container
                    widthColor = dataAverage / opts.rateMax * widthRatingContainer, // Width of the color Container
                    quotient =
                        $('<div>',
                            {
                                'class': 'jRatingColor',
                                css: {
                                    width: widthColor
                                }
                            }).appendTo($(this)),

                    average =
                        $('<div>',
                            {
                                'class': 'jRatingAverage',
                                css: {
                                    width: 0,
                                    top: -starHeight
                                }
                            }).appendTo($(this)),

                    jstar =
                        $('<div>',
                            {
                                'class': 'jStar',
                                css: {
                                    width: widthRatingContainer,
                                    height: starHeight,
                                    top: -(starHeight * 2),
                                    background: 'url(' + bgPath + ') repeat-x'
                                }
                            }).appendTo($(this));
                $(this).css({width: widthRatingContainer, overflow: 'hidden', zIndex: 1, position: 'relative'});
                if (!jDisabled)
                    $(this).unbind().bind({
                        mouseenter: function (e) {
                            var realOffsetLeft = findRealLeft(this);
                            var relativeX = e.pageX - realOffsetLeft;
                            var ratingK = getNote(relativeX);
                            if (opts.showRateInfo)
                                var tooltip =
                                    $('<p>', {
                                        'class': 'jRatingInfos',
                                        html: ratingK + ' <span class="maxRate">(' + ratingList[ratingK] + ')</span>',
                                        css: {
                                            top: (e.pageY + opts.rateInfosY),
                                            left: (e.pageX + opts.rateInfosX)
                                        }
                                    }).appendTo('body').show();
                        },
                        mouseover: function (e) {
                            $(this).css('cursor', 'pointer');
                        },
                        mouseout: function () {
                            $(this).css('cursor', 'default');
                            if (hasRated) average.width(globalWidth);
                            else average.width(0);
                        },
                        mousemove: function (e) {
                            var realOffsetLeft = findRealLeft(this);
                            var relativeX = e.pageX - realOffsetLeft;
                            if (opts.step) newWidth = Math.floor(relativeX / starWidth) * starWidth + starWidth;
                            else newWidth = relativeX;
                            var ratingL = getNote(newWidth);
                            average.width(newWidth);
                            if (opts.showRateInfo)
                                $("p.jRatingInfos")
                                    .css({
                                        left: (e.pageX + opts.rateInfosX)
                                    })
                                    .html(ratingL + ' <span class="maxRate">(' + ratingList[ratingL] + ')</span>');
                        },
                        mouseleave: function () {
                            $("p.jRatingInfos").remove();
                        },
                        click: function (e) {
                            var element = this;
                            hasRated = true;
                            globalWidth = newWidth;
                            nbOfRates--;
                            if (!opts.canRateAgain || parseInt(nbOfRates) <= 0) $(this).unbind().css('cursor', 'default').addClass('jDisabled');
                            if (opts.showRateInfo) $("p.jRatingInfos").fadeOut('fast', function () {
                                $(this).remove();
                            });
                            e.preventDefault();
                            var rate = getNote(newWidth);
                            average.width(newWidth);
                            if (opts.onClick) opts.onClick(element, rate);
                            if (opts.sendRequest) {
                                $.post(opts.phpPath, {
                                        idBox: idBox,
                                        rate: rate,
                                        action: 'rating'
                                    },
                                    function (data) {
                                        if (!data.error) {
                                            if (opts.onSuccess) opts.onSuccess(element, rate, data);
                                        } else {
                                            if (opts.onError) opts.onError(element, rate, data);
                                        }
                                    },
                                    'json'
                                );
                            }
                        }
                    });

                function getNote(relativeX) {
                    var noteBrut = parseFloat((relativeX * 100 / widthRatingContainer) * parseInt(opts.rateMax) / 100);
                    var dec = Math.pow(10, parseInt(opts.decimalLength));
                    var note = Math.round(noteBrut * dec) / dec;
                    return note;
                }

                function getStarWidth() {
                    switch (opts.type) {
                        case 'small' :
                            starWidth = 12; // width of the picture small.png
                            starHeight = 10; // height of the picture small.png
                            bgPath = opts.smallStarsPath;
                            break;
                        default :
                            starWidth = 23; // width of the picture stars.png
                            starHeight = 20; // height of the picture stars.png
                            bgPath = opts.bigStarsPath;
                    }
                }

                function findRealLeft(obj) {
                    if (!obj) return 0;
                    return obj.offsetLeft + findRealLeft(obj.offsetParent);
                }
            });
    }
})(jQuery);

/**
 * downCount: Simple Countdown clock with offset
 * Author: Sonny T. <hi@sonnyt.com>, sonnyt.com
 */
(function ($) {
    $.fn.downCount = function (options, callback) {
        var settings = $.extend({
            date: null,
            offset: null
        }, options);
        if (!settings.date) {
            $.error('Date is not defined.');
        }
        if (!Date.parse(settings.date)) {
            $.error('Incorrect date format, it should look like this, 12/24/2012 12:00:00.');
        }
        var container = this;
        var currentDate = function () {
            var date = new Date();
            var utc = date.getTime() + (date.getTimezoneOffset() * 60000);
            var new_date = new Date(utc + (3600000 * settings.offset));
            return new_date;
        };

        function countdown() {
            var target_date = new Date(settings.date),
                current_date = currentDate();
            var difference = target_date - current_date;
            if (difference < 0) {
                clearInterval(interval);
                if (callback && typeof callback === 'function') callback();
                return;
            }
            var _second = 1000,
                _minute = _second * 60,
                _hour = _minute * 60,
                _day = _hour * 24;
            var days = Math.floor(difference / _day),
                hours = Math.floor((difference % _day) / _hour),
                minutes = Math.floor((difference % _hour) / _minute),
                seconds = Math.floor((difference % _minute) / _second);
            days = (String(days).length >= 2) ? days : '0' + days;
            hours = (String(hours).length >= 2) ? hours : '0' + hours;
            minutes = (String(minutes).length >= 2) ? minutes : '0' + minutes;
            seconds = (String(seconds).length >= 2) ? seconds : '0' + seconds;
            var ref_days = (days === 1) ? 'день' : 'дней',
                ref_hours = (hours === 1) ? 'час' : 'часов',
                ref_minutes = (minutes === 1) ? 'минута' : 'минут',
                ref_seconds = (seconds === 1) ? 'секунда' : 'секунд';
            container.find('.days').text(days);
            container.find('.hours').text(hours);
            container.find('.minutes').text(minutes);
            container.find('.seconds').text(seconds);
            container.find('.days_ref').text(ref_days);
            container.find('.hours_ref').text(ref_hours);
            container.find('.minutes_ref').text(ref_minutes);
            container.find('.seconds_ref').text(ref_seconds);
        }

        var interval = setInterval(countdown, 1000);
    };
})(jQuery);

//resizetextarea
(function ($) {
    var textarea, staticOffset;
    var iLastMousePos = 0;
    var iMin = 32;
    var grip;
    $.fn.TextAreaResizer = function () {
        return this.each(function () {
            if ($(this).height() >= 190 || $(this).is('textarea')) {
                textarea = $(this).css({'height': 190, 'max-height': 'none'}).addClass('processed'), staticOffset = null;
                $(this).wrap('<div class="resizable-textarea"><span></span></div>').parent().append($('<div class="grippie"></div>').bind("mousedown", {el: this}, startDrag));
                var grippie = $('div.grippie', $(this).parent())[0];
                grippie.style.marginRight = (grippie.offsetWidth - $(this)[0].offsetWidth) + 'px'
            }
        })
    };

    function startDrag(e) {
        textarea = $(e.data.el);
        textarea.blur();
        iLastMousePos = mousePosition(e).y;
        staticOffset = textarea.height() - iLastMousePos;
        textarea.css('opacity', 0.7);
        $(document).mousemove(performDrag).mouseup(endDrag);
        return false
    }

    function performDrag(e) {
        var iThisMousePos = mousePosition(e).y;
        var iMousePos = staticOffset + iThisMousePos;
        if (iLastMousePos >= (iThisMousePos)) {
            iMousePos -= 5
        }
        iLastMousePos = iThisMousePos;
        iMousePos = Math.max(iMin, iMousePos);
        textarea.height(iMousePos + 'px');
        if (iMousePos < iMin) {
            endDrag(e)
        }
        return false
    }

    function endDrag(e) {
        $(document).unbind('mousemove', performDrag).unbind('mouseup', endDrag);
        textarea.css('opacity', 1);
        textarea.focus();
        textarea = null;
        staticOffset = null;
        iLastMousePos = 0
    }

    function mousePosition(e) {
        return {x: e.clientX + document.documentElement.scrollLeft, y: e.clientY + document.documentElement.scrollTop}
    }
})(jQuery);

//colors for VK widget
(function ($) {
    function hex(x) {
        return ("0" + parseInt(x).toString(16)).slice(-2);
    }

    function rgb2hex(rgb) {
        rgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(,\s*\d+\.*\d+)?\)$/);
        return "#" + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
    }

    function getProperty(el, prop) {
        return $(el).css(prop) || '';
    }

    $.fn.bgColor = function () {
        return rgb2hex(getProperty(this.get(0), 'background-color'));
    };
    $.fn.fgColor = function () {
        return rgb2hex(getProperty(this.get(0), 'color'));
    };
})(jQuery);
!function (e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.SlimSelect = t() : e.SlimSelect = t()
}(window, function () {
    return s = {}, n.m = i = [function (e, t, i) {
        "use strict";

        function s(e, t) {
            t = t || {bubbles: !1, cancelable: !1, detail: void 0};
            var i = document.createEvent("CustomEvent");
            return i.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), i
        }

        var n;
        t.__esModule = !0, t.hasClassInTree = function (e, t) {
            function s(e, t) {
                return t && e && e.classList && e.classList.contains(t) ? e : null
            }

            return s(e, t) || function e(t, i) {
                return t && t !== document ? s(t, i) ? t : e(t.parentNode, i) : null
            }(e, t)
        }, t.ensureElementInView = function (e, t) {
            var i = e.scrollTop + e.offsetTop, s = i + e.clientHeight, n = t.offsetTop, a = n + t.clientHeight;
            n < i ? e.scrollTop -= i - n : s < a && (e.scrollTop += a - s)
        }, t.putContent = function (e, t, i) {
            var s = e.offsetHeight, n = e.getBoundingClientRect(), a = i ? n.top : n.top - s,
                o = i ? n.bottom : n.bottom + s;
            return a <= 0 ? "below" : o >= window.innerHeight ? "above" : i ? t : "below"
        }, t.debounce = function (n, a, o) {
            var l;
            return void 0 === a && (a = 100), void 0 === o && (o = !1), function () {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                var i = self, s = o && !l;
                clearTimeout(l), l = setTimeout(function () {
                    l = null, o || n.apply(i, e)
                }, a), s && n.apply(i, e)
            }
        }, t.isValueInArrayOfObjects = function (e, t, i) {
            if (!Array.isArray(e)) return e[t] === i;
            for (var s = 0, n = e; s < n.length; s++) {
                var a = n[s];
                if (a && a[t] && a[t] === i) return !0
            }
            return !1
        }, t.highlight = function (e, t, i) {
            var s = e, n = new RegExp("(" + t.trim() + ")(?![^<]*>[^<>]*</)", "i");
            if (!e.match(n)) return e;
            var a = e.match(n).index, o = a + e.match(n)[0].toString().length, l = e.substring(a, o);
            return s = s.replace(n, '<mark class="' + i + '">' + l + "</mark>")
        }, t.kebabCase = function (e) {
            var t = e.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, function (e) {
                return "-" + e.toLowerCase()
            });
            return e[0] === e[0].toUpperCase() ? t.substring(1) : t
        }, "function" != typeof (n = window).CustomEvent && (s.prototype = n.Event.prototype, n.CustomEvent = s)
    }, function (e, t, i) {
        "use strict";
        t.__esModule = !0;
        var s = (n.prototype.newOption = function (e) {
            return {
                id: e.id ? e.id : String(Math.floor(1e8 * Math.random())),
                value: e.value ? e.value : "",
                text: e.text ? e.text : "",
                innerHTML: e.innerHTML ? e.innerHTML : "",
                selected: !!e.selected && e.selected,
                display: void 0 === e.display || e.display,
                disabled: !!e.disabled && e.disabled,
                placeholder: !!e.placeholder && e.placeholder,
                class: e.class ? e.class : void 0,
                data: e.data ? e.data : {},
                mandatory: !!e.mandatory && e.mandatory
            }
        }, n.prototype.add = function (e) {
            this.data.push({
                id: String(Math.floor(1e8 * Math.random())),
                value: e.value,
                text: e.text,
                innerHTML: "",
                selected: !1,
                display: !0,
                disabled: !1,
                placeholder: !1,
                class: void 0,
                mandatory: e.mandatory,
                data: {}
            })
        }, n.prototype.parseSelectData = function () {
            this.data = [];
            for (var e = 0, t = this.main.select.element.childNodes; e < t.length; e++) {
                var i = t[e];
                if ("OPTGROUP" === i.nodeName) {
                    for (var s = {label: i.label, options: []}, n = 0, a = i.childNodes; n < a.length; n++) {
                        var o = a[n];
                        if ("OPTION" === o.nodeName) {
                            var l = this.pullOptionData(o);
                            s.options.push(l), l.placeholder && "" !== l.text.trim() && (this.main.config.placeholderText = l.text)
                        }
                    }
                    this.data.push(s)
                } else "OPTION" === i.nodeName && (l = this.pullOptionData(i), this.data.push(l), l.placeholder && "" !== l.text.trim() && (this.main.config.placeholderText = l.text))
            }
        }, n.prototype.pullOptionData = function (e) {
            return {
                id: !!e.dataset && e.dataset.id || String(Math.floor(1e8 * Math.random())),
                value: e.value,
                text: e.text,
                innerHTML: e.innerHTML,
                selected: e.selected,
                disabled: e.disabled,
                placeholder: "true" === e.dataset.placeholder,
                class: e.className,
                style: e.style.cssText,
                data: e.dataset,
                mandatory: !!e.dataset && "true" === e.dataset.mandatory
            }
        }, n.prototype.setSelectedFromSelect = function () {
            if (this.main.config.isMultiple) {
                for (var e = [], t = 0, i = this.main.select.element.options; t < i.length; t++) {
                    var s = i[t];
                    if (s.selected) {
                        var n = this.getObjectFromData(s.value, "value");
                        n && n.id && e.push(n.id)
                    }
                }
                this.setSelected(e, "id")
            } else {
                var a = this.main.select.element;
                if (-1 !== a.selectedIndex) {
                    var o = a.options[a.selectedIndex].value;
                    this.setSelected(o, "value")
                }
            }
        }, n.prototype.setSelected = function (e, t) {
            void 0 === t && (t = "id");
            for (var i = 0, s = this.data; i < s.length; i++) {
                var n = s[i];
                if (n.hasOwnProperty("label")) {
                    if (n.hasOwnProperty("options")) {
                        var a = n.options;
                        if (a) for (var o = 0, l = a; o < l.length; o++) {
                            var r = l[o];
                            r.placeholder || (r.selected = this.shouldBeSelected(r, e, t))
                        }
                    }
                } else n.selected = this.shouldBeSelected(n, e, t)
            }
        }, n.prototype.shouldBeSelected = function (e, t, i) {
            if (void 0 === i && (i = "id"), Array.isArray(t)) for (var s = 0, n = t; s < n.length; s++) {
                var a = n[s];
                if (i in e && String(e[i]) === String(a)) return !0
            } else if (i in e && String(e[i]) === String(t)) return !0;
            return !1
        }, n.prototype.getSelected = function () {
            for (var e = {
                text: "",
                placeholder: this.main.config.placeholderText
            }, t = [], i = 0, s = this.data; i < s.length; i++) {
                var n = s[i];
                if (n.hasOwnProperty("label")) {
                    if (n.hasOwnProperty("options")) {
                        var a = n.options;
                        if (a) for (var o = 0, l = a; o < l.length; o++) {
                            var r = l[o];
                            r.selected && (this.main.config.isMultiple ? t.push(r) : e = r)
                        }
                    }
                } else n.selected && (this.main.config.isMultiple ? t.push(n) : e = n)
            }
            return this.main.config.isMultiple ? t : e
        }, n.prototype.addToSelected = function (e, t) {
            if (void 0 === t && (t = "id"), this.main.config.isMultiple) {
                var i = [], s = this.getSelected();
                if (Array.isArray(s)) for (var n = 0, a = s; n < a.length; n++) {
                    var o = a[n];
                    i.push(o[t])
                }
                i.push(e), this.setSelected(i, t)
            }
        }, n.prototype.removeFromSelected = function (e, t) {
            if (void 0 === t && (t = "id"), this.main.config.isMultiple) {
                for (var i = [], s = 0, n = this.getSelected(); s < n.length; s++) {
                    var a = n[s];
                    String(a[t]) !== String(e) && i.push(a[t])
                }
                this.setSelected(i, t)
            }
        }, n.prototype.onDataChange = function () {
            this.main.onChange && this.isOnChangeEnabled && this.main.onChange(JSON.parse(JSON.stringify(this.getSelected())))
        }, n.prototype.getObjectFromData = function (e, t) {
            void 0 === t && (t = "id");
            for (var i = 0, s = this.data; i < s.length; i++) {
                var n = s[i];
                if (t in n && String(n[t]) === String(e)) return n;
                if (n.hasOwnProperty("options") && n.options) for (var a = 0, o = n.options; a < o.length; a++) {
                    var l = o[a];
                    if (String(l[t]) === String(e)) return l
                }
            }
            return null
        }, n.prototype.search = function (n) {
            if ("" !== (this.searchValue = n).trim()) {
                var a = this.main.config.searchFilter, e = this.data.slice(0);
                n = n.trim();
                var t = e.map(function (e) {
                    if (e.hasOwnProperty("options")) {
                        var t = e, i = [];
                        if (t.options && (i = t.options.filter(function (e) {
                            return a(e, n)
                        })), 0 !== i.length) {
                            var s = Object.assign({}, t);
                            return s.options = i, s
                        }
                    }
                    return e.hasOwnProperty("text") && a(e, n) ? e : null
                });
                this.filtered = t.filter(function (e) {
                    return e
                })
            } else this.filtered = null
        }, n);

        function n(e) {
            this.contentOpen = !1, this.contentPosition = "below", this.isOnChangeEnabled = !0, this.main = e.main, this.searchValue = "", this.data = [], this.filtered = null, this.parseSelectData(), this.setSelectedFromSelect()
        }

        function r(e) {
            return void 0 !== e.text || (console.error("Data object option must have at least have a text value. Check object: " + JSON.stringify(e)), !1)
        }

        t.Data = s, t.validateData = function (e) {
            if (!e) return console.error("Data must be an array of objects"), !1;
            for (var t = 0, i = 0, s = e; i < s.length; i++) {
                var n = s[i];
                if (n.hasOwnProperty("label")) {
                    if (n.hasOwnProperty("options")) {
                        var a = n.options;
                        if (a) for (var o = 0, l = a; o < l.length; o++) {
                            r(l[o]) || t++
                        }
                    }
                } else r(n) || t++
            }
            return 0 === t
        }, t.validateOption = r
    }, function (e, t, i) {
        "use strict";
        t.__esModule = !0;
        var s = i(3), n = i(4), a = i(5), o = i(1), l = i(0), r = (c.prototype.validate = function (e) {
            var t = "string" == typeof e.select ? document.querySelector(e.select) : e.select;
            if (!t) throw new Error("Could not find select element");
            if ("SELECT" !== t.tagName) throw new Error("Element isnt of type select");
            return t
        }, c.prototype.selected = function () {
            if (this.config.isMultiple) {
                for (var e = [], t = 0, i = n = this.data.getSelected(); t < i.length; t++) {
                    var s = i[t];
                    e.push(s.value)
                }
                return e
            }
            var n;
            return (n = this.data.getSelected()) ? n.value : ""
        }, c.prototype.set = function (e, t, i, s) {
            void 0 === t && (t = "value"), void 0 === i && (i = !0), void 0 === s && (s = !0), this.config.isMultiple && !Array.isArray(e) ? this.data.addToSelected(e, t) : this.data.setSelected(e, t), this.select.setValue(), this.data.onDataChange(), this.render(), i && this.close()
        }, c.prototype.setSelected = function (e, t, i, s) {
            void 0 === t && (t = "value"), void 0 === i && (i = !0), void 0 === s && (s = !0), this.set(e, t, i, s)
        }, c.prototype.setData = function (e) {
            if (o.validateData(e)) {
                var t = JSON.parse(JSON.stringify(e)), i = this.data.getSelected();
                if (this.config.isAjax && i) if (this.config.isMultiple) for (var s = 0, n = i.reverse(); s < n.length; s++) {
                    var a = n[s];
                    t.unshift(a)
                } else t.unshift(this.data.getSelected()), t.unshift({text: "", placeholder: !0});
                this.select.create(t), this.data.parseSelectData(), this.data.setSelectedFromSelect()
            } else console.error("Validation problem on: #" + this.select.element.id)
        }, c.prototype.addData = function (e) {
            o.validateData([e]) ? (this.data.add(this.data.newOption(e)), this.select.create(this.data.data), this.data.parseSelectData(), this.data.setSelectedFromSelect(), this.render()) : console.error("Validation problem on: #" + this.select.element.id)
        }, c.prototype.open = function () {
            var e = this;
            if (this.config.isEnabled && !this.data.contentOpen) {
                if (this.beforeOpen && this.beforeOpen(), this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.plus.classList.add("ss-cross") : this.slim.singleSelected && (this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-up")), this.slim[this.config.isMultiple ? "multiSelected" : "singleSelected"].container.classList.add("above" === this.data.contentPosition ? this.config.openAbove : this.config.openBelow), this.config.addToBody) {
                    var t = this.slim.container.getBoundingClientRect();
                    this.slim.content.style.top = t.top + t.height + window.scrollY + "px", this.slim.content.style.left = t.left + window.scrollX + "px", this.slim.content.style.width = t.width + "px"
                }
                if (this.slim.container.classList.add(this.config.open), "up" === this.config.showContent.toLowerCase() || "down" !== this.config.showContent.toLowerCase() && "above" === l.putContent(this.slim.content, this.data.contentPosition, this.data.contentOpen) ? this.moveContentAbove() : this.moveContentBelow(), !this.config.isMultiple) {
                    var i = this.data.getSelected();
                    if (i) {
                        var s = i.id, n = this.slim.list.querySelector('[data-id="' + s + '"]');
                        n && l.ensureElementInView(this.slim.list, n)
                    }
                }
                setTimeout(function () {
                    e.data.contentOpen = !0, e.config.searchFocus && e.slim.search.input.focus(), e.afterOpen && e.afterOpen()
                }, this.config.timeoutDelay)
            }
        }, c.prototype.close = function () {
            var e = this;
            this.data.contentOpen && (this.beforeClose && this.beforeClose(), this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.plus.classList.remove("ss-cross")) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-up")), this.slim.container.classList.remove(this.config.open), this.data.contentOpen = !1, this.search(""), setTimeout(function () {
                e.slim.content.removeAttribute("style"), e.data.contentPosition = "below", e.config.isMultiple && e.slim.multiSelected ? (e.slim.multiSelected.container.classList.remove(e.config.openAbove), e.slim.multiSelected.container.classList.remove(e.config.openBelow)) : e.slim.singleSelected && (e.slim.singleSelected.container.classList.remove(e.config.openAbove), e.slim.singleSelected.container.classList.remove(e.config.openBelow)), e.slim.search.input.blur(), e.afterClose && e.afterClose()
            }, this.config.timeoutDelay))
        }, c.prototype.moveContentAbove = function () {
            var e = 0;
            this.config.isMultiple && this.slim.multiSelected ? e = this.slim.multiSelected.container.offsetHeight : this.slim.singleSelected && (e = this.slim.singleSelected.container.offsetHeight);
            var t = e + this.slim.content.offsetHeight - 1;
            this.slim.content.style.margin = "-" + t + "px 0 0 0", this.slim.content.style.height = t - e + 1 + "px", this.slim.content.style.transformOrigin = "center bottom", this.data.contentPosition = "above", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.container.classList.add(this.config.openAbove)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.container.classList.add(this.config.openAbove))
        }, c.prototype.moveContentBelow = function () {
            this.data.contentPosition = "below", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.add(this.config.openBelow)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.add(this.config.openBelow))
        }, c.prototype.enable = function () {
            this.config.isEnabled = !0, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.remove(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.remove(this.config.disabled), this.select.triggerMutationObserver = !1, this.select.element.disabled = !1, this.slim.search.input.disabled = !1, this.select.triggerMutationObserver = !0
        }, c.prototype.disable = function () {
            this.config.isEnabled = !1, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.add(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.add(this.config.disabled), this.select.triggerMutationObserver = !1, this.select.element.disabled = !0, this.slim.search.input.disabled = !0, this.select.triggerMutationObserver = !0
        }, c.prototype.search = function (t) {
            if (this.data.searchValue !== t) if (this.slim.search.input.value = t, this.config.isAjax) {
                var i = this;
                this.config.isSearching = !0, this.render(), this.ajax && this.ajax(t, function (e) {
                    i.config.isSearching = !1, Array.isArray(e) ? (e.unshift({
                        text: "",
                        placeholder: !0
                    }), i.setData(e), i.data.search(t), i.render()) : "string" == typeof e ? i.slim.options(e) : i.render()
                })
            } else this.data.search(t), this.render()
        }, c.prototype.setSearchText = function (e) {
            this.config.searchText = e
        }, c.prototype.render = function () {
            this.config.isMultiple ? this.slim.values() : (this.slim.placeholder(), this.slim.deselect()), this.slim.options()
        }, c.prototype.destroy = function (e) {
            void 0 === e && (e = null);
            var t = e ? document.querySelector("." + e + ".ss-main") : this.slim.container,
                i = e ? document.querySelector("[data-ssid=" + e + "]") : this.select.element;
            if (t && i && (i.style.display = "", delete i.dataset.ssid, i.slim = null, t.parentElement && t.parentElement.removeChild(t), this.config.addToBody)) {
                var s = e ? document.querySelector("." + e + ".ss-content") : this.slim.content;
                if (!s) return;
                document.body.removeChild(s)
            }
        }, c);

        function c(e) {
            var t = this;
            this.ajax = null, this.addable = null, this.beforeOnChange = null, this.onChange = null, this.beforeOpen = null, this.afterOpen = null, this.beforeClose = null, this.afterClose = null;
            var i = this.validate(e);
            i.dataset.ssid && this.destroy(i.dataset.ssid), e.ajax && (this.ajax = e.ajax), e.addable && (this.addable = e.addable), this.config = new s.Config({
                select: i,
                isAjax: !!e.ajax,
                showSearch: e.showSearch,
                searchPlaceholder: e.searchPlaceholder,
                searchText: e.searchText,
                searchingText: e.searchingText,
                searchFocus: e.searchFocus,
                searchHighlight: e.searchHighlight,
                searchFilter: e.searchFilter,
                closeOnSelect: e.closeOnSelect,
                showContent: e.showContent,
                placeholderText: e.placeholder,
                allowDeselect: e.allowDeselect,
                allowDeselectOption: e.allowDeselectOption,
                hideSelectedOption: e.hideSelectedOption,
                deselectLabel: e.deselectLabel,
                isEnabled: e.isEnabled,
                valuesUseText: e.valuesUseText,
                showOptionTooltips: e.showOptionTooltips,
                selectByGroup: e.selectByGroup,
                limit: e.limit,
                timeoutDelay: e.timeoutDelay,
                addToBody: e.addToBody
            }), this.select = new n.Select({
                select: i,
                main: this
            }), this.data = new o.Data({main: this}), this.slim = new a.Slim({main: this}), this.select.element.parentNode && this.select.element.parentNode.insertBefore(this.slim.container, this.select.element.nextSibling), e.data ? this.setData(e.data) : this.render(), document.addEventListener("click", function (e) {
                e.target && !l.hasClassInTree(e.target, t.config.id) && t.close()
            }), "auto" === this.config.showContent && window.addEventListener("scroll", l.debounce(function (e) {
                t.data.contentOpen && ("above" === l.putContent(t.slim.content, t.data.contentPosition, t.data.contentOpen) ? t.moveContentAbove() : t.moveContentBelow())
            }), !1), e.beforeOnChange && (this.beforeOnChange = e.beforeOnChange), e.onChange && (this.onChange = e.onChange), e.beforeOpen && (this.beforeOpen = e.beforeOpen), e.afterOpen && (this.afterOpen = e.afterOpen), e.beforeClose && (this.beforeClose = e.beforeClose), e.afterClose && (this.afterClose = e.afterClose), this.config.isEnabled || this.disable()
        }

        t.default = r
    }, function (e, t, i) {
        "use strict";
        t.__esModule = !0;
        var s = (n.prototype.searchFilter = function (e, t) {
            return -1 !== e.text.toLowerCase().indexOf(t.toLowerCase())
        }, n);

        function n(e) {
            this.id = "", this.isMultiple = !1, this.isAjax = !1, this.isSearching = !1, this.showSearch = !0, this.searchFocus = !0, this.searchHighlight = !1, this.closeOnSelect = !0, this.showContent = "auto", this.searchPlaceholder = "Search", this.searchText = "No Results", this.searchingText = "Searching...", this.placeholderText = "Select Value", this.allowDeselect = !1, this.allowDeselectOption = !1, this.hideSelectedOption = !1, this.deselectLabel = "", this.isEnabled = !0, this.valuesUseText = !1, this.showOptionTooltips = !1, this.selectByGroup = !1, this.limit = 0, this.timeoutDelay = 200, this.addToBody = !1, this.main = "ss-main", this.singleSelected = "ss-single-selected", this.arrow = "ss-arrow", this.multiSelected = "ss-multi-selected", this.add = "ss-add", this.plus = "ss-plus", this.values = "ss-values", this.value = "ss-value", this.valueText = "ss-value-text", this.valueDelete = "ss-value-delete", this.content = "ss-content", this.open = "ss-open", this.openAbove = "ss-open-above", this.openBelow = "ss-open-below", this.search = "ss-search", this.searchHighlighter = "ss-search-highlight", this.addable = "ss-addable", this.list = "ss-list", this.optgroup = "ss-optgroup", this.optgroupLabel = "ss-optgroup-label", this.optgroupLabelSelectable = "ss-optgroup-label-selectable", this.option = "ss-option", this.optionSelected = "ss-option-selected", this.highlighted = "ss-highlighted", this.disabled = "ss-disabled", this.hide = "ss-hide", this.id = "ss-" + Math.floor(1e5 * Math.random()), this.style = e.select.style.cssText, this.class = e.select.className.split(" "), this.isMultiple = e.select.multiple, this.isAjax = e.isAjax, this.showSearch = !1 !== e.showSearch, this.searchFocus = !1 !== e.searchFocus, this.searchHighlight = !0 === e.searchHighlight, this.closeOnSelect = !1 !== e.closeOnSelect, e.showContent && (this.showContent = e.showContent), this.isEnabled = !1 !== e.isEnabled, e.searchPlaceholder && (this.searchPlaceholder = e.searchPlaceholder), e.searchText && (this.searchText = e.searchText), e.searchingText && (this.searchingText = e.searchingText), e.placeholderText && (this.placeholderText = e.placeholderText), this.allowDeselect = !0 === e.allowDeselect, this.allowDeselectOption = !0 === e.allowDeselectOption, this.hideSelectedOption = !0 === e.hideSelectedOption, e.deselectLabel && (this.deselectLabel = e.deselectLabel), e.valuesUseText && (this.valuesUseText = e.valuesUseText), e.showOptionTooltips && (this.showOptionTooltips = e.showOptionTooltips), e.selectByGroup && (this.selectByGroup = e.selectByGroup), e.limit && (this.limit = e.limit), e.searchFilter && (this.searchFilter = e.searchFilter), null != e.timeoutDelay && (this.timeoutDelay = e.timeoutDelay), this.addToBody = !0 === e.addToBody
        }

        t.Config = s
    }, function (e, t, i) {
        "use strict";
        t.__esModule = !0;
        var s = i(0), n = (a.prototype.setValue = function () {
            if (this.main.data.getSelected()) {
                if (this.main.config.isMultiple) for (var e = this.main.data.getSelected(), t = 0, i = this.element.options; t < i.length; t++) {
                    var s = i[t];
                    s.selected = !1;
                    for (var n = 0, a = e; n < a.length; n++) a[n].value === s.value && (s.selected = !0)
                } else e = this.main.data.getSelected(), this.element.value = e ? e.value : "";
                this.main.data.isOnChangeEnabled = !1, this.element.dispatchEvent(new CustomEvent("change", {bubbles: !0})), this.main.data.isOnChangeEnabled = !0
            }
        }, a.prototype.addAttributes = function () {
            this.element.tabIndex = -1, this.element.style.display = "none", this.element.dataset.ssid = this.main.config.id
        }, a.prototype.addEventListeners = function () {
            var t = this;
            this.element.addEventListener("change", function (e) {
                t.main.data.setSelectedFromSelect(), t.main.render()
            })
        }, a.prototype.addMutationObserver = function () {
            var t = this;
            this.main.config.isAjax || (this.mutationObserver = new MutationObserver(function (e) {
                t.triggerMutationObserver && (t.main.data.parseSelectData(), t.main.data.setSelectedFromSelect(), t.main.render(), e.forEach(function (e) {
                    "class" === e.attributeName && t.main.slim.updateContainerDivClass(t.main.slim.container)
                }))
            }), this.observeMutationObserver())
        }, a.prototype.observeMutationObserver = function () {
            this.mutationObserver && this.mutationObserver.observe(this.element, {
                attributes: !0,
                childList: !0,
                characterData: !0
            })
        }, a.prototype.disconnectMutationObserver = function () {
            this.mutationObserver && this.mutationObserver.disconnect()
        }, a.prototype.create = function (e) {
            this.element.innerHTML = "";
            for (var t = 0, i = e; t < i.length; t++) {
                var s = i[t];
                if (s.hasOwnProperty("options")) {
                    var n = s, a = document.createElement("optgroup");
                    if (a.label = n.label, n.options) for (var o = 0, l = n.options; o < l.length; o++) {
                        var r = l[o];
                        a.appendChild(this.createOption(r))
                    }
                    this.element.appendChild(a)
                } else this.element.appendChild(this.createOption(s))
            }
        }, a.prototype.createOption = function (t) {
            var i = document.createElement("option");
            return i.value = "" !== t.value ? t.value : t.text, i.innerHTML = t.innerHTML || t.text, t.selected && (i.selected = t.selected), !1 === t.display && (i.style.display = "none"), t.disabled && (i.disabled = !0), t.placeholder && i.setAttribute("data-placeholder", "true"), t.mandatory && i.setAttribute("data-mandatory", "true"), t.class && t.class.split(" ").forEach(function (e) {
                i.classList.add(e)
            }), t.data && "object" == typeof t.data && Object.keys(t.data).forEach(function (e) {
                i.setAttribute("data-" + s.kebabCase(e), t.data[e])
            }), i
        }, a);

        function a(e) {
            this.triggerMutationObserver = !0, this.element = e.select, this.main = e.main, this.element.disabled && (this.main.config.isEnabled = !1), this.addAttributes(), this.addEventListeners(), this.mutationObserver = null, this.addMutationObserver(), this.element.slim = e.main
        }

        t.Select = n
    }, function (e, t, i) {
        "use strict";
        t.__esModule = !0;
        var a = i(0), o = i(1), s = (n.prototype.containerDiv = function () {
            var e = document.createElement("div");
            return e.style.cssText = this.main.config.style, this.updateContainerDivClass(e), e
        }, n.prototype.updateContainerDivClass = function (e) {
            this.main.config.class = this.main.select.element.className.split(" "), e.className = "", e.classList.add(this.main.config.id), e.classList.add(this.main.config.main);
            for (var t = 0, i = this.main.config.class; t < i.length; t++) {
                var s = i[t];
                "" !== s.trim() && e.classList.add(s)
            }
        }, n.prototype.singleSelectedDiv = function () {
            var t = this, e = document.createElement("div");
            e.classList.add(this.main.config.singleSelected);
            var i = document.createElement("span");
            i.classList.add("placeholder"), e.appendChild(i);
            var s = document.createElement("span");
            s.innerHTML = this.main.config.deselectLabel, s.classList.add("ss-deselect"), s.onclick = function (e) {
                e.stopPropagation(), t.main.config.isEnabled && t.main.set("")
            }, e.appendChild(s);
            var n = document.createElement("span");
            n.classList.add(this.main.config.arrow);
            var a = document.createElement("span");
            return a.classList.add("arrow-down"), n.appendChild(a), e.appendChild(n), e.onclick = function () {
                t.main.config.isEnabled && (t.main.data.contentOpen ? t.main.close() : t.main.open())
            }, {container: e, placeholder: i, deselect: s, arrowIcon: {container: n, arrow: a}}
        }, n.prototype.placeholder = function () {
            var e = this.main.data.getSelected();
            if (null === e || e && e.placeholder) {
                var t = document.createElement("span");
                t.classList.add(this.main.config.disabled), t.innerHTML = this.main.config.placeholderText, this.singleSelected && (this.singleSelected.placeholder.innerHTML = t.outerHTML)
            } else {
                var i = "";
                e && (i = e.innerHTML && !0 !== this.main.config.valuesUseText ? e.innerHTML : e.text), this.singleSelected && (this.singleSelected.placeholder.innerHTML = e ? i : "")
            }
        }, n.prototype.deselect = function () {
            if (this.singleSelected) {
                if (!this.main.config.allowDeselect) return void this.singleSelected.deselect.classList.add("ss-hide");
                "" === this.main.selected() ? this.singleSelected.deselect.classList.add("ss-hide") : this.singleSelected.deselect.classList.remove("ss-hide")
            }
        }, n.prototype.multiSelectedDiv = function () {
            var t = this, e = document.createElement("div");
            e.classList.add(this.main.config.multiSelected);
            var i = document.createElement("div");
            i.classList.add(this.main.config.values), e.appendChild(i);
            var s = document.createElement("div");
            s.classList.add(this.main.config.add);
            var n = document.createElement("span");
            return n.classList.add(this.main.config.plus), s.onclick = function (e) {
                t.main.data.contentOpen && (t.main.close(), e.stopPropagation())
            }, s.appendChild(n), e.appendChild(s), e.onclick = function (e) {
                t.main.config.isEnabled && (e.target.classList.contains(t.main.config.valueDelete) || (!t.main.data.contentOpen && t.main.open()))
            }, {container: e, values: i, add: s, plus: n}
        }, n.prototype.values = function () {
            if (this.multiSelected) {
                for (var e, t = this.multiSelected.values.childNodes, i = this.main.data.getSelected(), s = [], n = 0, a = t; n < a.length; n++) {
                    var o = a[n];
                    e = !0;
                    for (var l = 0, r = i; l < r.length; l++) {
                        var c = r[l];
                        String(c.id) === String(o.dataset.id) && (e = !1)
                    }
                    e && s.push(o)
                }
                for (var d = 0, h = s; d < h.length; d++) {
                    var u = h[d];
                    u.classList.add("ss-out"), this.multiSelected.values.removeChild(u)
                }
                for (t = this.multiSelected.values.childNodes, c = 0; c < i.length; c++) {
                    e = !1;
                    for (var p = 0, m = t; p < m.length; p++) o = m[p], String(i[c].id) === String(o.dataset.id) && (e = !0);
                    e || (0 !== t.length && HTMLElement.prototype.insertAdjacentElement ? 0 === c ? this.multiSelected.values.insertBefore(this.valueDiv(i[c]), t[c]) : t[c - 1].insertAdjacentElement("afterend", this.valueDiv(i[c])) : this.multiSelected.values.appendChild(this.valueDiv(i[c])))
                }
                if (0 === i.length) {
                    var f = document.createElement("span");
                    f.classList.add(this.main.config.disabled), f.innerHTML = this.main.config.placeholderText, this.multiSelected.values.innerHTML = f.outerHTML
                }
            }
        }, n.prototype.valueDiv = function (a) {
            var o = this, e = document.createElement("div");
            e.classList.add(this.main.config.value), e.dataset.id = a.id;
            var t = document.createElement("span");
            if (t.classList.add(this.main.config.valueText), t.innerHTML = a.innerHTML && !0 !== this.main.config.valuesUseText ? a.innerHTML : a.text, e.appendChild(t), !a.mandatory) {
                var i = document.createElement("span");
                i.classList.add(this.main.config.valueDelete), i.innerHTML = this.main.config.deselectLabel, i.onclick = function (e) {
                    e.preventDefault(), e.stopPropagation();
                    var t = !1;
                    if (o.main.beforeOnChange || (t = !0), o.main.beforeOnChange) {
                        for (var i = o.main.data.getSelected(), s = JSON.parse(JSON.stringify(i)), n = 0; n < s.length; n++) s[n].id === a.id && s.splice(n, 1);
                        !1 !== o.main.beforeOnChange(s) && (t = !0)
                    }
                    t && (o.main.data.removeFromSelected(a.id, "id"), o.main.render(), o.main.select.setValue(), o.main.data.onDataChange())
                }, e.appendChild(i)
            }
            return e
        }, n.prototype.contentDiv = function () {
            var e = document.createElement("div");
            return e.classList.add(this.main.config.content), e
        }, n.prototype.searchDiv = function () {
            var n = this, e = document.createElement("div"), s = document.createElement("input"),
                a = document.createElement("div");
            e.classList.add(this.main.config.search);
            var t = {container: e, input: s};
            return this.main.config.showSearch || (e.classList.add(this.main.config.hide), s.readOnly = !0), s.type = "text", s.placeholder = this.main.config.searchPlaceholder, s.tabIndex = 0, s.setAttribute("aria-label", this.main.config.searchPlaceholder), s.setAttribute("autocapitalize", "off"), s.setAttribute("autocomplete", "off"), s.setAttribute("autocorrect", "off"), s.onclick = function (e) {
                setTimeout(function () {
                    "" === e.target.value && n.main.search("")
                }, 10)
            }, s.onkeydown = function (e) {
                "ArrowUp" === e.key ? (n.main.open(), n.highlightUp(), e.preventDefault()) : "ArrowDown" === e.key ? (n.main.open(), n.highlightDown(), e.preventDefault()) : "Tab" === e.key ? n.main.data.contentOpen ? n.main.close() : setTimeout(function () {
                    n.main.close()
                }, n.main.config.timeoutDelay) : "Enter" === e.key && e.preventDefault()
            }, s.onkeyup = function (e) {
                var t = e.target;
                if ("Enter" === e.key) {
                    if (n.main.addable && e.ctrlKey) return a.click(), e.preventDefault(), void e.stopPropagation();
                    var i = n.list.querySelector("." + n.main.config.highlighted);
                    i && i.click()
                } else "ArrowUp" === e.key || "ArrowDown" === e.key || ("Escape" === e.key ? n.main.close() : n.main.config.showSearch && n.main.data.contentOpen ? n.main.search(t.value) : s.value = "");
                e.preventDefault(), e.stopPropagation()
            }, s.onfocus = function () {
                n.main.open()
            }, e.appendChild(s), this.main.addable && (a.classList.add(this.main.config.addable), a.innerHTML = "<i class='fal fa-plus'></i>", a.onclick = function (e) {
                if (n.main.addable) {
                    e.preventDefault(), e.stopPropagation();
                    var t = n.search.input.value;
                    if ("" === t.trim()) return void n.search.input.focus();
                    var i = n.main.addable(t), s = "";
                    if (!i) return;
                    "object" == typeof i ? o.validateOption(i) && (n.main.addData(i), s = i.value ? i.value : i.text) : (n.main.addData(n.main.data.newOption({
                        text: i,
                        value: i
                    })), s = i), n.main.search(""), setTimeout(function () {
                        n.main.set(s, "value", !1, !1)
                    }, 100), n.main.config.closeOnSelect && setTimeout(function () {
                        n.main.close()
                    }, 100)
                }
            }, e.appendChild(a), t.addable = a), t
        }, n.prototype.highlightUp = function () {
            var e = this.list.querySelector("." + this.main.config.highlighted), t = null;
            if (e) for (t = e.previousSibling; null !== t && t.classList.contains(this.main.config.disabled);) t = t.previousSibling; else {
                var i = this.list.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")");
                t = i[i.length - 1]
            }
            if (t && t.classList.contains(this.main.config.optgroupLabel) && (t = null), null === t) {
                var s = e.parentNode;
                if (s.classList.contains(this.main.config.optgroup) && s.previousSibling) {
                    var n = s.previousSibling.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")");
                    n.length && (t = n[n.length - 1])
                }
            }
            t && (e && e.classList.remove(this.main.config.highlighted), t.classList.add(this.main.config.highlighted), a.ensureElementInView(this.list, t))
        }, n.prototype.highlightDown = function () {
            var e = this.list.querySelector("." + this.main.config.highlighted), t = null;
            if (e) for (t = e.nextSibling; null !== t && t.classList.contains(this.main.config.disabled);) t = t.nextSibling; else t = this.list.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")");
            if (null === t && null !== e) {
                var i = e.parentNode;
                i.classList.contains(this.main.config.optgroup) && i.nextSibling && (t = i.nextSibling.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")"))
            }
            t && (e && e.classList.remove(this.main.config.highlighted), t.classList.add(this.main.config.highlighted), a.ensureElementInView(this.list, t))
        }, n.prototype.listDiv = function () {
            var e = document.createElement("div");
            return e.classList.add(this.main.config.list), e
        }, n.prototype.options = function (e) {
            void 0 === e && (e = "");
            var t, i = this.main.data.filtered || this.main.data.data;
            if ((this.list.innerHTML = "") !== e) return (t = document.createElement("div")).classList.add(this.main.config.option), t.classList.add(this.main.config.disabled), t.innerHTML = e, void this.list.appendChild(t);
            if (this.main.config.isAjax && this.main.config.isSearching) return (t = document.createElement("div")).classList.add(this.main.config.option), t.classList.add(this.main.config.disabled), t.innerHTML = this.main.config.searchingText, void this.list.appendChild(t);
            if (0 === i.length) {
                var s = document.createElement("div");
                return s.classList.add(this.main.config.option), s.classList.add(this.main.config.disabled), s.innerHTML = this.main.config.searchText, void this.list.appendChild(s)
            }
            for (var n = function (e) {
                if (e.hasOwnProperty("label")) {
                    var t = e, n = document.createElement("div");
                    n.classList.add(c.main.config.optgroup);
                    var i = document.createElement("div");
                    i.classList.add(c.main.config.optgroupLabel), c.main.config.selectByGroup && c.main.config.isMultiple && i.classList.add(c.main.config.optgroupLabelSelectable), i.innerHTML = t.label, n.appendChild(i);
                    var s = t.options;
                    if (s) {
                        for (var a = 0, o = s; a < o.length; a++) {
                            var l = o[a];
                            n.appendChild(c.option(l))
                        }
                        if (c.main.config.selectByGroup && c.main.config.isMultiple) {
                            var r = c;
                            i.addEventListener("click", function (e) {
                                e.preventDefault(), e.stopPropagation();
                                for (var t = 0, i = n.children; t < i.length; t++) {
                                    var s = i[t];
                                    -1 !== s.className.indexOf(r.main.config.option) && s.click()
                                }
                            })
                        }
                    }
                    c.list.appendChild(n)
                } else c.list.appendChild(c.option(e))
            }, c = this, a = 0, o = i; a < o.length; a++) n(o[a])
        }, n.prototype.option = function (r) {
            if (r.placeholder) {
                var e = document.createElement("div");
                return e.classList.add(this.main.config.option), e.classList.add(this.main.config.hide), e
            }
            var t = document.createElement("div");
            t.classList.add(this.main.config.option), r.class && r.class.split(" ").forEach(function (e) {
                t.classList.add(e)
            }), r.style && (t.style.cssText = r.style);
            var c = this.main.data.getSelected();
            t.dataset.id = r.id, this.main.config.searchHighlight && this.main.slim && r.innerHTML && "" !== this.main.slim.search.input.value.trim() ? t.innerHTML = a.highlight(r.innerHTML, this.main.slim.search.input.value, this.main.config.searchHighlighter) : r.innerHTML && (t.innerHTML = r.innerHTML), this.main.config.showOptionTooltips && t.textContent && t.setAttribute("title", t.textContent);
            var d = this;
            t.addEventListener("click", function (e) {
                e.preventDefault(), e.stopPropagation();
                var t = this.dataset.id;
                if (!0 === r.selected && d.main.config.allowDeselectOption) {
                    var i = !1;
                    if (d.main.beforeOnChange && d.main.config.isMultiple || (i = !0), d.main.beforeOnChange && d.main.config.isMultiple) {
                        for (var s = d.main.data.getSelected(), n = JSON.parse(JSON.stringify(s)), a = 0; a < n.length; a++) n[a].id === t && n.splice(a, 1);
                        !1 !== d.main.beforeOnChange(n) && (i = !0)
                    }
                    i && (d.main.config.isMultiple ? (d.main.data.removeFromSelected(t, "id"), d.main.render(), d.main.select.setValue(), d.main.data.onDataChange()) : d.main.set(""))
                } else {
                    if (r.disabled || r.selected) return;
                    if (d.main.config.limit && Array.isArray(c) && d.main.config.limit <= c.length) return;
                    if (d.main.beforeOnChange) {
                        var o = void 0, l = JSON.parse(JSON.stringify(d.main.data.getObjectFromData(t)));
                        l.selected = !0, d.main.config.isMultiple ? (o = JSON.parse(JSON.stringify(c))).push(l) : o = JSON.parse(JSON.stringify(l)), !1 !== d.main.beforeOnChange(o) && d.main.set(t, "id", d.main.config.closeOnSelect)
                    } else d.main.set(t, "id", d.main.config.closeOnSelect)
                }
            });
            var i = c && a.isValueInArrayOfObjects(c, "id", r.id);
            return (r.disabled || i) && (t.onclick = null, d.main.config.allowDeselectOption || t.classList.add(this.main.config.disabled), d.main.config.hideSelectedOption && t.classList.add(this.main.config.hide)), i ? t.classList.add(this.main.config.optionSelected) : t.classList.remove(this.main.config.optionSelected), t
        }, n);

        function n(e) {
            this.main = e.main, this.container = this.containerDiv(), this.content = this.contentDiv(), this.search = this.searchDiv(), this.list = this.listDiv(), this.options(), this.singleSelected = null, this.multiSelected = null, this.main.config.isMultiple ? (this.multiSelected = this.multiSelectedDiv(), this.multiSelected && this.container.appendChild(this.multiSelected.container)) : (this.singleSelected = this.singleSelectedDiv(), this.container.appendChild(this.singleSelected.container)), this.main.config.addToBody ? (this.content.classList.add(this.main.config.id), document.body.appendChild(this.content)) : this.container.appendChild(this.content), this.content.appendChild(this.search.container), this.content.appendChild(this.list)
        }

        t.Slim = s
    }], n.c = s, n.d = function (e, t, i) {
        n.o(e, t) || Object.defineProperty(e, t, {enumerable: !0, get: i})
    }, n.r = function (e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
    }, n.t = function (t, e) {
        if (1 & e && (t = n(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var i = Object.create(null);
        if (n.r(i), Object.defineProperty(i, "default", {
            enumerable: !0,
            value: t
        }), 2 & e && "string" != typeof t) for (var s in t) n.d(i, s, function (e) {
            return t[e]
        }.bind(null, s));
        return i
    }, n.n = function (e) {
        var t = e && e.__esModule ? function () {
            return e.default
        } : function () {
            return e
        };
        return n.d(t, "a", t), t
    }, n.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, n.p = "", n(n.s = 2).default;

    function n(e) {
        if (s[e]) return s[e].exports;
        var t = s[e] = {i: e, l: !1, exports: {}};
        return i[e].call(t.exports, t, t.exports, n), t.l = !0, t.exports
    }

    var i, s
});

//ForJquery

jQuery.fn.slimSelect = function (f) {
    this.each(function (e) {
        var d = slimCustom.apply(this, [f]);
        d.showSearch = this.children.length > 10;
        d.searchFilter = function (o, s) {
            var text = o.text.toLowerCase()
                .replace(/[ёэ]/g, 'е')
                .replace(/[^а-яa-z0-9]/g, '');
            var search = s.toLowerCase()
                .replace(/[ёэ]/g, 'е')
                .replace(/[^а-яa-z0-9]/g, '');
            return text.indexOf(search) !== -1;
        }
        new SlimSelect(d)
    })
    return this;
};

var si = null;
jQuery.fn.slimSelectAjax = function (aj) {
    this.each(function (e) {
        var d = slimCustom.apply(this, []);
        d.searchingText = 'Поиск...';
        d.ajax = function (search, callback) {
            clearTimeout(si);
            if (search.length < 3) {
                callback('Введите не менее 3-х символов')
                return
            }
            si = setTimeout(function () {
                aj(search, callback)
            }, 500);
        }

        new SlimSelect(d)
    })
    return this;
};

function slimCustom(f) {
    var t = $(this)
    var d = {
        select: this,
        searchPlaceholder: 'Искать',
        searchText: 'Ничего не найдено',
        placeholder: t.data('placeholder'),
        showContent: 'down'
    }
    if (window.screen.width <= 768) {
        if (this.multiple) {
            d.allowDeselectOption = true;
            d.closeOnSelect = false;
        }
        d.beforeOpen = function () {
            this.select.element.style.display = "block"
            document.body.style.overflow = 'hidden';
        }
        d.beforeClose = function () {
            this.select.element.style.display = "none"
            document.body.style.overflow = '';
        }
    }
    if (t.data('addable')) {
        if (f) {
            d.addable = f
        } else {
            d.addable = function (value) {
                return value;
            }
        }
    }
    return d
}

jQuery.fn.slimSet = function (v) {
    this.each(function (e) {
        if (this.slim.selected() != v && this.innerHTML.indexOf('value="' + v + '"') > -1) {
            this.slim.set(v);
        }
    })
    return this;
};

jQuery.fn.slimDestroy = function () {
    this.each(function (e) {
        this.slim.destroy();
    })
    return this;
};
/*!
	autosize 4.0.2
	license: MIT
	http://www.jacklmoore.com/autosize
*/
!function(e,t){if("function"==typeof define&&define.amd)define(["module","exports"],t);else if("undefined"!=typeof exports)t(module,exports);else{var n={exports:{}};t(n,n.exports),e.autosize=n.exports}}(this,function(e,t){"use strict";var n,o,p="function"==typeof Map?new Map:(n=[],o=[],{has:function(e){return-1<n.indexOf(e)},get:function(e){return o[n.indexOf(e)]},set:function(e,t){-1===n.indexOf(e)&&(n.push(e),o.push(t))},delete:function(e){var t=n.indexOf(e);-1<t&&(n.splice(t,1),o.splice(t,1))}}),c=function(e){return new Event(e,{bubbles:!0})};try{new Event("test")}catch(e){c=function(e){var t=document.createEvent("Event");return t.initEvent(e,!0,!1),t}}function r(r){if(r&&r.nodeName&&"TEXTAREA"===r.nodeName&&!p.has(r)){var e,n=null,o=null,i=null,d=function(){r.clientWidth!==o&&a()},l=function(t){window.removeEventListener("resize",d,!1),r.removeEventListener("input",a,!1),r.removeEventListener("keyup",a,!1),r.removeEventListener("autosize:destroy",l,!1),r.removeEventListener("autosize:update",a,!1),Object.keys(t).forEach(function(e){r.style[e]=t[e]}),p.delete(r)}.bind(r,{height:r.style.height,resize:r.style.resize,overflowY:r.style.overflowY,overflowX:r.style.overflowX,wordWrap:r.style.wordWrap});r.addEventListener("autosize:destroy",l,!1),"onpropertychange"in r&&"oninput"in r&&r.addEventListener("keyup",a,!1),window.addEventListener("resize",d,!1),r.addEventListener("input",a,!1),r.addEventListener("autosize:update",a,!1),r.style.overflowX="hidden",r.style.wordWrap="break-word",p.set(r,{destroy:l,update:a}),"vertical"===(e=window.getComputedStyle(r,null)).resize?r.style.resize="none":"both"===e.resize&&(r.style.resize="horizontal"),n="content-box"===e.boxSizing?-(parseFloat(e.paddingTop)+parseFloat(e.paddingBottom)):parseFloat(e.borderTopWidth)+parseFloat(e.borderBottomWidth),isNaN(n)&&(n=0),a()}function s(e){var t=r.style.width;r.style.width="0px",r.offsetWidth,r.style.width=t,r.style.overflowY=e}function u(){if(0!==r.scrollHeight){var e=function(e){for(var t=[];e&&e.parentNode&&e.parentNode instanceof Element;)e.parentNode.scrollTop&&t.push({node:e.parentNode,scrollTop:e.parentNode.scrollTop}),e=e.parentNode;return t}(r),t=document.documentElement&&document.documentElement.scrollTop;r.style.height="",r.style.height=r.scrollHeight+n+"px",o=r.clientWidth,e.forEach(function(e){e.node.scrollTop=e.scrollTop}),t&&(document.documentElement.scrollTop=t)}}function a(){u();var e=Math.round(parseFloat(r.style.height)),t=window.getComputedStyle(r,null),n="content-box"===t.boxSizing?Math.round(parseFloat(t.height)):r.offsetHeight;if(n<e?"hidden"===t.overflowY&&(s("scroll"),u(),n="content-box"===t.boxSizing?Math.round(parseFloat(window.getComputedStyle(r,null).height)):r.offsetHeight):"hidden"!==t.overflowY&&(s("hidden"),u(),n="content-box"===t.boxSizing?Math.round(parseFloat(window.getComputedStyle(r,null).height)):r.offsetHeight),i!==n){i=n;var o=c("autosize:resized");try{r.dispatchEvent(o)}catch(e){}}}}function i(e){var t=p.get(e);t&&t.destroy()}function d(e){var t=p.get(e);t&&t.update()}var l=null;"undefined"==typeof window||"function"!=typeof window.getComputedStyle?((l=function(e){return e}).destroy=function(e){return e},l.update=function(e){return e}):((l=function(e,t){return e&&Array.prototype.forEach.call(e.length?e:[e],function(e){return r(e)}),e}).destroy=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],i),e},l.update=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],d),e}),t.default=l,e.exports=t.default});
/*!
 * Autolinker.js
 * 1.7.1
 *
 * Copyright(c) 2018 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT License
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
;(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Autolinker = factory();
  }
}(this, function() {
/**
 * @class Autolinker
 * @extends Object
 *
 * Utility class used to process a given string of text, and wrap the matches in
 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
 *
 * Any of the configuration options may be provided in an Object (map) provided
 * to the Autolinker constructor, which will configure how the {@link #link link()}
 * method will process the links.
 *
 * For example:
 *
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *
 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * The {@link #static-link static link()} method may also be used to inline
 * options into a single call, which may be more convenient for one-off uses.
 * For example:
 *
 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * ## Custom Replacements of Links
 *
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn}
 * may be provided to fully customize the output of Autolinker. This function is
 * called once for each URL/Email/Phone#/Hashtag/Mention (Twitter, Instagram)
 * match that is encountered.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, Phone #s, Hashtags, and Mentions (Twitter, Instagram)
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
 *                         var tag = match.buildTag();  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( 'rel', 'nofollow' );
 *                         tag.addClass( 'external-link' );
 *
 *                         return tag;
 *
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *
 *                 case 'email' :
 *                     var email = match.getEmail();
 *                     console.log( "email: ", email );
 *
 *                     if( email === "my@own.address" ) {
 *                         return false;  // don't auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *
 *                 case 'phone' :
 *                     var phoneNumber = match.getPhoneNumber();
 *                     console.log( phoneNumber );
 *
 *                     return '<a href="http://newplace.to.link.phone.numbers.to/">' + phoneNumber + '</a>';
 *
 *                 case 'hashtag' :
 *                     var hashtag = match.getHashtag();
 *                     console.log( hashtag );
 *
 *                     return '<a href="http://newplace.to.link.hashtag.handles.to/">' + hashtag + '</a>';
 *
 *                 case 'mention' :
 *                     var mention = match.getMention();
 *                     console.log( mention );
 *
 *                     return '<a href="http://newplace.to.link.mention.to/">' + mention + '</a>';
 *             }
 *         }
 *     } );
 *
 *
 * The function may return the following values:
 *
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally
 *   would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be
 *   used directly as the replacement HTML for the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify
 *   an HTML tag before writing out its HTML text.
 *
 * @constructor
 * @param {Object} [cfg] The configuration options for the Autolinker instance,
 *   specified in an Object (map).
 */
var Autolinker = function( cfg ) {
	cfg = cfg || {};

	this.version = Autolinker.version;

	this.urls = this.normalizeUrlsCfg( cfg.urls );
	this.email = typeof cfg.email === 'boolean' ? cfg.email : true;
	this.phone = typeof cfg.phone === 'boolean' ? cfg.phone : true;
	this.hashtag = cfg.hashtag || false;
	this.mention = cfg.mention || false;
	this.newWindow = typeof cfg.newWindow === 'boolean' ? cfg.newWindow : true;
	this.stripPrefix = this.normalizeStripPrefixCfg( cfg.stripPrefix );
	this.stripTrailingSlash = typeof cfg.stripTrailingSlash === 'boolean' ? cfg.stripTrailingSlash : true;
	this.decodePercentEncoding = typeof cfg.decodePercentEncoding === 'boolean' ? cfg.decodePercentEncoding : true;

	// Validate the value of the `mention` cfg
	var mention = this.mention;
	if( mention !== false && mention !== 'twitter' && mention !== 'instagram' ) {
		throw new Error( "invalid `mention` cfg - see docs" );
	}

	// Validate the value of the `hashtag` cfg
	var hashtag = this.hashtag;
	if( hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram' ) {
		throw new Error( "invalid `hashtag` cfg - see docs" );
	}

	this.truncate = this.normalizeTruncateCfg( cfg.truncate );
	this.className = cfg.className || '';
	this.replaceFn = cfg.replaceFn || null;
	this.context = cfg.context || this;

	this.htmlParser = null;
	this.matchers = null;
	this.tagBuilder = null;
};



/**
 * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,
 * Hashtags, and Mentions found in the given chunk of HTML. Does not link URLs
 * found within HTML tags.
 *
 * For instance, if given the text: `You should go to http://www.yahoo.com`,
 * then the result will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
 *
 * Example:
 *
 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
 *
 * @static
 * @param {String} textOrHtml The HTML or text to find matches within (depending
 *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #mention},
 *   {@link #hashtag}, and {@link #mention} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker
 *   class, specified in an Object (map). See the class description for an
 *   example call.
 * @return {String} The HTML text, with matches automatically linked.
 */
Autolinker.link = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.link( textOrHtml );
};



/**
 * Parses the input `textOrHtml` looking for URLs, email addresses, phone
 * numbers, username handles, and hashtags (depending on the configuration
 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
 * objects describing those matches (without making any replacements).
 *
 * Note that if parsing multiple pieces of text, it is slightly more efficient
 * to create an Autolinker instance, and use the instance-level {@link #parse}
 * method.
 *
 * Example:
 *
 *     var matches = Autolinker.parse( "Hello google.com, I am asdf@asdf.com", {
 *         urls: true,
 *         email: true
 *     } );
 *
 *     console.log( matches.length );           // 2
 *     console.log( matches[ 0 ].getType() );   // 'url'
 *     console.log( matches[ 0 ].getUrl() );    // 'google.com'
 *     console.log( matches[ 1 ].getType() );   // 'email'
 *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'
 *
 * @static
 * @param {String} textOrHtml The HTML or text to find matches within
 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
 *   {@link #hashtag}, and {@link #mention} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker
 *   class, specified in an Object (map). See the class description for an
 *   example call.
 * @return {Autolinker.match.Match[]} The array of Matches found in the
 *   given input `textOrHtml`.
 */
Autolinker.parse = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.parse( textOrHtml );
};


/**
 * @static
 * @property {String} version (readonly)
 *
 * The Autolinker version number in the form major.minor.patch
 *
 * Ex: 0.25.1
 */
Autolinker.version = '1.7.1';


Autolinker.prototype = {
	constructor : Autolinker,  // fix constructor property

	/**
	 * @cfg {Boolean/Object} [urls]
	 *
	 * `true` if URLs should be automatically linked, `false` if they should not
	 * be. Defaults to `true`.
	 *
	 * Examples:
	 *
	 *     urls: true
	 *
	 *     // or
	 *
	 *     urls: {
	 *         schemeMatches : true,
	 *         wwwMatches    : true,
	 *         tldMatches    : true
	 *     }
	 *
	 * As shown above, this option also accepts an Object form with 3 properties
	 * to allow for more customization of what exactly gets linked. All default
	 * to `true`:
	 *
	 * @cfg {Boolean} [urls.schemeMatches] `true` to match URLs found prefixed
	 *   with a scheme, i.e. `http://google.com`, or `other+scheme://google.com`,
	 *   `false` to prevent these types of matches.
	 * @cfg {Boolean} [urls.wwwMatches] `true` to match urls found prefixed with
	 *   `'www.'`, i.e. `www.google.com`. `false` to prevent these types of
	 *   matches. Note that if the URL had a prefixed scheme, and
	 *   `schemeMatches` is true, it will still be linked.
	 * @cfg {Boolean} [urls.tldMatches] `true` to match URLs with known top
	 *   level domains (.com, .net, etc.) that are not prefixed with a scheme or
	 *   `'www.'`. This option attempts to match anything that looks like a URL
	 *   in the given text. Ex: `google.com`, `asdf.org/?page=1`, etc. `false`
	 *   to prevent these types of matches.
	 */

	/**
	 * @cfg {Boolean} [email=true]
	 *
	 * `true` if email addresses should be automatically linked, `false` if they
	 * should not be.
	 */

	/**
	 * @cfg {Boolean} [phone=true]
	 *
	 * `true` if Phone numbers ("(555)555-5555") should be automatically linked,
	 * `false` if they should not be.
	 */

	/**
	 * @cfg {Boolean/String} [hashtag=false]
	 *
	 * A string for the service name to have hashtags (ex: "#myHashtag")
	 * auto-linked to. The currently-supported values are:
	 *
	 * - 'twitter'
	 * - 'facebook'
	 * - 'instagram'
	 *
	 * Pass `false` to skip auto-linking of hashtags.
	 */

	/**
	 * @cfg {String/Boolean} [mention=false]
	 *
	 * A string for the service name to have mentions (ex: "@myuser")
	 * auto-linked to. The currently supported values are:
	 *
	 * - 'twitter'
	 * - 'instagram'
	 *
	 * Defaults to `false` to skip auto-linking of mentions.
	 */

	/**
	 * @cfg {Boolean} [newWindow=true]
	 *
	 * `true` if the links should open in a new window, `false` otherwise.
	 */

	/**
	 * @cfg {Boolean/Object} [stripPrefix]
	 *
	 * `true` if 'http://' (or 'https://') and/or the 'www.' should be stripped
	 * from the beginning of URL links' text, `false` otherwise. Defaults to
	 * `true`.
	 *
	 * Examples:
	 *
	 *     stripPrefix: true
	 *
	 *     // or
	 *
	 *     stripPrefix: {
	 *         scheme : true,
	 *         www    : true
	 *     }
	 *
	 * As shown above, this option also accepts an Object form with 2 properties
	 * to allow for more customization of what exactly is prevented from being
	 * displayed. Both default to `true`:
	 *
	 * @cfg {Boolean} [stripPrefix.scheme] `true` to prevent the scheme part of
	 *   a URL match from being displayed to the user. Example:
	 *   `'http://google.com'` will be displayed as `'google.com'`. `false` to
	 *   not strip the scheme. NOTE: Only an `'http://'` or `'https://'` scheme
	 *   will be removed, so as not to remove a potentially dangerous scheme
	 *   (such as `'file://'` or `'javascript:'`)
	 * @cfg {Boolean} [stripPrefix.www] www (Boolean): `true` to prevent the
	 *   `'www.'` part of a URL match from being displayed to the user. Ex:
	 *   `'www.google.com'` will be displayed as `'google.com'`. `false` to not
	 *   strip the `'www'`.
	 */

	/**
	 * @cfg {Boolean} [stripTrailingSlash=true]
	 *
	 * `true` to remove the trailing slash from URL matches, `false` to keep
	 *  the trailing slash.
	 *
	 *  Example when `true`: `http://google.com/` will be displayed as
	 *  `http://google.com`.
	 */

	/**
	 * @cfg {Boolean} [decodePercentEncoding=true]
	 *
	 * `true` to decode percent-encoded characters in URL matches, `false` to keep
	 *  the percent-encoded characters.
	 *
	 *  Example when `true`: `https://en.wikipedia.org/wiki/San_Jos%C3%A9` will
	 *  be displayed as `https://en.wikipedia.org/wiki/San_José`.
	 */

	/**
	 * @cfg {Number/Object} [truncate=0]
	 *
	 * ## Number Form
	 *
	 * A number for how many characters matched text should be truncated to
	 * inside the text of a link. If the matched text is over this number of
	 * characters, it will be truncated to this length by adding a two period
	 * ellipsis ('..') to the end of the string.
	 *
	 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file'
	 * truncated to 25 characters might look something like this:
	 * 'yahoo.com/some/long/pat..'
	 *
	 * Example Usage:
	 *
	 *     truncate: 25
	 *
	 *
	 *  Defaults to `0` for "no truncation."
	 *
	 *
	 * ## Object Form
	 *
	 * An Object may also be provided with two properties: `length` (Number) and
	 * `location` (String). `location` may be one of the following: 'end'
	 * (default), 'middle', or 'smart'.
	 *
	 * Example Usage:
	 *
	 *     truncate: { length: 25, location: 'middle' }
	 *
	 * @cfg {Number} [truncate.length=0] How many characters to allow before
	 *   truncation will occur. Defaults to `0` for "no truncation."
	 * @cfg {"end"/"middle"/"smart"} [truncate.location="end"]
	 *
	 * - 'end' (default): will truncate up to the number of characters, and then
	 *   add an ellipsis at the end. Ex: 'yahoo.com/some/long/pat..'
	 * - 'middle': will truncate and add the ellipsis in the middle. Ex:
	 *   'yahoo.com/s..th/to/a/file'
	 * - 'smart': for URLs where the algorithm attempts to strip out unnecessary
	 *   parts first (such as the 'www.', then URL scheme, hash, etc.),
	 *   attempting to make the URL human-readable before looking for a good
	 *   point to insert the ellipsis if it is still too long. Ex:
	 *   'yahoo.com/some..to/a/file'. For more details, see
	 *   {@link Autolinker.truncate.TruncateSmart}.
	 */

	/**
	 * @cfg {String} className
	 *
	 * A CSS class name to add to the generated links. This class will be added
	 * to all links, as well as this class plus match suffixes for styling
	 * url/email/phone/hashtag/mention links differently.
	 *
	 * For example, if this config is provided as "myLink", then:
	 *
	 * - URL links will have the CSS classes: "myLink myLink-url"
	 * - Email links will have the CSS classes: "myLink myLink-email", and
	 * - Phone links will have the CSS classes: "myLink myLink-phone"
	 * - Hashtag links will have the CSS classes: "myLink myLink-hashtag"
	 * - Mention links will have the CSS classes: "myLink myLink-mention myLink-[type]"
	 *   where [type] is either "instagram" or "twitter"
	 */

	/**
	 * @cfg {Function} replaceFn
	 *
	 * A function to individually process each match found in the input string.
	 *
	 * See the class's description for usage.
	 *
	 * The `replaceFn` can be called with a different context object (`this`
	 * reference) using the {@link #context} cfg.
	 *
	 * This function is called with the following parameter:
	 *
	 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which
	 *   can be used to retrieve information about the match that the `replaceFn`
	 *   is currently processing. See {@link Autolinker.match.Match} subclasses
	 *   for details.
	 */

	/**
	 * @cfg {Object} context
	 *
	 * The context object (`this` reference) to call the `replaceFn` with.
	 *
	 * Defaults to this Autolinker instance.
	 */


	/**
	 * @property {String} version (readonly)
	 *
	 * The Autolinker version number in the form major.minor.patch
	 *
	 * Ex: 0.25.1
	 */

	/**
	 * @private
	 * @property {Autolinker.htmlParser.HtmlParser} htmlParser
	 *
	 * The HtmlParser instance used to skip over HTML tags, while finding text
	 * nodes to process. This is lazily instantiated in the {@link #getHtmlParser}
	 * method.
	 */

	/**
	 * @private
	 * @property {Autolinker.matcher.Matcher[]} matchers
	 *
	 * The {@link Autolinker.matcher.Matcher} instances for this Autolinker
	 * instance.
	 *
	 * This is lazily created in {@link #getMatchers}.
	 */

	/**
	 * @private
	 * @property {Autolinker.AnchorTagBuilder} tagBuilder
	 *
	 * The AnchorTagBuilder instance used to build match replacement anchor tags.
	 * Note: this is lazily instantiated in the {@link #getTagBuilder} method.
	 */


	/**
	 * Normalizes the {@link #urls} config into an Object with 3 properties:
	 * `schemeMatches`, `wwwMatches`, and `tldMatches`, all Booleans.
	 *
	 * See {@link #urls} config for details.
	 *
	 * @private
	 * @param {Boolean/Object} urls
	 * @return {Object}
	 */
	normalizeUrlsCfg : function( urls ) {
		if( urls == null ) urls = true;  // default to `true`

		if( typeof urls === 'boolean' ) {
			return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };

		} else {  // object form
			return {
				schemeMatches : typeof urls.schemeMatches === 'boolean' ? urls.schemeMatches : true,
				wwwMatches    : typeof urls.wwwMatches === 'boolean'    ? urls.wwwMatches    : true,
				tldMatches    : typeof urls.tldMatches === 'boolean'    ? urls.tldMatches    : true
			};
		}
	},


	/**
	 * Normalizes the {@link #stripPrefix} config into an Object with 2
	 * properties: `scheme`, and `www` - both Booleans.
	 *
	 * See {@link #stripPrefix} config for details.
	 *
	 * @private
	 * @param {Boolean/Object} stripPrefix
	 * @return {Object}
	 */
	normalizeStripPrefixCfg : function( stripPrefix ) {
		if( stripPrefix == null ) stripPrefix = true;  // default to `true`

		if( typeof stripPrefix === 'boolean' ) {
			return { scheme: stripPrefix, www: stripPrefix };

		} else {  // object form
			return {
				scheme : typeof stripPrefix.scheme === 'boolean' ? stripPrefix.scheme : true,
				www    : typeof stripPrefix.www === 'boolean'    ? stripPrefix.www    : true
			};
		}
	},


	/**
	 * Normalizes the {@link #truncate} config into an Object with 2 properties:
	 * `length` (Number), and `location` (String).
	 *
	 * See {@link #truncate} config for details.
	 *
	 * @private
	 * @param {Number/Object} truncate
	 * @return {Object}
	 */
	normalizeTruncateCfg : function( truncate ) {
		if( typeof truncate === 'number' ) {
			return { length: truncate, location: 'end' };

		} else {  // object, or undefined/null
			return Autolinker.Util.defaults( truncate || {}, {
				length   : Number.POSITIVE_INFINITY,
				location : 'end'
			} );
		}
	},


	/**
	 * Parses the input `textOrHtml` looking for URLs, email addresses, phone
	 * numbers, username handles, and hashtags (depending on the configuration
	 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
	 * objects describing those matches (without making any replacements).
	 *
	 * This method is used by the {@link #link} method, but can also be used to
	 * simply do parsing of the input in order to discover what kinds of links
	 * there are and how many.
	 *
	 * Example usage:
	 *
	 *     var autolinker = new Autolinker( {
	 *         urls: true,
	 *         email: true
	 *     } );
	 *
	 *     var matches = autolinker.parse( "Hello google.com, I am asdf@asdf.com" );
	 *
	 *     console.log( matches.length );           // 2
	 *     console.log( matches[ 0 ].getType() );   // 'url'
	 *     console.log( matches[ 0 ].getUrl() );    // 'google.com'
	 *     console.log( matches[ 1 ].getType() );   // 'email'
	 *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'
	 *
	 * @param {String} textOrHtml The HTML or text to find matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #hashtag}, and {@link #mention} options are enabled).
	 * @return {Autolinker.match.Match[]} The array of Matches found in the
	 *   given input `textOrHtml`.
	 */
	parse : function( textOrHtml ) {
		var htmlParser = this.getHtmlParser(),
		    htmlNodes = htmlParser.parse( textOrHtml ),
		    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have;
		    matches = [];

		// Find all matches within the `textOrHtml` (but not matches that are
		// already nested within <a> tags)
		for( var i = 0, len = htmlNodes.length; i < len; i++ ) {
			var node = htmlNodes[ i ],
			    nodeType = node.getType();

			if( nodeType === 'element' && node.getTagName() === 'a' ) {  // Process HTML anchor element nodes in the input `textOrHtml` to find out when we're within an <a> tag
				if( !node.isClosing() ) {  // it's the start <a> tag
					anchorTagStackCount++;
				} else {  // it's the end </a> tag
					anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
				}

			} else if( nodeType === 'text' && anchorTagStackCount === 0 ) {  // Process text nodes that are not within an <a> tag
				var textNodeMatches = this.parseText( node.getText(), node.getOffset() );

				matches.push.apply( matches, textNodeMatches );
			}
		}


		// After we have found all matches, remove subsequent matches that
		// overlap with a previous match. This can happen for instance with URLs,
		// where the url 'google.com/#link' would match '#link' as a hashtag.
		matches = this.compactMatches( matches );

		// And finally, remove matches for match types that have been turned
		// off. We needed to have all match types turned on initially so that
		// things like hashtags could be filtered out if they were really just
		// part of a URL match (for instance, as a named anchor).
		matches = this.removeUnwantedMatches( matches );

		return matches;
	},


	/**
	 * After we have found all matches, we need to remove subsequent matches
	 * that overlap with a previous match. This can happen for instance with
	 * URLs, where the url 'google.com/#link' would match '#link' as a hashtag.
	 *
	 * @private
	 * @param {Autolinker.match.Match[]} matches
	 * @return {Autolinker.match.Match[]}
	 */
	compactMatches : function( matches ) {
		// First, the matches need to be sorted in order of offset
		matches.sort( function( a, b ) { return a.getOffset() - b.getOffset(); } );

		for( var i = 0; i < matches.length - 1; i++ ) {
			var match = matches[ i ],
					offset = match.getOffset(),
					matchedTextLength = match.getMatchedText().length,
			    endIdx = offset + matchedTextLength;

			if( i + 1 < matches.length ) {
				// Remove subsequent matches that equal offset with current match
				if( matches[ i + 1 ].getOffset() === offset ) {
					var removeIdx = matches[ i + 1 ].getMatchedText().length > matchedTextLength ? i : i + 1;
					matches.splice( removeIdx, 1 );
					continue;
				}

				// Remove subsequent matches that overlap with the current match
				if( matches[ i + 1 ].getOffset() < endIdx ) {
					matches.splice( i + 1, 1 );
				}
			}
		}

		return matches;
	},


	/**
	 * Removes matches for matchers that were turned off in the options. For
	 * example, if {@link #hashtag hashtags} were not to be matched, we'll
	 * remove them from the `matches` array here.
	 *
	 * @private
	 * @param {Autolinker.match.Match[]} matches The array of matches to remove
	 *   the unwanted matches from. Note: this array is mutated for the
	 *   removals.
	 * @return {Autolinker.match.Match[]} The mutated input `matches` array.
	 */
	removeUnwantedMatches : function( matches ) {
		var remove = Autolinker.Util.remove;

		if( !this.hashtag ) remove( matches, function( match ) { return match.getType() === 'hashtag'; } );
		if( !this.email )   remove( matches, function( match ) { return match.getType() === 'email'; } );
		if( !this.phone )   remove( matches, function( match ) { return match.getType() === 'phone'; } );
		if( !this.mention ) remove( matches, function( match ) { return match.getType() === 'mention'; } );
		if( !this.urls.schemeMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'scheme'; } );
		}
		if( !this.urls.wwwMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'www'; } );
		}
		if( !this.urls.tldMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'tld'; } );
		}

		return matches;
	},


	/**
	 * Parses the input `text` looking for URLs, email addresses, phone
	 * numbers, username handles, and hashtags (depending on the configuration
	 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
	 * objects describing those matches.
	 *
	 * This method processes a **non-HTML string**, and is used to parse and
	 * match within the text nodes of an HTML string. This method is used
	 * internally by {@link #parse}.
	 *
	 * @private
	 * @param {String} text The text to find matches within (depending on if the
	 *   {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #hashtag}, and {@link #mention} options are enabled). This must be a non-HTML string.
	 * @param {Number} [offset=0] The offset of the text node within the
	 *   original string. This is used when parsing with the {@link #parse}
	 *   method to generate correct offsets within the {@link Autolinker.match.Match}
	 *   instances, but may be omitted if calling this method publicly.
	 * @return {Autolinker.match.Match[]} The array of Matches found in the
	 *   given input `text`.
	 */
	parseText : function( text, offset ) {
		offset = offset || 0;
		var matchers = this.getMatchers(),
		    matches = [];

		for( var i = 0, numMatchers = matchers.length; i < numMatchers; i++ ) {
			var textMatches = matchers[ i ].parseMatches( text );

			// Correct the offset of each of the matches. They are originally
			// the offset of the match within the provided text node, but we
			// need to correct them to be relative to the original HTML input
			// string (i.e. the one provided to #parse).
			for( var j = 0, numTextMatches = textMatches.length; j < numTextMatches; j++ ) {
				textMatches[ j ].setOffset( offset + textMatches[ j ].getOffset() );
			}

			matches.push.apply( matches, textMatches );
		}
		return matches;
	},


	/**
	 * Automatically links URLs, Email addresses, Phone numbers, Hashtags,
	 * and Mentions (Twitter, Instagram) found in the given chunk of HTML. Does not link
	 * URLs found within HTML tags.
	 *
	 * For instance, if given the text: `You should go to http://www.yahoo.com`,
	 * then the result will be `You should go to
	 * &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 *
	 * This method finds the text around any HTML elements in the input
	 * `textOrHtml`, which will be the text that is processed. Any original HTML
	 * elements will be left as-is, as well as the text that is already wrapped
	 * in anchor (&lt;a&gt;) tags.
	 *
	 * @param {String} textOrHtml The HTML or text to autolink matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #hashtag}, and {@link #mention} options are enabled).
	 * @return {String} The HTML, with matches automatically linked.
	 */
	link : function( textOrHtml ) {
		if( !textOrHtml ) { return ""; }  // handle `null` and `undefined`

		var matches = this.parse( textOrHtml ),
			newHtml = [],
			lastIndex = 0;

		for( var i = 0, len = matches.length; i < len; i++ ) {
			var match = matches[ i ];

			newHtml.push( textOrHtml.substring( lastIndex, match.getOffset() ) );
			newHtml.push( this.createMatchReturnVal( match ) );

			lastIndex = match.getOffset() + match.getMatchedText().length;
		}
		newHtml.push( textOrHtml.substring( lastIndex ) );  // handle the text after the last match

		return newHtml.join( '' );
	},


	/**
	 * Creates the return string value for a given match in the input string.
	 *
	 * This method handles the {@link #replaceFn}, if one was provided.
	 *
	 * @private
	 * @param {Autolinker.match.Match} match The Match object that represents
	 *   the match.
	 * @return {String} The string that the `match` should be replaced with.
	 *   This is usually the anchor tag string, but may be the `matchStr` itself
	 *   if the match is not to be replaced.
	 */
	createMatchReturnVal : function( match ) {
		// Handle a custom `replaceFn` being provided
		var replaceFnResult;
		if( this.replaceFn ) {
			replaceFnResult = this.replaceFn.call( this.context, match );  // Autolinker instance is the context
		}

		if( typeof replaceFnResult === 'string' ) {
			return replaceFnResult;  // `replaceFn` returned a string, use that

		} else if( replaceFnResult === false ) {
			return match.getMatchedText();  // no replacement for the match

		} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
			return replaceFnResult.toAnchorString();

		} else {  // replaceFnResult === true, or no/unknown return value from function
			// Perform Autolinker's default anchor tag generation
			var anchorTag = match.buildTag();  // returns an Autolinker.HtmlTag instance

			return anchorTag.toAnchorString();
		}
	},


	/**
	 * Lazily instantiates and returns the {@link #htmlParser} instance for this
	 * Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.htmlParser.HtmlParser}
	 */
	getHtmlParser : function() {
		var htmlParser = this.htmlParser;

		if( !htmlParser ) {
			htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
		}

		return htmlParser;
	},


	/**
	 * Lazily instantiates and returns the {@link Autolinker.matcher.Matcher}
	 * instances for this Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.matcher.Matcher[]}
	 */
	getMatchers : function() {
		if( !this.matchers ) {
			var matchersNs = Autolinker.matcher,
			    tagBuilder = this.getTagBuilder();

			var matchers = [
				new matchersNs.Hashtag( { tagBuilder: tagBuilder, serviceName: this.hashtag } ),
				new matchersNs.Email( { tagBuilder: tagBuilder } ),
				new matchersNs.Phone( { tagBuilder: tagBuilder } ),
				new matchersNs.Mention( { tagBuilder: tagBuilder, serviceName: this.mention } ),
				new matchersNs.Url( { tagBuilder: tagBuilder, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash, decodePercentEncoding: this.decodePercentEncoding } )
			];

			return ( this.matchers = matchers );

		} else {
			return this.matchers;
		}
	},


	/**
	 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
	 * if it does not yet exist.
	 *
	 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that
	 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
	 *
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( match ) {
	 *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *
	 *             return tag;
	 *         }
	 *     } );
	 *
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 *
	 * @return {Autolinker.AnchorTagBuilder}
	 */
	getTagBuilder : function() {
		var tagBuilder = this.tagBuilder;

		if( !tagBuilder ) {
			tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
				newWindow   : this.newWindow,
				truncate    : this.truncate,
				className   : this.className
			} );
		}

		return tagBuilder;
	}

};


// Autolinker Namespaces

Autolinker.match = {};
Autolinker.matcher = {};
Autolinker.htmlParser = {};
Autolinker.truncate = {};

/*global Autolinker */
/*jshint eqnull:true, boss:true */
/**
 * @class Autolinker.Util
 * @singleton
 *
 * A few utility methods for Autolinker.
 */
Autolinker.Util = {

	/**
	 * @property {Function} abstractMethod
	 *
	 * A function object which represents an abstract method.
	 */
	abstractMethod : function() { throw "abstract"; },


	/**
	 * @private
	 * @property {RegExp} trimRegex
	 *
	 * The regular expression used to trim the leading and trailing whitespace
	 * from a string.
	 */
	trimRegex : /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	assign : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`, if the
	 * corresponding property on `dest` === `undefined`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	defaults : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) && dest[ prop ] === undefined ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
	 *
	 * @param {Function} superclass The constructor function for the superclass.
	 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
	 *   special property `constructor`, which will be used as the new subclass's constructor function.
	 * @return {Function} The new subclass function.
	 */
	extend : function( superclass, protoProps ) {
		var superclassProto = superclass.prototype;

		var F = function() {};
		F.prototype = superclassProto;

		var subclass;
		if( protoProps.hasOwnProperty( 'constructor' ) ) {
			subclass = protoProps.constructor;
		} else {
			subclass = function() { superclassProto.constructor.apply( this, arguments ); };
		}

		var subclassProto = subclass.prototype = new F();  // set up prototype chain
		subclassProto.constructor = subclass;  // fix constructor property
		subclassProto.superclass = superclassProto;

		delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
		Autolinker.Util.assign( subclassProto, protoProps );

		return subclass;
	},


	/**
	 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
	 * end of the string (by default, two periods: '..'). If the `str` length does not exceed
	 * `len`, the string will be returned unchanged.
	 *
	 * @param {String} str The string to truncate and add an ellipsis to.
	 * @param {Number} truncateLen The length to truncate the string at.
	 * @param {String} [ellipsisChars=...] The ellipsis character(s) to add to the end of `str`
	 *   when truncated. Defaults to '...'
	 */
	ellipsis : function( str, truncateLen, ellipsisChars ) {
		var ellipsisLength;

		if( str.length > truncateLen ) {
			if(ellipsisChars == null) {
			  ellipsisChars = '&hellip;';
			  ellipsisLength = 3;
			} else {
			  ellipsisLength = ellipsisChars.length;
			}

			str = str.substring( 0, truncateLen - ellipsisLength ) + ellipsisChars;
		}
		return str;
	},


	/**
	 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
	 *
	 * @param {Array} arr The array to find an element of.
	 * @param {*} element The element to find in the array, and return the index of.
	 * @return {Number} The index of the `element`, or -1 if it was not found.
	 */
	indexOf : function( arr, element ) {
		if( Array.prototype.indexOf ) {
			return arr.indexOf( element );

		} else {
			for( var i = 0, len = arr.length; i < len; i++ ) {
				if( arr[ i ] === element ) return i;
			}
			return -1;
		}
	},


	/**
	 * Removes array elements based on a filtering function. Mutates the input
	 * array.
	 *
	 * Using this instead of the ES5 Array.prototype.filter() function, to allow
	 * Autolinker compatibility with IE8, and also to prevent creating many new
	 * arrays in memory for filtering.
	 *
	 * @param {Array} arr The array to remove elements from. This array is
	 *   mutated.
	 * @param {Function} fn A function which should return `true` to
	 *   remove an element.
	 * @return {Array} The mutated input `arr`.
	 */
	remove : function( arr, fn ) {
		for( var i = arr.length - 1; i >= 0; i-- ) {
			if( fn( arr[ i ] ) === true ) {
				arr.splice( i, 1 );
			}
		}
	},


	/**
	 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
	 * with a regular expression that contains capturing parenthesis.
	 *
	 * For example:
	 *
	 *     // Modern browsers:
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
	 *
	 *     // Old IE (including IE8):
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
	 *
	 * This method emulates the functionality of modern browsers for the old IE case.
	 *
	 * @param {String} str The string to split.
	 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
	 *   character(s) will be spliced into the array, as in the "modern browsers" example in the
	 *   description of this method.
	 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
	 *   Note #2: for simplicity's sake, the regular expression does not need
	 *   to contain capturing parenthesis - it will be assumed that any match has them.
	 * @return {String[]} The split array of strings, with the splitting character(s) included.
	 */
	splitAndCapture : function( str, splitRegex ) {
		if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );

		var result = [],
		    lastIdx = 0,
		    match;

		while( match = splitRegex.exec( str ) ) {
			result.push( str.substring( lastIdx, match.index ) );
			result.push( match[ 0 ] );  // push the splitting char(s)

			lastIdx = match.index + match[ 0 ].length;
		}
		result.push( str.substring( lastIdx ) );

		return result;
	},


	/**
	 * Trims the leading and trailing whitespace from a string.
	 *
	 * @param {String} str The string to trim.
	 * @return {String}
	 */
	trim : function( str ) {
		return str.replace( this.trimRegex, '' );
	}

};

/*global Autolinker */
/*jshint boss:true */
/**
 * @class Autolinker.HtmlTag
 * @extends Object
 *
 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
 *
 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
 *
 * ## Examples
 *
 * Example instantiation:
 *
 *     var tag = new Autolinker.HtmlTag( {
 *         tagName : 'a',
 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
 *         innerHtml : 'Google'
 *     } );
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *     // Individual accessor methods
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *
 * Using mutator methods (which may be used in combination with instantiation config properties):
 *
 *     var tag = new Autolinker.HtmlTag();
 *     tag.setTagName( 'a' );
 *     tag.setAttr( 'href', 'http://google.com' );
 *     tag.addClass( 'external-link' );
 *     tag.setInnerHtml( 'Google' );
 *
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *
 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( match ) {
 *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 *
 *
 * ## Example use with a new tag for the replacement
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( match ) {
 *             var tag = new Autolinker.HtmlTag( {
 *                 tagName : 'button',
 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
 *             } );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
 */
Autolinker.HtmlTag = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {String} tagName
	 *
	 * The tag name. Ex: 'a', 'button', etc.
	 *
	 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}
	 * is executed.
	 */

	/**
	 * @cfg {Object.<String, String>} attrs
	 *
	 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
	 * values are the attribute values.
	 */

	/**
	 * @cfg {String} innerHtml
	 *
	 * The inner HTML for the tag.
	 *
	 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym
	 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
	 * if you prefer, but this one is recommended.
	 */

	/**
	 * @cfg {String} innerHTML
	 *
	 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
	 * for acronym names.
	 */


	/**
	 * @protected
	 * @property {RegExp} whitespaceRegex
	 *
	 * Regular expression used to match whitespace in a string of CSS classes.
	 */
	whitespaceRegex : /\s+/,


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
	},


	/**
	 * Sets the tag name that will be used to generate the tag with.
	 *
	 * @param {String} tagName
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setTagName : function( tagName ) {
		this.tagName = tagName;
		return this;
	},


	/**
	 * Retrieves the tag name.
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName || "";
	},


	/**
	 * Sets an attribute on the HtmlTag.
	 *
	 * @param {String} attrName The attribute name to set.
	 * @param {String} attrValue The attribute value to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttr : function( attrName, attrValue ) {
		var tagAttrs = this.getAttrs();
		tagAttrs[ attrName ] = attrValue;

		return this;
	},


	/**
	 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
	 *
	 * @param {String} attrName The attribute name to retrieve.
	 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
	 */
	getAttr : function( attrName ) {
		return this.getAttrs()[ attrName ];
	},


	/**
	 * Sets one or more attributes on the HtmlTag.
	 *
	 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttrs : function( attrs ) {
		var tagAttrs = this.getAttrs();
		Autolinker.Util.assign( tagAttrs, attrs );

		return this;
	},


	/**
	 * Retrieves the attributes Object (map) for the HtmlTag.
	 *
	 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
	 */
	getAttrs : function() {
		return this.attrs || ( this.attrs = {} );
	},


	/**
	 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setClass : function( cssClass ) {
		return this.setAttr( 'class', cssClass );
	},


	/**
	 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to add.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	addClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    newClasses = cssClass.split( whitespaceRegex ),
		    newClass;

		while( newClass = newClasses.shift() ) {
			if( indexOf( classes, newClass ) === -1 ) {
				classes.push( newClass );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to remove one or more CSS classes from the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to remove.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	removeClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    removeClasses = cssClass.split( whitespaceRegex ),
		    removeClass;

		while( classes.length && ( removeClass = removeClasses.shift() ) ) {
			var idx = indexOf( classes, removeClass );
			if( idx !== -1 ) {
				classes.splice( idx, 1 );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
	 * there are multiple.
	 *
	 * @return {String}
	 */
	getClass : function() {
		return this.getAttrs()[ 'class' ] || "";
	},


	/**
	 * Convenience method to check if the tag has a CSS class or not.
	 *
	 * @param {String} cssClass The CSS class to check for.
	 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
	 */
	hasClass : function( cssClass ) {
		return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
	},


	/**
	 * Sets the inner HTML for the tag.
	 *
	 * @param {String} html The inner HTML to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setInnerHtml : function( html ) {
		this.innerHtml = html;

		return this;
	},


	/**
	 * Retrieves the inner HTML for the tag.
	 *
	 * @return {String}
	 */
	getInnerHtml : function() {
		return this.innerHtml || "";
	},


	/**
	 * Override of superclass method used to generate the HTML string for the tag.
	 *
	 * @return {String}
	 */
	toAnchorString : function() {
		var tagName = this.getTagName(),
		    attrsStr = this.buildAttrsStr();

		attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes

		return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
	},


	/**
	 * Support method for {@link #toAnchorString}, returns the string space-separated key="value" pairs, used to populate
	 * the stringified HtmlTag.
	 *
	 * @protected
	 * @return {String} Example return: `attr1="value1" attr2="value2"`
	 */
	buildAttrsStr : function() {
		if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string

		var attrs = this.getAttrs(),
		    attrsArr = [];

		for( var prop in attrs ) {
			if( attrs.hasOwnProperty( prop ) ) {
				attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
			}
		}
		return attrsArr.join( " " );
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.RegexLib
 * @singleton
 *
 * Builds and stores a library of the common regular expressions used by the
 * Autolinker utility.
 *
 * Other regular expressions may exist ad-hoc, but these are generally the
 * regular expressions that are shared between source files.
 */
Autolinker.RegexLib = (function() {

	/**
	 * The string form of a regular expression that would match all of the
	 * alphabetic ("letter") chars in the unicode character set when placed in a
	 * RegExp character class (`[]`). This includes all international alphabetic
	 * characters.
	 *
	 * These would be the characters matched by unicode regex engines `\p{L}`
	 * escape ("all letters").
	 *
	 * Taken from the XRegExp library: http://xregexp.com/
	 * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
	 *
	 * @private
	 * @type {String}
	 */
	var alphaCharsStr = 'A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';

	/**
	 * The string form of a regular expression that would match all of the
	 * decimal number chars in the unicode character set when placed in a RegExp
	 * character class (`[]`).
	 *
	 * These would be the characters matched by unicode regex engines `\p{Nd}`
	 * escape ("all decimal numbers")
	 *
	 * Taken from the XRegExp library: http://xregexp.com/
	 * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
	 *
	 * @private
	 * @type {String}
	 */
	var decimalNumbersStr = '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19';


	// See documentation below
	var alphaNumericCharsStr = alphaCharsStr + decimalNumbersStr;

	// Simplified IP regular expression
	var ipStr = '(?:[' + decimalNumbersStr + ']{1,3}\\.){3}[' + decimalNumbersStr + ']{1,3}';

	// Protected domain label which do not allow "-" character on the beginning and the end of a single label
	var domainLabelStr = '[' + alphaNumericCharsStr + '](?:[' + alphaNumericCharsStr + '\\-]{0,61}[' + alphaNumericCharsStr + '])?';

	var getDomainLabelStr = function(group) {
		return '(?=(' + domainLabelStr + '))\\' + group;
	};

	// See documentation below
	var getDomainNameStr = function(group) {
		return '(?:' + getDomainLabelStr(group) + '(?:\\.' + getDomainLabelStr(group + 1) + '){0,126}|' + ipStr + ')';
	};

	return {

		/**
		 * The string form of a regular expression that would match all of the
		 * letters and decimal number chars in the unicode character set when placed
		 * in a RegExp character class (`[]`).
		 *
		 * These would be the characters matched by unicode regex engines `[\p{L}\p{Nd}]`
		 * escape ("all letters and decimal numbers")
		 *
		 * @property {String} alphaNumericCharsStr
		 */
		alphaNumericCharsStr : alphaNumericCharsStr,

		/**
		 * The string form of a regular expression that would match all of the
		 * letters and in the unicode character set when placed
		 * in a RegExp character class (`[]`).
		 *
		 * These would be the characters matched by unicode regex engines `[\p{L}]`
		 * escape ("all letters")
		 *
		 * @property {String} alphaCharsStr
		 */
		alphaCharsStr : alphaCharsStr,

		/**
		 * A regular expression to match domain names of a URL or email address.
		 * Ex: 'google', 'yahoo', 'some-other-company', etc.
		 *
		 * @property {RegExp} domainNameRegex
		 */
		getDomainNameStr : getDomainNameStr,

	};


}() );

/*global Autolinker */
/*jshint sub:true */
/**
 * @protected
 * @class Autolinker.AnchorTagBuilder
 * @extends Object
 *
 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is
 * found.
 *
 * Normally this class is instantiated, configured, and used internally by an
 * {@link Autolinker} instance, but may actually be used indirectly in a
 * {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag}
 * instances which may be modified before returning from the
 * {@link Autolinker#replaceFn replaceFn}. For example:
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( match ) {
 *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 */
Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Boolean} newWindow
	 * @inheritdoc Autolinker#newWindow
	 */

	/**
	 * @cfg {Object} truncate
	 * @inheritdoc Autolinker#truncate
	 */

	/**
	 * @cfg {String} className
	 * @inheritdoc Autolinker#className
	 */


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		cfg = cfg || {};

		this.newWindow = cfg.newWindow;
		this.truncate = cfg.truncate;
		this.className = cfg.className;
	},


	/**
	 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the
	 * matched text, via its `match` object.
	 *
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
	 */
	build : function( match ) {
		return new Autolinker.HtmlTag( {
			tagName   : 'a',
			attrs     : this.createAttrs( match ),
			innerHtml : this.processAnchorText( match.getAnchorText() )
		} );
	},


	/**
	 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)
	 *   tag being generated.
	 *
	 * @protected
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {Object} A key/value Object (map) of the anchor tag's attributes.
	 */
	createAttrs : function( match ) {
		var attrs = {
			'href' : match.getAnchorHref()  // we'll always have the `href` attribute
		};

		var cssClass = this.createCssClass( match );
		if( cssClass ) {
			attrs[ 'class' ] = cssClass;
		}
		if( this.newWindow ) {
			attrs[ 'target' ] = "_blank";
			attrs[ 'rel' ] = "noopener noreferrer";
		}

		if( this.truncate ) {
			if( this.truncate.length && this.truncate.length < match.getAnchorText().length ) {
				attrs[ 'title' ] = match.getAnchorHref();
			}
		}

		return attrs;
	},


	/**
	 * Creates the CSS class that will be used for a given anchor tag, based on
	 * the `matchType` and the {@link #className} config.
	 *
	 * Example returns:
	 *
	 * - ""                                      // no {@link #className}
	 * - "myLink myLink-url"                     // url match
	 * - "myLink myLink-email"                   // email match
	 * - "myLink myLink-phone"                   // phone match
	 * - "myLink myLink-hashtag"                 // hashtag match
	 * - "myLink myLink-mention myLink-twitter"  // mention match with Twitter service
	 *
	 * @private
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {String} The CSS class string for the link. Example return:
	 *   "myLink myLink-url". If no {@link #className} was configured, returns
	 *   an empty string.
	 */
	createCssClass : function( match ) {
		var className = this.className;

		if( !className ) {
			return "";

		} else {
			var returnClasses = [ className ],
				cssClassSuffixes = match.getCssClassSuffixes();

			for( var i = 0, len = cssClassSuffixes.length; i < len; i++ ) {
				returnClasses.push( className + '-' + cssClassSuffixes[ i ] );
			}
			return returnClasses.join( ' ' );
		}
	},


	/**
	 * Processes the `anchorText` by truncating the text according to the
	 * {@link #truncate} config.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The processed `anchorText`.
	 */
	processAnchorText : function( anchorText ) {
		anchorText = this.doTruncate( anchorText );

		return anchorText;
	},


	/**
	 * Performs the truncation of the `anchorText` based on the {@link #truncate}
	 * option. If the `anchorText` is longer than the length specified by the
	 * {@link #truncate} option, the truncation is performed based on the
	 * `location` property. See {@link #truncate} for details.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The truncated anchor text.
	 */
	doTruncate : function( anchorText ) {
		var truncate = this.truncate;
		if( !truncate || !truncate.length ) return anchorText;

		var truncateLength = truncate.length,
			truncateLocation = truncate.location;

		if( truncateLocation === 'smart' ) {
			return Autolinker.truncate.TruncateSmart( anchorText, truncateLength );

		} else if( truncateLocation === 'middle' ) {
			return Autolinker.truncate.TruncateMiddle( anchorText, truncateLength );

		} else {
			return Autolinker.truncate.TruncateEnd( anchorText, truncateLength );
		}
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.htmlParser.HtmlParser
 * @extends Object
 *
 * An HTML parser implementation which simply walks an HTML string and returns an array of
 * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
 *
 * Autolinker uses this to only link URLs/emails/mentions within text nodes, effectively ignoring / "walking
 * around" HTML tags.
 */
Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {

	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 *
	 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
	 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
	 *
	 * Capturing groups:
	 *
	 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
	 * 2. If it is an end tag, this group will have the '/'.
	 * 3. If it is a comment tag, this group will hold the comment text (i.e.
	 *    the text inside the `&lt;!--` and `--&gt;`.
	 * 4. The tag name for a tag without attributes (other than the &lt;!DOCTYPE&gt; tag)
	 * 5. The tag name for a tag with attributes (other than the &lt;!DOCTYPE&gt; tag)
	 */
	htmlRegex : (function() {
		var commentTagRegex = /!--([\s\S]+?)--/,
		    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
		    attrNameRegex = /[^\s"'>\/=\x00-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
		    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
		    optionalAttrValueRegex = '(?:\\s*?=\\s*?' + attrValueRegex.source + ')?'; // optional '=[value]'

		var getNameEqualsValueRegex = function(group) {
			return '(?=(' + attrNameRegex.source + '))\\' + group + optionalAttrValueRegex;
		};

		return new RegExp( [
			// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
			'(?:',
				'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag

					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',  // one or more whitespace chars before an attribute

						// Either:
						// A. attr="value", or
						// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
						// *** Capturing Group 2 - Pseudo-atomic group for attrNameRegex
						'(?:', getNameEqualsValueRegex(2), '|', attrValueRegex.source + ')',
					')*',
				'>',
			')',

			'|',

			// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
			'(?:',
				'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.
				          // *** Capturing Group 3: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

					'(?:',
						commentTagRegex.source,  // *** Capturing Group 4 - A Comment Tag's Text

						'|',

						// Handle tag without attributes.
						// Doing this separately from a tag that has attributes
						// to fix a regex time complexity issue seen with the
						// example in https://github.com/gregjacobs/Autolinker.js/issues/172
						'(?:',
							// *** Capturing Group 5 - The tag name for a tag without attributes
							'(' + tagNameRegex.source + ')',

							'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
						')',

						'|',

						// Handle tag with attributes
						// Doing this separately from a tag with no attributes
						// to fix a regex time complexity issue seen with the
						// example in https://github.com/gregjacobs/Autolinker.js/issues/172
						'(?:',
							// *** Capturing Group 6 - The tag name for a tag with attributes
							'(' + tagNameRegex.source + ')',

							'\\s+',  // must have at least one space after the tag name to prevent ReDoS issue (issue #172)

							// Zero or more attributes following the tag name
							'(?:',
								'(?:\\s+|\\b)',        // any number of whitespace chars before an attribute. NOTE: Using \s* here throws Chrome into an infinite loop for some reason, so using \s+|\b instead
								// *** Capturing Group 7 - Pseudo-atomic group for attrNameRegex
								getNameEqualsValueRegex(7),  // attr="value" (with optional ="value" part)
							')*',

							'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
						')',
					')',
				'>',
			')'
		].join( "" ), 'gi' );
	} )(),

	/**
	 * @private
	 * @property {RegExp} htmlCharacterEntitiesRegex
	 *
	 * The regular expression that matches common HTML character entities.
	 *
	 * Ignoring &amp; as it could be part of a query string -- handling it separately.
	 */
	htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,


	/**
	 * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}
	 * to represent the HTML structure of the input string.
	 *
	 * @param {String} html The HTML to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]}
	 */
	parse : function( html ) {
		var htmlRegex = this.htmlRegex,
		    currentResult,
		    lastIndex = 0,
		    textAndEntityNodes,
		    nodes = [];  // will be the result of the method

		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    commentText = currentResult[ 4 ], // if we've matched a comment
			    tagName = currentResult[ 1 ] || currentResult[ 5 ] || currentResult[ 6 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img")
			    isClosingTag = !!currentResult[ 3 ],
			    offset = currentResult.index,
			    inBetweenTagsText = html.substring( lastIndex, offset );

			// Push TextNodes and EntityNodes for any text found between tags
			if( inBetweenTagsText ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, inBetweenTagsText );
				nodes.push.apply( nodes, textAndEntityNodes );
			}

			// Push the CommentNode or ElementNode
			if( commentText ) {
				nodes.push( this.createCommentNode( offset, tagText, commentText ) );
			} else {
				nodes.push( this.createElementNode( offset, tagText, tagName, isClosingTag ) );
			}

			lastIndex = offset + tagText.length;
		}

		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			var text = html.substring( lastIndex );

			// Push TextNodes and EntityNodes for any text found between tags
			if( text ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, text );

				// Note: the following 3 lines were previously:
				//   nodes.push.apply( nodes, textAndEntityNodes );
				// but this was causing a "Maximum Call Stack Size Exceeded"
				// error on inputs with a large number of html entities.
				textAndEntityNodes.forEach( function( node ) {
					nodes.push( node );
				} );
			}
		}

		return nodes;
	},


	/**
	 * Parses text and HTML entity nodes from a given string. The input string
	 * should not have any HTML tags (elements) within it.
	 *
	 * @private
	 * @param {Number} offset The offset of the text node match within the
	 *   original HTML string.
	 * @param {String} text The string of text to parse. This is from an HTML
	 *   text node.
	 * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to
	 *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and
	 *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
	 */
	parseTextAndEntityNodes : function( offset, text ) {
		var nodes = [],
		    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array

		// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
		// For example: an input `text` of "Test &quot;this&quot; today" would turn into the
		//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
		for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {
			var textToken = textAndEntityTokens[ i ],
			    entityToken = textAndEntityTokens[ i + 1 ];

			if( textToken ) {
				nodes.push( this.createTextNode( offset, textToken ) );
				offset += textToken.length;
			}
			if( entityToken ) {
				nodes.push( this.createEntityNode( offset, entityToken ) );
				offset += entityToken.length;
			}
		}
		return nodes;
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} tagText The full text of the tag (comment) that was
	 *   matched, including its &lt;!-- and --&gt;.
	 * @param {String} commentText The full text of the comment that was matched.
	 */
	createCommentNode : function( offset, tagText, commentText ) {
		return new Autolinker.htmlParser.CommentNode( {
			offset : offset,
			text   : tagText,
			comment: Autolinker.Util.trim( commentText )
		} );
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} tagText The full text of the tag (element) that was
	 *   matched, including its attributes.
	 * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would
	 *   be passed to this method as "img".
	 * @param {Boolean} isClosingTag `true` if it's a closing tag, false
	 *   otherwise.
	 * @return {Autolinker.htmlParser.ElementNode}
	 */
	createElementNode : function( offset, tagText, tagName, isClosingTag ) {
		return new Autolinker.htmlParser.ElementNode( {
			offset  : offset,
			text    : tagText,
			tagName : tagName.toLowerCase(),
			closing : isClosingTag
		} );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} text The text that was matched for the HTML entity (such
	 *   as '&amp;nbsp;').
	 * @return {Autolinker.htmlParser.EntityNode}
	 */
	createEntityNode : function( offset, text ) {
		return new Autolinker.htmlParser.EntityNode( { offset: offset, text: text } );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} text The text that was matched.
	 * @return {Autolinker.htmlParser.TextNode}
	 */
	createTextNode : function( offset, text ) {
		return new Autolinker.htmlParser.TextNode( { offset: offset, text: text } );
	}

} );

/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML node found in an input string. An HTML node is one of the
 * following:
 *
 * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents
 *    HTML tags.
 * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents
 *    HTML comments.
 * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text
 *    outside or within HTML tags.
 * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents
 *    one of the known HTML entities that Autolinker looks for. This includes
 *    common ones such as &amp;quot; and &amp;nbsp;
 */
Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Number} offset (required)
	 *
	 * The offset of the HTML node in the original text that was parsed.
	 */
	offset : undefined,

	/**
	 * @cfg {String} text (required)
	 *
	 * The text that was matched for the HtmlNode.
	 *
	 * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode},
	 *   this will be the tag's text.
	 * - In the case of an {@link Autolinker.htmlParser.CommentNode CommentNode},
	 *   this will be the comment's text.
	 * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this
	 *   will be the text itself.
	 * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode},
	 *   this will be the text of the HTML entity.
	 */
	text : undefined,


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 * specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		if( this.offset == null ) throw new Error( '`offset` cfg required' );
		if( this.text == null ) throw new Error( '`text` cfg required' );
	},


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,


	/**
	 * Retrieves the {@link #offset} of the HtmlNode. This is the offset of the
	 * HTML node in the original string that was parsed.
	 *
	 * @return {Number}
	 */
	getOffset : function() {
		return this.offset;
	},


	/**
	 * Retrieves the {@link #text} for the HtmlNode.
	 *
	 * @return {String}
	 */
	getText : function() {
		return this.text;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.CommentNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML comment node that has been parsed by the
 * {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.CommentNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} comment (required)
	 *
	 * The text inside the comment tag. This text is stripped of any leading or
	 * trailing whitespace.
	 */
	comment : '',


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'comment';
	},


	/**
	 * Returns the comment inside the comment tag.
	 *
	 * @return {String}
	 */
	getComment : function() {
		return this.comment;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.ElementNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} tagName (required)
	 *
	 * The name of the tag that was matched.
	 */
	tagName : '',

	/**
	 * @cfg {Boolean} closing (required)
	 *
	 * `true` if the element (tag) is a closing tag, `false` if its an opening
	 * tag.
	 */
	closing : false,


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'element';
	},


	/**
	 * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,
	 * returns "img".
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName;
	},


	/**
	 * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;
	 * returns `false`, while &lt;/div&gt; returns `true`.
	 *
	 * @return {Boolean}
	 */
	isClosing : function() {
		return this.closing;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.EntityNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}
 * method.
 *
 * Note that this class will only be returned from the HtmlParser for the set of
 * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'entity';
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.TextNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'text';
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.match.Match
 *
 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a
 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, and Mentions (Twitter, Instagram)
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                 case 'email' :
 *                     console.log( "email: ", match.getEmail() );
 *
 *                 case 'mention' :
 *                     console.log( "mention: ", match.getMention() );
 *             }
 *         }
 *     } );
 *
 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
 */
Autolinker.match.Match = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
	 *
	 * Reference to the AnchorTagBuilder instance to use to generate an anchor
	 * tag for the Match.
	 */

	/**
	 * @cfg {String} matchedText (required)
	 *
	 * The original text that was matched by the {@link Autolinker.matcher.Matcher}.
	 */

	/**
	 * @cfg {Number} offset (required)
	 *
	 * The offset of where the match was made in the input string.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		if( cfg.tagBuilder == null ) throw new Error( '`tagBuilder` cfg required' );
		if( cfg.matchedText == null ) throw new Error( '`matchedText` cfg required' );
		if( cfg.offset == null ) throw new Error( '`offset` cfg required' );

		this.tagBuilder = cfg.tagBuilder;
		this.matchedText = cfg.matchedText;
		this.offset = cfg.offset;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,


	/**
	 * Returns the original text that was matched.
	 *
	 * @return {String}
	 */
	getMatchedText : function() {
		return this.matchedText;
	},


	/**
	 * Sets the {@link #offset} of where the match was made in the input string.
	 *
	 * A {@link Autolinker.matcher.Matcher} will be fed only HTML text nodes,
	 * and will therefore set an original offset that is relative to the HTML
	 * text node itself. However, we want this offset to be relative to the full
	 * HTML input string, and thus if using {@link Autolinker#parse} (rather
	 * than calling a {@link Autolinker.matcher.Matcher} directly), then this
	 * offset is corrected after the Matcher itself has done its job.
	 *
	 * @param {Number} offset
	 */
	setOffset : function( offset ) {
		this.offset = offset;
	},


	/**
	 * Returns the offset of where the match was made in the input string. This
	 * is the 0-based index of the match.
	 *
	 * @return {Number}
	 */
	getOffset : function() {
		return this.offset;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @abstract
	 * @return {String}
	 */
	getAnchorHref : Autolinker.Util.abstractMethod,


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @abstract
	 * @return {String}
	 */
	getAnchorText : Autolinker.Util.abstractMethod,


	/**
	 * Returns the CSS class suffix(es) for this match.
	 *
	 * A CSS class suffix is appended to the {@link Autolinker#className} in
	 * the {@link Autolinker.AnchorTagBuilder} when a match is translated into
	 * an anchor tag.
	 *
	 * For example, if {@link Autolinker#className} was configured as 'myLink',
	 * and this method returns `[ 'url' ]`, the final class name of the element
	 * will become: 'myLink myLink-url'.
	 *
	 * The match may provide multiple CSS class suffixes to be appended to the
	 * {@link Autolinker#className} in order to facilitate better styling
	 * options for different match criteria. See {@link Autolinker.match.Mention}
	 * for an example.
	 *
	 * By default, this method returns a single array with the match's
	 * {@link #getType type} name, but may be overridden by subclasses.
	 *
	 * @return {String[]}
	 */
	getCssClassSuffixes : function() {
		return [ this.getType() ];
	},


	/**
	 * Builds and returns an {@link Autolinker.HtmlTag} instance based on the
	 * Match.
	 *
	 * This can be used to easily generate anchor tags from matches, and either
	 * return their HTML string, or modify them before doing so.
	 *
	 * Example Usage:
	 *
	 *     var tag = match.buildTag();
	 *     tag.addClass( 'cordova-link' );
	 *     tag.setAttr( 'target', '_system' );
	 *
	 *     tag.toAnchorString();  // <a href="http://google.com" class="cordova-link" target="_system">Google</a>
	 */
	buildTag : function() {
		return this.tagBuilder.build( this );
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Email
 * @extends Autolinker.match.Match
 *
 * Represents a Email match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} email (required)
	 *
	 * The email address that was matched.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.email ) throw new Error( '`email` cfg required' );

		this.email = cfg.email;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'email';
	},


	/**
	 * Returns the email address that was matched.
	 *
	 * @return {String}
	 */
	getEmail : function() {
		return this.email;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'mailto:' + this.email;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.email;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Hashtag
 * @extends Autolinker.match.Match
 *
 * Represents a Hashtag match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Hashtag = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */

	/**
	 * @cfg {String} hashtag (required)
	 *
	 * The Hashtag that was matched, without the '#'.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		// TODO: if( !serviceName ) throw new Error( '`serviceName` cfg required' );
		if( !cfg.hashtag ) throw new Error( '`hashtag` cfg required' );

		this.serviceName = cfg.serviceName;
		this.hashtag = cfg.hashtag;
	},


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'hashtag';
	},


	/**
	 * Returns the configured {@link #serviceName} to point the Hashtag to.
	 * Ex: 'facebook', 'twitter'.
	 *
	 * @return {String}
	 */
	getServiceName : function() {
		return this.serviceName;
	},


	/**
	 * Returns the matched hashtag, without the '#' character.
	 *
	 * @return {String}
	 */
	getHashtag : function() {
		return this.hashtag;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var serviceName = this.serviceName,
		    hashtag = this.hashtag;

		switch( serviceName ) {
			case 'twitter' :
				return 'https://twitter.com/hashtag/' + hashtag;
			case 'facebook' :
				return 'https://www.facebook.com/hashtag/' + hashtag;
			case 'instagram' :
				return 'https://instagram.com/explore/tags/' + hashtag;

			default :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
				throw new Error( 'Unknown service name to point hashtag to: ', serviceName );
		}
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '#' + this.hashtag;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Phone
 * @extends Autolinker.match.Match
 *
 * Represents a Phone number match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @protected
	 * @property {String} number (required)
	 *
	 * The phone number that was matched, without any delimiter characters.
	 *
	 * Note: This is a string to allow for prefixed 0's.
	 */

	/**
	 * @protected
	 * @property  {Boolean} plusSign (required)
	 *
	 * `true` if the matched phone number started with a '+' sign. We'll include
	 * it in the `tel:` URL if so, as this is needed for international numbers.
	 *
	 * Ex: '+1 (123) 456 7879'
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.number ) throw new Error( '`number` cfg required' );
		if( cfg.plusSign == null ) throw new Error( '`plusSign` cfg required' );

		this.number = cfg.number;
		this.plusSign = cfg.plusSign;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'phone';
	},


	/**
	 * Returns the phone number that was matched as a string, without any
	 * delimiter characters.
	 *
	 * Note: This is a string to allow for prefixed 0's.
	 *
	 * @return {String}
	 */
	getNumber: function() {
		return this.number;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'tel:' + ( this.plusSign ? '+' : '' ) + this.number;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.matchedText;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Mention
 * @extends Autolinker.match.Match
 *
 * Represents a Mention match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Mention = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point mention matches to. See {@link Autolinker#mention}
	 * for available values.
	 */

	/**
	 * @cfg {String} mention (required)
	 *
	 * The Mention that was matched, without the '@' character.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.serviceName ) throw new Error( '`serviceName` cfg required' );
		if( !cfg.mention ) throw new Error( '`mention` cfg required' );

		this.mention = cfg.mention;
		this.serviceName = cfg.serviceName;
	},


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'mention';
	},


	/**
	 * Returns the mention, without the '@' character.
	 *
	 * @return {String}
	 */
	getMention : function() {
		return this.mention;
	},


	/**
	 * Returns the configured {@link #serviceName} to point the mention to.
	 * Ex: 'instagram', 'twitter'.
	 *
	 * @return {String}
	 */
	getServiceName : function() {
		return this.serviceName;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		switch( this.serviceName ) {
			case 'twitter' :
				return 'https://twitter.com/' + this.mention;
			case 'instagram' :
				return 'https://instagram.com/' + this.mention;

			default :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
				throw new Error( 'Unknown service name to point mention to: ', this.serviceName );
		}
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '@' + this.mention;
	},


	/**
	 * Returns the CSS class suffixes that should be used on a tag built with
	 * the match. See {@link Autolinker.match.Match#getCssClassSuffixes} for
	 * details.
	 *
	 * @return {String[]}
	 */
	getCssClassSuffixes : function() {
		var cssClassSuffixes = Autolinker.match.Match.prototype.getCssClassSuffixes.call( this ),
		    serviceName = this.getServiceName();

		if( serviceName ) {
			cssClassSuffixes.push( serviceName );
		}
		return cssClassSuffixes;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Url
 * @extends Autolinker.match.Match
 *
 * Represents a Url match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} url (required)
	 *
	 * The url that was matched.
	 */

	/**
	 * @cfg {"scheme"/"www"/"tld"} urlMatchType (required)
	 *
	 * The type of URL match that this class represents. This helps to determine
	 * if the match was made in the original text with a prefixed scheme (ex:
	 * 'http://www.google.com'), a prefixed 'www' (ex: 'www.google.com'), or
	 * was matched by a known top-level domain (ex: 'google.com').
	 */

	/**
	 * @cfg {Boolean} protocolUrlMatch (required)
	 *
	 * `true` if the URL is a match which already has a protocol (i.e.
	 * 'http://'), `false` if the match was from a 'www' or known TLD match.
	 */

	/**
	 * @cfg {Boolean} protocolRelativeMatch (required)
	 *
	 * `true` if the URL is a protocol-relative match. A protocol-relative match
	 * is a URL that starts with '//', and will be either http:// or https://
	 * based on the protocol that the site is loaded under.
	 */

	/**
	 * @cfg {Object} stripPrefix (required)
	 *
	 * The Object form of {@link Autolinker#cfg-stripPrefix}.
	 */

	/**
	 * @cfg {Boolean} stripTrailingSlash (required)
	 * @inheritdoc Autolinker#cfg-stripTrailingSlash
	 */

	/**
	 * @cfg {Boolean} decodePercentEncoding (required)
	 * @inheritdoc Autolinker#cfg-decodePercentEncoding
	 */

	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( cfg.urlMatchType !== 'scheme' && cfg.urlMatchType !== 'www' && cfg.urlMatchType !== 'tld' ) throw new Error( '`urlMatchType` cfg must be one of: "scheme", "www", or "tld"' );
		if( !cfg.url ) throw new Error( '`url` cfg required' );
		if( cfg.protocolUrlMatch == null ) throw new Error( '`protocolUrlMatch` cfg required' );
		if( cfg.protocolRelativeMatch == null ) throw new Error( '`protocolRelativeMatch` cfg required' );
		if( cfg.stripPrefix == null ) throw new Error( '`stripPrefix` cfg required' );
		if( cfg.stripTrailingSlash == null ) throw new Error( '`stripTrailingSlash` cfg required' );
		if( cfg.decodePercentEncoding == null ) throw new Error( '`decodePercentEncoding` cfg required' );

		this.urlMatchType = cfg.urlMatchType;
		this.url = cfg.url;
		this.protocolUrlMatch = cfg.protocolUrlMatch;
		this.protocolRelativeMatch = cfg.protocolRelativeMatch;
		this.stripPrefix = cfg.stripPrefix;
		this.stripTrailingSlash = cfg.stripTrailingSlash;
		this.decodePercentEncoding = cfg.decodePercentEncoding;
	},


	/**
	 * @private
	 * @property {RegExp} schemePrefixRegex
	 *
	 * A regular expression used to remove the 'http://' or 'https://' from
	 * URLs.
	 */
	schemePrefixRegex: /^(https?:\/\/)?/i,

	/**
	 * @private
	 * @property {RegExp} wwwPrefixRegex
	 *
	 * A regular expression used to remove the 'www.' from URLs.
	 */
	wwwPrefixRegex: /^(https?:\/\/)?(www\.)?/i,

	/**
	 * @private
	 * @property {RegExp} protocolRelativeRegex
	 *
	 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
	 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
	 */
	protocolRelativeRegex : /^\/\//,

	/**
	 * @private
	 * @property {Boolean} protocolPrepended
	 *
	 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
	 * {@link #url} did not have a protocol)
	 */
	protocolPrepended : false,


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'url';
	},


	/**
	 * Returns a string name for the type of URL match that this class
	 * represents.
	 *
	 * This helps to determine if the match was made in the original text with a
	 * prefixed scheme (ex: 'http://www.google.com'), a prefixed 'www' (ex:
	 * 'www.google.com'), or was matched by a known top-level domain (ex:
	 * 'google.com').
	 *
	 * @return {"scheme"/"www"/"tld"}
	 */
	getUrlMatchType : function() {
		return this.urlMatchType;
	},


	/**
	 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
	 * match was missing a protocol.
	 *
	 * @return {String}
	 */
	getUrl : function() {
		var url = this.url;

		// if the url string doesn't begin with a protocol, assume 'http://'
		if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
			url = this.url = 'http://' + url;

			this.protocolPrepended = true;
		}

		return url;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var url = this.getUrl();

		return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		var anchorText = this.getMatchedText();

		if( this.protocolRelativeMatch ) {
			// Strip off any protocol-relative '//' from the anchor text
			anchorText = this.stripProtocolRelativePrefix( anchorText );
		}
		if( this.stripPrefix.scheme ) {
			anchorText = this.stripSchemePrefix( anchorText );
		}
		if( this.stripPrefix.www ) {
			anchorText = this.stripWwwPrefix( anchorText );
		}
		if( this.stripTrailingSlash ) {
			anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one
		}
		if( this.decodePercentEncoding ) {
			anchorText = this.removePercentEncoding( anchorText);
		}

		return anchorText;
	},


	// ---------------------------------------

	// Utility Functionality

	/**
	 * Strips the scheme prefix (such as "http://" or "https://") from the given
	 * `url`.
	 *
	 * @private
	 * @param {String} url The text of the anchor that is being generated, for
	 *   which to strip off the url scheme.
	 * @return {String} The `url`, with the scheme stripped.
	 */
	stripSchemePrefix : function( url ) {
		return url.replace( this.schemePrefixRegex, '' );
	},


	/**
	 * Strips the 'www' prefix from the given `url`.
	 *
	 * @private
	 * @param {String} url The text of the anchor that is being generated, for
	 *   which to strip off the 'www' if it exists.
	 * @return {String} The `url`, with the 'www' stripped.
	 */
	stripWwwPrefix : function( url ) {
		return url.replace( this.wwwPrefixRegex, '$1' );  // leave any scheme ($1), it one exists
	},


	/**
	 * Strips any protocol-relative '//' from the anchor text.
	 *
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   protocol-relative prefix (such as stripping off "//")
	 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
	 */
	stripProtocolRelativePrefix : function( text ) {
		return text.replace( this.protocolRelativeRegex, '' );
	},


	/**
	 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
	 *
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
	 *   slash ('/') that may exist.
	 * @return {String} The `anchorText`, with the trailing slash removed.
	 */
	removeTrailingSlash : function( anchorText ) {
		if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
			anchorText = anchorText.slice( 0, -1 );
		}
		return anchorText;
	},

	/**
	 * Decodes percent-encoded characters from the given `anchorText`, in preparation for the text to be displayed.
	 *
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to decode any percent-encoded characters.
	 * @return {String} The `anchorText`, with the percent-encoded characters decoded.
	 */
	removePercentEncoding : function( anchorText ) {
		try {
			return decodeURIComponent( anchorText
				.replace( /%22/gi, '&quot;' )
				.replace( /%26/gi, '&amp;' )
				.replace( /%27/gi, '&#39;')
				.replace( /%3C/gi, '&lt;' )
				.replace( /%3E/gi, '&gt;' )
			 );
		} catch (e) {
			// Invalid escape sequence.
			return anchorText;
		}
	}

} );
// NOTE: THIS IS A GENERATED FILE
// To update with the latest TLD list, run `gulp update-tld-list`

/*global Autolinker */
Autolinker.tldRegex = /(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermögensberatung|xn--3oq18vl8pn36a|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermögensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbc0a9azcg|xn--nqv7fs00ema|afamilycompany|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|international|lifeinsurance|orientexpress|spreadbetting|travelchannel|wolterskluwer|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|pamperedchef|scholarships|versicherung|xn--3e0b707e|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|rightathome|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--3bst00m|xn--3ds443g|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--pbt977c|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b|சிங்கப்பூர்|accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nationwide|newholland|nextdirect|onyourside|properties|protection|prudential|realestate|republican|restaurant|schaeffler|swiftcover|tatamotors|technology|telefonica|university|vistaprint|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|fujixerox|furniture|goldpoint|goodhands|hisamitsu|homedepot|homegoods|homesense|honeywell|institute|insurance|kuokgroup|ladbrokes|lancaster|landrover|lifestyle|marketing|marshalls|mcdonalds|melbourne|microsoft|montblanc|panasonic|passagens|pramerica|richardli|scjohnson|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--nqv7f|xn--p1acf|xn--tckwe|xn--vhquv|yodobashi|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|budapest|builders|business|capetown|catering|catholic|chrysler|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|esurance|everbank|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|mortgage|movistar|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|symantec|telecity|training|uconnect|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama|السعودية|abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|cartier|channel|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|iselect|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lancome|lanxess|lasalle|latrobe|leclerc|liaison|limited|lincoln|markets|metlife|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|panerai|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|shriram|singles|spiegel|staples|starhub|statoil|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich|католик|الجزائر|العليان|پاکستان|كاثوليك|موبايلي|இந்தியா|abarth|abbott|abbvie|active|africa|agency|airbus|airtel|alipay|alsace|alstom|anquan|aramco|author|bayern|beauty|berlin|bharti|blanco|bostik|boston|broker|camera|career|caseih|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|mobily|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|piaget|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|warman|webcam|xihuan|xperia|yachts|yandex|zappos|москва|онлайн|ابوظبي|ارامكو|الاردن|المغرب|امارات|فلسطين|مليسيا|இலங்கை|ファッション|actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|boots|bosch|build|canon|cards|chase|cheap|chloe|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|dodge|drive|dubai|earth|edeka|email|epost|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glade|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|intel|irish|iveco|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|lixil|loans|locus|lotte|lotto|lupin|macys|mango|media|miami|money|mopar|movie|nadex|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vista|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo|zippo|ایران|بازار|بھارت|سودان|سورية|همراه|संगठन|বাংলা|భారత్|嘉里大酒店|aarp|able|adac|aero|aigo|akdn|ally|amex|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|doha|duck|duns|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|mtpc|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|raid|read|reit|rent|rest|rich|rmit|room|rsvp|ruhr|safe|sale|sapo|sarl|save|saxo|scor|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone|дети|сайт|بيتك|تونس|شبكة|عراق|عمان|موقع|भारत|ভারত|ਭਾਰਤ|ભારત|ලංකා|グーグル|クラウド|ポイント|大众汽车|组织机构|電訊盈科|香格里拉|aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bnl|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceb|ceo|cfa|cfd|com|crs|csc|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|htc|ibm|ice|icu|ifm|ing|ink|int|ist|itv|iwc|jcb|jcp|jio|jlc|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|lol|lpl|ltd|man|mba|mcd|med|men|meo|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|off|one|ong|onl|ooo|org|ott|ovh|pay|pet|pid|pin|pnc|pro|pru|pub|pwc|qvc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|srl|srt|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip|бел|ком|қаз|мкд|мон|орг|рус|срб|укр|հայ|קום|قطر|كوم|مصر|कॉम|नेट|คอม|ไทย|ストア|セール|みんな|中文网|天主教|我爱你|新加坡|淡马锡|诺基亚|飞利浦|ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|ελ|бг|ею|рф|გე|닷넷|닷컴|삼성|한국|コム|世界|中信|中国|中國|企业|佛山|信息|健康|八卦|公司|公益|台湾|台灣|商城|商店|商标|嘉里|在线|大拿|娱乐|家電|工行|广东|微博|慈善|手机|手表|政务|政府|新闻|时尚|書籍|机构|游戏|澳門|点看|珠宝|移动|网址|网店|网站|网络|联通|谷歌|购物|通販|集团|食品|餐厅|香港)/;

/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.matcher.Matcher
 *
 * An abstract class and interface for individual matchers to find matches in
 * an input string with linkified versions of them.
 *
 * Note that Matchers do not take HTML into account - they must be fed the text
 * nodes of any HTML string, which is handled by {@link Autolinker#parse}.
 */
Autolinker.matcher.Matcher = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
	 *
	 * Reference to the AnchorTagBuilder instance to use to generate HTML tags
	 * for {@link Autolinker.match.Match Matches}.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Matcher
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		if( !cfg.tagBuilder ) throw new Error( '`tagBuilder` cfg required' );

		this.tagBuilder = cfg.tagBuilder;
	},


	/**
	 * Parses the input `text` and returns the array of {@link Autolinker.match.Match Matches}
	 * for the matcher.
	 *
	 * @abstract
	 * @param {String} text The text to scan and replace matches in.
	 * @return {Autolinker.match.Match[]}
	 */
	parseMatches : Autolinker.Util.abstractMethod

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Email
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find email matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
 */
Autolinker.matcher.Email = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * The regular expression to match email addresses. Example match:
	 *
	 *     person@place.com
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : (function() {
		var alphaNumericChars = Autolinker.RegexLib.alphaNumericCharsStr,
			specialCharacters = '!#$%&\'*+\\-\\/=?^_`{|}~',
			restrictedSpecialCharacters = '\\s"(),:;<>@\\[\\]',
			validCharacters = alphaNumericChars + specialCharacters,
			validRestrictedCharacters = validCharacters + restrictedSpecialCharacters,
		    emailRegex = new RegExp( '(?:[' + validCharacters + '](?:[' + validCharacters + ']|\\.(?!\\.|@))*|\\"[' + validRestrictedCharacters + '.]+\\")@'),
			getDomainNameStr = Autolinker.RegexLib.getDomainNameStr,
			tldRegex = Autolinker.tldRegex;  // match our known top level domains (TLDs)

		return new RegExp( [
			emailRegex.source,
			getDomainNameStr(1),
			'\\.', tldRegex.source   // '.com', '.net', etc
		].join( "" ), 'gi' );
	} )(),


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var matchedText = match[ 0 ];

			matches.push( new Autolinker.match.Email( {
				tagBuilder  : tagBuilder,
				matchedText : matchedText,
				offset      : match.index,
				email       : matchedText
			} ) );
		}

		return matches;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.matcher.Hashtag
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find Hashtag matches in an input string.
 */
Autolinker.matcher.Hashtag = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */


	/**
	 * The regular expression to match Hashtags. Example match:
	 *
	 *     #asdf
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : new RegExp( '#[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,139}', 'g' ),

	/**
	 * The regular expression to use to check the character before a username match to
	 * make sure we didn't accidentally match an email address.
	 *
	 * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
	 *
	 * @private
	 * @property {RegExp} nonWordCharRegex
	 */
	nonWordCharRegex : new RegExp( '[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		this.serviceName = cfg.serviceName;
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    nonWordCharRegex = this.nonWordCharRegex,
		    serviceName = this.serviceName,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var offset = match.index,
			    prevChar = text.charAt( offset - 1 );

			// If we found the match at the beginning of the string, or we found the match
			// and there is a whitespace char in front of it (meaning it is not a '#' char
			// in the middle of a word), then it is a hashtag match.
			if( offset === 0 || nonWordCharRegex.test( prevChar ) ) {
				var matchedText = match[ 0 ],
				    hashtag = match[ 0 ].slice( 1 );  // strip off the '#' character at the beginning

				matches.push( new Autolinker.match.Hashtag( {
					tagBuilder  : tagBuilder,
					matchedText : matchedText,
					offset      : offset,
					serviceName : serviceName,
					hashtag     : hashtag
				} ) );
			}
		}

		return matches;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Phone
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find Phone number matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more
 * details.
 */
Autolinker.matcher.Phone = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * The regular expression to match Phone numbers. Example match:
	 *
	 *     (123) 456-7890
	 *
	 * This regular expression has the following capturing groups:
	 *
	 * 1 or 2. The prefixed '+' sign, if there is one.
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : /(?:(?:(?:(\+)?\d{1,3}[-\040.]?)?\(?\d{3}\)?[-\040.]?\d{3}[-\040.]?\d{4})|(?:(\+)(?:9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-\040.]?(?:\d[-\040.]?){6,12}\d+))([,;]+[0-9]+#?)*/g,

	// ex: (123) 456-7890, 123 456 7890, 123-456-7890, +18004441234,,;,10226420346#,
	// +1 (800) 444 1234, 10226420346#, 1-800-444-1234,1022,64,20346#

	/**
	 * @inheritdoc
	 */
	parseMatches: function(text) {
		var matcherRegex = this.matcherRegex,
			tagBuilder = this.tagBuilder,
			matches = [],
			match;

		while ((match = matcherRegex.exec(text)) !== null) {
			// Remove non-numeric values from phone number string
			var matchedText = match[0],
				cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''), // strip out non-digit characters exclude comma semicolon and #
				plusSign = !!(match[1] || match[2]), // match[ 1 ] or match[ 2 ] is the prefixed plus sign, if there is one
				before = match.index == 0 ? '' : text.substr(match.index - 1, 1),
				after = text.substr(match.index + matchedText.length, 1),
				contextClear = !before.match(/\d/) && !after.match(/\d/);

			if (this.testMatch(match[3]) && this.testMatch(matchedText) && contextClear) {
				matches.push(new Autolinker.match.Phone({
					tagBuilder: tagBuilder,
					matchedText: matchedText,
					offset: match.index,
					number: cleanNumber,
					plusSign: plusSign
				}));
			}
		}

		return matches;
	},

	testMatch: function(text) {
		return /\D/.test(text);
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.matcher.Mention
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find/replace username matches in an input string.
 */
Autolinker.matcher.Mention = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * Hash of regular expression to match username handles. Example match:
	 *
	 *     @asdf
	 *
	 * @private
	 * @property {Object} matcherRegexes
	 */
	matcherRegexes : {
		"twitter": new RegExp( '@[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,20}', 'g' ),
		"instagram": new RegExp( '@[_.' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,50}', 'g' )
	},

	/**
	 * The regular expression to use to check the character before a username match to
	 * make sure we didn't accidentally match an email address.
	 *
	 * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
	 *
	 * @private
	 * @property {RegExp} nonWordCharRegex
	 */
	nonWordCharRegex : new RegExp( '[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		this.serviceName = cfg.serviceName;
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegexes[this.serviceName],
		    nonWordCharRegex = this.nonWordCharRegex,
		    serviceName = this.serviceName,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		if (!matcherRegex) {
			return matches;
		}

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var offset = match.index,
			    prevChar = text.charAt( offset - 1 );

			// If we found the match at the beginning of the string, or we found the match
			// and there is a whitespace char in front of it (meaning it is not an email
			// address), then it is a username match.
			if( offset === 0 || nonWordCharRegex.test( prevChar ) ) {
				var matchedText = match[ 0 ].replace(/\.+$/g, ''), // strip off trailing .
				    mention = matchedText.slice( 1 );  // strip off the '@' character at the beginning

				matches.push( new Autolinker.match.Mention( {
					tagBuilder    : tagBuilder,
					matchedText   : matchedText,
					offset        : offset,
					serviceName   : serviceName,
					mention       : mention
				} ) );
			}
		}

		return matches;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.matcher.Url
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find URL matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
 */
Autolinker.matcher.Url = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * @cfg {Object} stripPrefix (required)
	 *
	 * The Object form of {@link Autolinker#cfg-stripPrefix}.
	 */

	/**
	 * @cfg {Boolean} stripTrailingSlash (required)
	 * @inheritdoc Autolinker#stripTrailingSlash
	 */

	/**
	 * @cfg {Boolean} decodePercentEncoding (required)
	 * @inheritdoc Autolinker#decodePercentEncoding
	 */


	/**
	 * @private
	 * @property {RegExp} matcherRegex
	 *
	 * The regular expression to match URLs with an optional scheme, port
	 * number, path, query string, and hash anchor.
	 *
	 * Example matches:
	 *
	 *     http://google.com
	 *     www.google.com
	 *     google.com/path/to/file?q1=1&q2=2#myAnchor
	 *
	 *
	 * This regular expression will have the following capturing groups:
	 *
	 * 1.  Group that matches a scheme-prefixed URL (i.e. 'http://google.com').
	 *     This is used to match scheme URLs with just a single word, such as
	 *     'http://localhost', where we won't double check that the domain name
	 *     has at least one dot ('.') in it.
	 * 2.  Group that matches a 'www.' prefixed URL. This is only matched if the
	 *     'www.' text was not prefixed by a scheme (i.e.: not prefixed by
	 *     'http://', 'ftp:', etc.)
	 * 3.  A protocol-relative ('//') match for the case of a 'www.' prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     We need to know the character before the '//' in order to determine
	 *     if it is a valid match or the // was in a string we don't want to
	 *     auto-link.
	 * 4.  Group that matches a known TLD (top level domain), when a scheme
	 *     or 'www.'-prefixed domain is not matched.
	 * 5.  A protocol-relative ('//') match for the case of a known TLD prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     See #3 for more info.
	 */
	matcherRegex : (function() {
		var schemeRegex = /(?:[A-Za-z][-.+A-Za-z0-9]{0,63}:(?![A-Za-z][-.+A-Za-z0-9]{0,63}:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
		    wwwRegex = /(?:www\.)/,                  // starting with 'www.'
		    getDomainNameStr = Autolinker.RegexLib.getDomainNameStr,
		    tldRegex = Autolinker.tldRegex,  // match our known top level domains (TLDs)
		    alphaNumericCharsStr = Autolinker.RegexLib.alphaNumericCharsStr,

		    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
		    // http://blog.codinghorror.com/the-problem-with-urls/
		    urlSuffixRegex = new RegExp( '[/?#](?:[' + alphaNumericCharsStr + '\\-+&@#/%=~_()|\'$*\\[\\]?!:,.;\u2713]*[' + alphaNumericCharsStr + '\\-+&@#/%=~_()|\'$*\\[\\]\u2713])?' );

		return new RegExp( [
			'(?:', // parens to cover match for scheme (optional), and domain
				'(',  // *** Capturing group $1, for a scheme-prefixed url (ex: http://google.com)
					schemeRegex.source,
					getDomainNameStr(2),
				')',

				'|',

				'(',  // *** Capturing group $4 for a 'www.' prefixed url (ex: www.google.com)
					'(//)?',  // *** Capturing group $5 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					wwwRegex.source,
					getDomainNameStr(6),
				')',

				'|',

				'(',  // *** Capturing group $8, for known a TLD url (ex: google.com)
					'(//)?',  // *** Capturing group $9 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					getDomainNameStr(10) + '\\.',
					tldRegex.source,
					'(?![-' + alphaNumericCharsStr + '])', // TLD not followed by a letter, behaves like unicode-aware \b
				')',
			')',

			'(?::[0-9]+)?', // port

			'(?:' + urlSuffixRegex.source + ')?'  // match for path, query string, and/or hash anchor - optional
		].join( "" ), 'gi' );
	} )(),


	/**
	 * A regular expression to use to check the character before a protocol-relative
	 * URL match. We don't want to match a protocol-relative URL if it is part
	 * of another word.
	 *
	 * For example, we want to match something like "Go to: //google.com",
	 * but we don't want to match something like "abc//google.com"
	 *
	 * This regular expression is used to test the character before the '//'.
	 *
	 * @private
	 * @type {RegExp} wordCharRegExp
	 */
	wordCharRegExp : new RegExp( '[' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * The regular expression to match opening parenthesis in a URL match.
	 *
	 * This is to determine if we have unbalanced parenthesis in the URL, and to
	 * drop the final parenthesis that was matched if so.
	 *
	 * Ex: The text "(check out: wikipedia.com/something_(disambiguation))"
	 * should only autolink the inner "wikipedia.com/something_(disambiguation)"
	 * part, so if we find that we have unbalanced parenthesis, we will drop the
	 * last one for the match.
	 *
	 * @private
	 * @property {RegExp}
	 */
	openParensRe : /\(/g,

	/**
	 * The regular expression to match closing parenthesis in a URL match. See
	 * {@link #openParensRe} for more information.
	 *
	 * @private
	 * @property {RegExp}
	 */
	closeParensRe : /\)/g,


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		if( cfg.stripPrefix == null ) throw new Error( '`stripPrefix` cfg required' );
		if( cfg.stripTrailingSlash == null ) throw new Error( '`stripTrailingSlash` cfg required' );

		this.stripPrefix = cfg.stripPrefix;
		this.stripTrailingSlash = cfg.stripTrailingSlash;
		this.decodePercentEncoding = cfg.decodePercentEncoding;
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    stripPrefix = this.stripPrefix,
		    stripTrailingSlash = this.stripTrailingSlash,
		    decodePercentEncoding = this.decodePercentEncoding,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var matchStr = match[ 0 ],
			    schemeUrlMatch = match[ 1 ],
			    wwwUrlMatch = match[ 4 ],
			    wwwProtocolRelativeMatch = match[ 5 ],
			    //tldUrlMatch = match[ 8 ],  -- not needed at the moment
			    tldProtocolRelativeMatch = match[ 9 ],
			    offset = match.index,
			    protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
				prevChar = text.charAt( offset - 1 );

			if( !Autolinker.matcher.UrlMatchValidator.isValid( matchStr, schemeUrlMatch ) ) {
				continue;
			}

			// If the match is preceded by an '@' character, then it is either
			// an email address or a username. Skip these types of matches.
			if( offset > 0 && prevChar === '@' ) {
				continue;
			}

			// If it's a protocol-relative '//' match, but the character before the '//'
			// was a word character (i.e. a letter/number), then we found the '//' in the
			// middle of another word (such as "asdf//asdf.com"). In this case, skip the
			// match.
			if( offset > 0 && protocolRelativeMatch && this.wordCharRegExp.test( prevChar ) ) {
				continue;
			}

			if( /\?$/.test(matchStr) ) {
				matchStr = matchStr.substr(0, matchStr.length-1);
			}

			// Handle a closing parenthesis at the end of the match, and exclude
			// it if there is not a matching open parenthesis in the match
			// itself.
			if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
				matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
			} else {
				// Handle an invalid character after the TLD
				var pos = this.matchHasInvalidCharAfterTld( matchStr, schemeUrlMatch );
				if( pos > -1 ) {
					matchStr = matchStr.substr( 0, pos ); // remove the trailing invalid chars
				}
			}

			var urlMatchType = schemeUrlMatch ? 'scheme' : ( wwwUrlMatch ? 'www' : 'tld' ),
			    protocolUrlMatch = !!schemeUrlMatch;

			matches.push( new Autolinker.match.Url( {
				tagBuilder            : tagBuilder,
				matchedText           : matchStr,
				offset                : offset,
				urlMatchType          : urlMatchType,
				url                   : matchStr,
				protocolUrlMatch      : protocolUrlMatch,
				protocolRelativeMatch : !!protocolRelativeMatch,
				stripPrefix           : stripPrefix,
				stripTrailingSlash    : stripTrailingSlash,
				decodePercentEncoding : decodePercentEncoding,
			} ) );
		}

		return matches;
	},


	/**
	 * Determines if a match found has an unmatched closing parenthesis. If so,
	 * this parenthesis will be removed from the match itself, and appended
	 * after the generated anchor tag.
	 *
	 * A match may have an extra closing parenthesis at the end of the match
	 * because the regular expression must include parenthesis for URLs such as
	 * "wikipedia.com/something_(disambiguation)", which should be auto-linked.
	 *
	 * However, an extra parenthesis *will* be included when the URL itself is
	 * wrapped in parenthesis, such as in the case of "(wikipedia.com/something_(disambiguation))".
	 * In this case, the last closing parenthesis should *not* be part of the
	 * URL itself, and this method will return `true`.
	 *
	 * @private
	 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
	 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at
	 *   the end of the `matchStr`, `false` otherwise.
	 */
	matchHasUnbalancedClosingParen : function( matchStr ) {
		var lastChar = matchStr.charAt( matchStr.length - 1 );

		if( lastChar === ')' ) {
			var openParensMatch = matchStr.match( this.openParensRe ),
			    closeParensMatch = matchStr.match( this.closeParensRe ),
			    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
			    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;

			if( numOpenParens < numCloseParens ) {
				return true;
			}
		}

		return false;
	},


	/**
	 * Determine if there's an invalid character after the TLD in a URL. Valid
	 * characters after TLD are ':/?#'. Exclude scheme matched URLs from this
	 * check.
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} schemeUrlMatch The match URL string for a scheme
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Number} the position where the invalid character was found. If
	 *   no such character was found, returns -1
	 */
	matchHasInvalidCharAfterTld : function( urlMatch, schemeUrlMatch ) {
		if( !urlMatch ) {
			return -1;
		}

		var offset = 0;
		if ( schemeUrlMatch ) {
			offset = urlMatch.indexOf(':');
			urlMatch = urlMatch.slice(offset);
		}

		var alphaNumeric = Autolinker.RegexLib.alphaNumericCharsStr;

		var re = new RegExp("^((.?\/\/)?[-." + alphaNumeric + "]*[-" + alphaNumeric + "]\\.[-" + alphaNumeric + "]+)");
		var res = re.exec( urlMatch );
		if ( res === null ) {
			return -1;
		}

		offset += res[1].length;
		urlMatch = urlMatch.slice(res[1].length);
		if (/^[^-.A-Za-z0-9:\/?#]/.test(urlMatch)) {
			return offset;
		}

		return -1;
	}

} );

/*global Autolinker */
/*jshint scripturl:true */
/**
 * @private
 * @class Autolinker.matcher.UrlMatchValidator
 * @singleton
 *
 * Used by Autolinker to filter out false URL positives from the
 * {@link Autolinker.matcher.Url UrlMatcher}.
 *
 * Due to the limitations of regular expressions (including the missing feature
 * of look-behinds in JS regular expressions), we cannot always determine the
 * validity of a given match. This class applies a bit of additional logic to
 * filter out any false positives that have been matched by the
 * {@link Autolinker.matcher.Url UrlMatcher}.
 */
Autolinker.matcher.UrlMatchValidator = {

	/**
	 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
	 *
	 * @private
	 * @property {RegExp} hasFullProtocolRegex
	 */
	hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]*:\/\//,

	/**
	 * Regex to find the URI scheme, such as 'mailto:'.
	 *
	 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
	 *
	 * @private
	 * @property {RegExp} uriSchemeRegex
	 */
	uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]*:/,

	/**
	 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
	 *
	 * @private
	 * @property {RegExp} hasWordCharAfterProtocolRegex
	 */
	hasWordCharAfterProtocolRegex : new RegExp(":[^\\s]*?[" + Autolinker.RegexLib.alphaCharsStr + "]"),

	/**
	 * Regex to determine if the string is a valid IP address
	 *
	 * @private
	 * @property {RegExp} ipRegex
	 */
	ipRegex: /[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?(:[0-9]*)?\/?$/,

	/**
	 * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}
	 * is valid. Will return `false` for:
	 *
	 * 1) URL matches which do not have at least have one period ('.') in the
	 *    domain name (effectively skipping over matches like "abc:def").
	 *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')
	 * 2) URL matches which do not have at least one word character in the
	 *    domain name (effectively skipping over matches like "git:1.0").
	 * 3) A protocol-relative url match (a URL beginning with '//') whose
	 *    previous character is a word character (effectively skipping over
	 *    strings like "abc//google.com")
	 *
	 * Otherwise, returns `true`.
	 *
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the match given is valid and should be
	 *   processed, or `false` if the match is invalid and/or should just not be
	 *   processed.
	 */
	isValid : function( urlMatch, protocolUrlMatch ) {
		if(
			( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
			this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||    // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
			(this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
			   !this.isValidIpAddress( urlMatch )) || // Except if it's an IP address
			this.containsMultipleDots( urlMatch )
		) {
			return false;
		}

		return true;
	},


	isValidIpAddress : function ( uriSchemeMatch ) {
		var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);
		var uriScheme = uriSchemeMatch.match( newRegex );

		return uriScheme !== null;
	},

	containsMultipleDots : function ( urlMatch ) {
		var stringBeforeSlash = urlMatch;
		if (this.hasFullProtocolRegex.test(urlMatch)) {
			stringBeforeSlash = urlMatch.split('://')[1];
		}
		return stringBeforeSlash.split('/')[0].indexOf("..") > -1;
	},

	/**
	 * Determines if the URI scheme is a valid scheme to be autolinked. Returns
	 * `false` if the scheme is 'javascript:' or 'vbscript:'
	 *
	 * @private
	 * @param {String} uriSchemeMatch The match URL string for a full URI scheme
	 *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.
	 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
	 */
	isValidUriScheme : function( uriSchemeMatch ) {
		var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();

		return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
	},


	/**
	 * Determines if a URL match does not have either:
	 *
	 * a) a full protocol (i.e. 'http://'), or
	 * b) at least one dot ('.') in the domain name (for a non-full-protocol
	 *    match).
	 *
	 * Either situation is considered an invalid URL (ex: 'git:d' does not have
	 * either the '://' part, or at least one dot in the domain name. If the
	 * match was 'git:abc.com', we would consider this valid.)
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the URL match does not have a full protocol,
	 *   or at least one dot ('.') in a non-full-protocol match.
	 */
	urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
		return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
	},


	/**
	 * Determines if a URL match does not have at least one word character after
	 * the protocol (i.e. in the domain name).
	 *
	 * At least one letter character must exist in the domain name after a
	 * protocol match. Ex: skip over something like "git:1.0"
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we
	 *   have a protocol in the URL string, in order to check for a word
	 *   character after the protocol separator (':').
	 * @return {Boolean} `true` if the URL match does not have at least one word
	 *   character in it after the protocol, `false` otherwise.
	 */
	urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
		if( urlMatch && protocolUrlMatch ) {
			return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
		} else {
			return false;
		}
	}

};

/*global Autolinker */
/**
 * A truncation feature where the ellipsis will be placed at the end of the URL.
 *
 * @param {String} anchorText
 * @param {Number} truncateLen The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars The characters to place within the url, e.g. "..".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateEnd = function(anchorText, truncateLen, ellipsisChars){
	return Autolinker.Util.ellipsis( anchorText, truncateLen, ellipsisChars );
};

/*global Autolinker */
/**
 * Date: 2015-10-05
 * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)
 *
 * A truncation feature, where the ellipsis will be placed in the dead-center of the URL.
 *
 * @param {String} url             A URL.
 * @param {Number} truncateLen     The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars   The characters to place within the url, e.g. "..".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateMiddle = function(url, truncateLen, ellipsisChars){
  if (url.length <= truncateLen) {
    return url;
  }

  var ellipsisLengthBeforeParsing;
  var ellipsisLength;

  if(ellipsisChars == null) {
    ellipsisChars = '&hellip;';
    ellipsisLengthBeforeParsing = 8;
    ellipsisLength = 3;
  } else {
    ellipsisLengthBeforeParsing = ellipsisChars.length;
    ellipsisLength = ellipsisChars.length;
  }

  var availableLength = truncateLen - ellipsisLength;
  var end = "";
  if (availableLength > 0) {
    end = url.substr((-1)*Math.floor(availableLength/2));
  }
  return (url.substr(0, Math.ceil(availableLength/2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);
};

/*global Autolinker */
/**
 * Date: 2015-10-05
 * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)
 *
 * A truncation feature, where the ellipsis will be placed at a section within
 * the URL making it still somewhat human readable.
 *
 * @param {String} url						 A URL.
 * @param {Number} truncateLen		 The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars	 The characters to place within the url, e.g. "...".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateSmart = function(url, truncateLen, ellipsisChars){

	var ellipsisLengthBeforeParsing;
	var ellipsisLength;

	if(ellipsisChars == null) {
		ellipsisChars = '&hellip;';
		ellipsisLength = 3;
		ellipsisLengthBeforeParsing = 8;
	} else {
		ellipsisLength = ellipsisChars.length;
		ellipsisLengthBeforeParsing = ellipsisChars.length;
	}

	var parse_url = function(url){ // Functionality inspired by PHP function of same name
		var urlObj = {};
		var urlSub = url;
		var match = urlSub.match(/^([a-z]+):\/\//i);
		if (match) {
			urlObj.scheme = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^(.*?)(?=(\?|#|\/|$))/i);
		if (match) {
			urlObj.host = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^\/(.*?)(?=(\?|#|$))/i);
		if (match) {
			urlObj.path = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^\?(.*?)(?=(#|$))/i);
		if (match) {
			urlObj.query = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^#(.*?)$/i);
		if (match) {
			urlObj.fragment = match[1];
			//urlSub = urlSub.substr(match[0].length);  -- not used. Uncomment if adding another block.
		}
		return urlObj;
	};

	var buildUrl = function(urlObj){
		var url = "";
		if (urlObj.scheme && urlObj.host) {
			url += urlObj.scheme + "://";
		}
		if (urlObj.host) {
			url += urlObj.host;
		}
		if (urlObj.path) {
			url += "/" + urlObj.path;
		}
		if (urlObj.query) {
			url += "?" + urlObj.query;
		}
		if (urlObj.fragment) {
			url += "#" + urlObj.fragment;
		}
		return url;
	};

	var buildSegment = function(segment, remainingAvailableLength){
		var remainingAvailableLengthHalf = remainingAvailableLength/ 2,
				startOffset = Math.ceil(remainingAvailableLengthHalf),
				endOffset = (-1)*Math.floor(remainingAvailableLengthHalf),
				end = "";
		if (endOffset < 0) {
			end = segment.substr(endOffset);
		}
		return segment.substr(0, startOffset) + ellipsisChars + end;
	};
	if (url.length <= truncateLen) {
		return url;
	}
	var availableLength = truncateLen - ellipsisLength;
	var urlObj = parse_url(url);
	// Clean up the URL
	if (urlObj.query) {
		var matchQuery = urlObj.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i);
		if (matchQuery) {
			// Malformed URL; two or more "?". Removed any content behind the 2nd.
			urlObj.query = urlObj.query.substr(0, matchQuery[1].length);
			url = buildUrl(urlObj);
		}
	}
	if (url.length <= truncateLen) {
		return url;
	}
	if (urlObj.host) {
		urlObj.host = urlObj.host.replace(/^www\./, "");
		url = buildUrl(urlObj);
	}
	if (url.length <= truncateLen) {
		return url;
	}
	// Process and build the URL
	var str = "";
	if (urlObj.host) {
		str += urlObj.host;
	}
	if (str.length >= availableLength) {
		if (urlObj.host.length == truncateLen) {
			return (urlObj.host.substr(0, (truncateLen - ellipsisLength)) + ellipsisChars).substr(0, availableLength + ellipsisLengthBeforeParsing);
		}
		return buildSegment(str, availableLength).substr(0, availableLength + ellipsisLengthBeforeParsing);
	}
	var pathAndQuery = "";
	if (urlObj.path) {
		pathAndQuery += "/" + urlObj.path;
	}
	if (urlObj.query) {
		pathAndQuery += "?" + urlObj.query;
	}
	if (pathAndQuery) {
		if ((str+pathAndQuery).length >= availableLength) {
			if ((str+pathAndQuery).length == truncateLen) {
				return (str + pathAndQuery).substr(0, truncateLen);
			}
			var remainingAvailableLength = availableLength - str.length;
			return (str + buildSegment(pathAndQuery, remainingAvailableLength)).substr(0, availableLength + ellipsisLengthBeforeParsing);
		} else {
			str += pathAndQuery;
		}
	}
	if (urlObj.fragment) {
		var fragment = "#"+urlObj.fragment;
		if ((str+fragment).length >= availableLength) {
			if ((str+fragment).length == truncateLen) {
				return (str + fragment).substr(0, truncateLen);
			}
			var remainingAvailableLength2 = availableLength - str.length;
			return (str + buildSegment(fragment, remainingAvailableLength2)).substr(0, availableLength + ellipsisLengthBeforeParsing);
		} else {
			str += fragment;
		}
	}
	if (urlObj.scheme && urlObj.host) {
		var scheme = urlObj.scheme + "://";
		if ((str+scheme).length < availableLength) {
			return (scheme + str).substr(0, truncateLen);
		}
	}
	if (str.length <= truncateLen) {
		return str;
	}
	var end = "";
	if (availableLength > 0) {
		end = str.substr((-1)*Math.floor(availableLength/2));
	}
	return (str.substr(0, Math.ceil(availableLength/2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);
};

return Autolinker;
}));

(function ($) {
    var methods = {
        init: function (f) {
            var that = $(this);
            var modalId = that.data('modal');
            var modal = $('#' + modalId).addClass('open-modal').children();
            modal.append('<span class="modal-close"><i class="fal fa-times"></i></span>');
            if (f) f(that, modal);
        },
        destroy: function () {
            var modal = $(this);
            if (!modal.is('.modal-container')) {
                modal = modal.parents('.modal-container');
            }
            modal.removeClass('open-modal').find('.modal-close').remove();
            modal.find('textarea, input').val('')
        }
    };

    $('body').on('click', '.modal-close', function () {
        var modal = $(this).parents('.modal-container');
        modal.removeClass('open-modal');
        $(this).remove();
    }).on('mousedown', '.modal-container', function (e) {
        if (e.target !== this) return;
        $('.modal-close').trigger('click');
    });

    $.fn.modal = function (f) {
        if (typeof f === 'string' && f === 'destroy') {
            return methods.destroy.apply(this, []);
        } else {
            this.click(function () {
                if (typeof f === 'function') {
                    return methods.init.apply(this, [f]);
                } else {
                    return methods.init.apply(this, []);
                }
            })
        }
    };

})(jQuery);
var linkWhiteList = [window.location.hostname, 'wikipedia.org', 'youtube.com', 'imgur.com', 'youtu.be', 'prnt.sc'];
var commentsLinkWhiteList = [window.location.hostname, 'wikipedia.org', 'imgur.com', 'prnt.sc'];

Date.prototype.addHours = function (h) {
    this.setTime(this.getTime() + (h * 60 * 60 * 1000));
    return this;
};

function getMobileOperatingSystem() {
    var userAgent = navigator.userAgent || navigator.vendor || window.opera;
    if (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
        return 'iOS';
    } else if (userAgent.match(/Android/i)) {
        return 'Android';
    } else if (userAgent.match(/Trident/i)) {
        return 'IE';
    } else if (userAgent.match(/Edge/i)) {
        return 'Edge';
    } else if (userAgent.match(/Opera/i) || userAgent.match(/OPR/i)) {
        return 'Opera'
    } /* else if (userAgent.match(/Macintosh/i)){
         return 'Macintosh';
         }*/ else {
        return 'unknown';
    }
}

$(document).ready(function () {
    $.ajaxSetup({
        headers: {
            'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
        }
    });

    function refreshToken() {
        $.get('/refresh-csrf').done(function (data) {
            $('meta[name="csrf-token"]').attr('content', data);
            $.ajaxSetup({
                headers: {
                    'X-CSRF-TOKEN': data
                }
            });
        });
    }

    setInterval(refreshToken, 3600000); // 1 hour

    $.fn.exists = function () {
        return this.length > 0;
    };

    var os = getMobileOperatingSystem();
    if (os == 'iOS') {
        $('#frame').hide();
        $('.top').addClass('ios');
    }

    $('#dub-select > option').each(function () {
        var dub = $(this);
        var max = 0;
        $('#player-select option[data-name="' + dub.val() + '"]').each(function () {
            var player = $(this);
            var count = $('.episodes-container[data-id="' + player.val() + '"] .video-button').length;
            player.text(player.text() + ' (' + count + ' эп.)');
            max = max < count ? count : max;
        });
        dub.text(dub.text() + ' (' + max + ' эп.)');
    });

    //init SlimSelect plugin
    $("select.slim-select").slimSelect();

    //init resize
    $(".custom-scroll.resizable").TextAreaResizer();

    if ($(".video-block-select").exists()) {
        $(".video-block-select").find('select').each(function () {
            var select = $(this);
            if (select.find('option').length <= 1) {
                select.prop('disabled', true).next('.slim-select').addClass('disabled')
            }
        })
    }

    $('.tabs-li').click(function () {
        var that = $(this);
        that.parent().find('.tabs-li').removeClass('active');
        that.addClass('active');
        var block = that.data('id');
        that.parents('.tabs-block').find('.tab-content').removeClass('active');
        $(block).addClass('active');

        var url = that.data('url');
        if (url) {
            window.history.pushState("", "", window.location.pathname + '?tab=' + url);
        }
    });

    $(window).on("popstate", function () {
        if (window.location.href.substr(-1) !== '#') {
            $('.tabs-li[data-url="' + window.location.search.replace(/.+tab=(\w+).*/, '$1') + '"]').trigger('click');
        }
    });

    //mobile-filter
    $('.mobile-filter-toggle').click(function () {
        $('body').toggleClass('filter-open');
        $('.filter-block').removeClass('main').find('.collapse').removeClass('collapse');
    });

    //update anime list from anime page
    $('.to-list').click(function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {
            $('.to-list').addClass('blocked');
            that.parents('.content-buttons').find('.hidden-menu').addClass('invisible');

            var id = that.data('id');
            var list_id;
            var action = 1;

            var buttonId = that.attr('id');
            if (buttonId === 'watch_now') {
                list_id = 1;
            } else if (buttonId === 'will') {
                list_id = 2;
            } else if (buttonId === 'watched') {
                list_id = 3;
            } else if (buttonId === 'lost') {
                list_id = 5;
            } else return;

            if (that.hasClass('active')) {
                action = 0;
            }

            $.ajax({
                url: '/update-list',
                type: 'post',
                data: 'id=' + id + '&list_id=' + list_id + '&action=' + action,
                success: function (data) {
                    if (data) {
                        $('.content-buttons li').removeClass('active');
                        if (action !== 0) {
                            showNotice('Аниме добавлено в список ' + that.text());
                            $('.to-list, .drop-menu-click').removeClass('blocked').removeClass('active');
                            that.addClass('active');
                            if (buttonId === 'watched' || buttonId === 'lost') {
                                $('.drop-menu-click').addClass('active');
                            } else if (buttonId === 'will') {
                                $('.user-rating').remove();
                            }
                        } else {
                            showNotice('Аниме удалено из списка ' + that.text());
                            $('.to-list, .drop-menu-click').removeClass('blocked').removeClass('active');
                            that.removeClass('active');
                            if (buttonId === 'watched' || buttonId === 'lost') {
                                $('.drop-menu-click').removeClass('active');
                            }
                            $('.user-rating').remove();
                        }
                    } else showNotice('Не удалось добавить в список', 'Ошибка', 'error')
                }
            });
        }
    });

    $('.update-list').on('click', '.list-remove', function () {
        var that = $(this);
        var action = 0;
        var list_id = that.parents('.update-list').data('listid');
        update_list(that, list_id, action);
    }).on('click', '.list-will-watch', function () {
        var list_id = 2;
        update_list($(this), list_id);
    }).on('click', '.list-watched', function () {
        var list_id = 3;
        update_list($(this), list_id);
    }).on('click', '.list-lost', function () {
        var list_id = 5;
        update_list($(this), list_id);
    }).on('click', '.list-watch-now', function () {
        var list_id = 1;
        update_list($(this), list_id);
    }).on('click', '.list-buttons-control', function () {
        $(this).parent().find('.list-buttons-list').toggleClass('open');
        return false;
    }).on('click', '.addtofavourite', function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var id = that.data('id');
            if (!that.hasClass('active')) {
                $.ajax({
                    url: '/update-list',
                    type: 'post',
                    data: 'id=' + id + '&list_id=4',
                    success: function (data) {
                        if (data) {
                            that.addClass('active').attr('title', 'Удалить из любимого');
                            showNotice('Добавлено в список любимого');
                        } else {
                            that.removeClass('active');
                        }
                        that.removeClass('blocked');
                    }
                });
            } else {
                $.ajax({
                    url: '/update-list',
                    type: 'post',
                    data: 'id=' + id + '&list_id=4&action=0',
                    success: function (data) {
                        if (data) {
                            that.removeClass('active').attr('title', 'Добавить в любимое');
                            showNotice('Удалено из списка любимого');
                        } else {
                            that.addClass('active');
                        }
                        that.removeClass('blocked');
                    }
                });
            }
        }
    });

    function update_list(elem, list_id, action) {
        if (!elem.hasClass('blocked')) {
            elem.addClass('blocked');
            if (typeof action == 'undefined') {
                action = 1;
            }
            var li = elem.parents('.update-list > li');
            var id = elem.data('id');
            $.ajax({
                url: '/update-list',
                type: 'post',
                data: 'id=' + id + '&list_id=' + list_id + '&action=' + action,
                success: function () {
                    var old_list_id = li.parent().data('listid');
                    var listRemove = $('.tabs-li[data-listid=' + old_list_id + ']').find('.count');
                    var countRemove = ~~listRemove.text();
                    var title = li.find('.update-title').text()
                    listRemove.text(--countRemove);
                    if (action === 0) {
                        showNotice('Аниме "' + $.trim(title) + '" успешно удалено');
                    } else {
                        showNotice('Аниме "' + $.trim(title) + '" успешно перемещено в ' + $.trim(elem.attr('title')));
                    }
                    li.remove();
                    if (action !== 0) {
                        var count = $('.tabs-li[data-listid=' + list_id + ']').find('.count');
                        count.text(~~count.text() + 1)
                    }
                    elem.removeClass('blocked');
                }
            });
        }
    }

    //toggle login form
    $('.login').click(function () {
        $(this).next().toggleClass('open');
    });

    //search
    $('.search-submit .fal').click(function () {
        $(this).next().click();
    });

    //mobile menu
    $('.mobile-menu-button').click(function () {
        $('.header .menu').toggleClass('show');
    });

    $('.sub-menu-link > a').click(function (e) {
        e.preventDefault();
    });

    //translate url

    function translit() {
        var space = '-'; // Символ, на который будут заменяться все спецсимволы
        var text = $('#name').val().toLowerCase(); // Берем значение из нужного поля и переводим в нижний регистр

        // Массив для транслитерации
        var transl = {
            'а': 'a',
            'б': 'b',
            'в': 'v',
            'г': 'g',
            'д': 'd',
            'е': 'e',
            'ё': 'e',
            'ж': 'zh',
            'з': 'z',
            'и': 'i',
            'й': 'j',
            'к': 'k',
            'л': 'l',
            'м': 'm',
            'н': 'n',
            'о': 'o',
            'п': 'p',
            'р': 'r',
            'с': 's',
            'т': 't',
            'у': 'u',
            'ф': 'f',
            'х': 'h',
            'ц': 'c',
            'ч': 'ch',
            'ш': 'sh',
            'щ': 'sh',
            'ъ': space,
            'ы': 'y',
            'ь': space,
            'э': 'e',
            'ю': 'yu',
            'я': 'ya',
            ' ': space,
            '_': space,
            '`': space,
            '~': space,
            '!': space,
            '@': space,
            '#': space,
            '$': space,
            '%': space,
            '^': space,
            '&': space,
            '*': space,
            '(': space,
            ')': space,
            '-': space,
            '\=': space,
            '+': space,
            '[': space,
            ']': space,
            '\\': space,
            '|': space,
            '/': space,
            '.': space,
            ',': space,
            '{': space,
            '}': space,
            '\'': space,
            '"': space,
            ';': space,
            ':': space,
            '?': space,
            '<': space,
            '>': space,
            '№': space
        };

        var result = '';
        var curent_sim = '';

        for (i = 0; i < text.length; i++) {
            // Если символ найден в массиве то меняем его
            if (transl[text[i]] != undefined) {
                if (curent_sim != transl[text[i]] || curent_sim != space) {
                    result += transl[text[i]];
                    curent_sim = transl[text[i]];
                }
            }
            // Если нет, то оставляем так как есть
            else {
                result += text[i];
                curent_sim = text[i];
            }
        }

        result = TrimStr(result);

        // Выводим результат
        $('#alias').val(result);

    }

    function TrimStr(s) {
        s = s.replace(/^-/, '');
        return s.replace(/-$/, '');
    }

    // Выполняем транслитерацию при вводе текста в поле

    $('#name').blur(function () {
        translit();
        return false;
    });

    //chosen

    $('select#video-select').slimSelect();

    $('#add-social').click(function () {
        var name = $('#social-links').data('name');
        $(this).before('<div class="form-cell"><input type="text" name="' + name + '" class="social-link" placeholder="Скопируйте сюда ссылку на свой профиль"><div class="fal fa-times remove-social-link"></div></div>');
    });

    var x = 0;
    $('#add-social-with-text').click(function () {
        $(this).before('<div class="form-cell"><input type="text" name="social[' + x + '][link]" class="social-link inline" placeholder="Скопируйте сюда ссылку"><input type="text" placeholder="Текст ссылки (необязателен)" name="social[' + x + '][text]" class="inline"><div class="fal fa-times remove-social-link"></div></div>');
        x++;
    });

    $('#social-links').on('click', '.remove-social-link', function () {
        $(this).parent().remove();
    });

    $('.social a').each(function (i, e) {
        var href = $(e).attr('href');
        href = href.replace(/(https?:\/\/)?(.+)/, '$2');
        if (href.indexOf('vk.com') !== -1) {
            $(e).parent().find('i').addClass('fab fa-vk');
        } else if (href.indexOf('steamcommunity.com') !== -1) {
            $(e).parent().find('i').addClass('fab fa-steam');
        } else if (href.indexOf('facebook.com') !== -1) {
            $(e).parent().find('i').addClass('fab fa-facebook-square');
        } else if (href.indexOf('youtube.com') !== -1) {
            $(e).parent().find('i').addClass('fab fa-youtube');
        } else if (href.indexOf('instagram.com') !== -1) {
            $(e).parent().find('i').addClass('fab fa-instagram');
        } else if (href.indexOf('twitter.com') !== -1) {
            $(e).parent().find('i').addClass('fab fa-twitter');
        } else if (href.indexOf('ok.ru') !== -1) {
            $(e).parent().find('i').addClass('fab fa-odnoklassniki');
        } else if (href.indexOf('plus.google.com') !== -1) {
            $(e).parent().find('i').addClass('fab fa-google-plus');
        } else if (/^t\.me/.test(href) || /^telegram\.me/.test(href)) {
            $(e).parent().find('i').addClass('fab fa-telegram-plane');
        } else {
            $(e).parent().find('i').addClass('fas fa-external-link');
        }
    });

    autosize($('textarea.custom-textarea'));

    var canClickMessage = true;
    $('.comments-block').on('click', '.comment-hidden-action a', function () {
        $(this).parent().parent().find('.comment-hidden').show();
        $(this).parent().remove();
    }).on('click', '.message-viewed', function () {
        if (canClickMessage) {
            canClickMessage = false;
            var id = $(this).parent().data('id');
            var type = $(this).parent().data('type');
            var $elem = $(this);
            $.ajax({
                url: '/profile/messages/' + type + '/' + id + '/viewed',
                type: 'POST',
                dataType: 'json',
                success: function (data) {
                    if (data.Result == 'success') {
                        $elem.parents('.comment-wrapper').removeClass('not-viewed');
                        $elem.remove();
                        var num = parseInt($('.messages-number:first').data('num')) - 1;
                        if (num < 1) {
                            $('.messages-number').remove();
                        } else {
                            $('.messages-number').data('num', num).text(num > 99 ? '99+' : num);
                        }
                        showNotice('Сообщение помечено просмотренным');
                    } else {
                        showNotice('Произошла какая-то ошибка');
                    }
                    canClickMessage = true;
                }
            });
        }

    }).on('click', '.message-remove', function () {
        if ($(document).width() > 580 || confirm('Вы уверены что хотите удалить это сообщение?')) {
            var id = $(this).parent().data('id');
            var type = $(this).parent().data('type');
            var $elem = $(this);
            var not_viewed = $elem.parents('.comment-wrapper').hasClass('not-viewed');
            $.ajax({
                url: '/profile/messages/' + type + '/' + id + '/delete',
                type: 'POST',
                dataType: 'json',
                success: function (data) {
                    if (data) {
                        showNotice('Сообщение было удалено');
                        $elem.parents('.comment-wrapper').remove();
                        if (not_viewed) {
                            var num = parseInt($('.messages-number:first').data('num')) - 1;
                            if (num < 1) {
                                $('.messages-number').remove();
                            } else {
                                $('.messages-number').data('num', num).text(num > 99 ? '99+' : num);
                            }
                        }
                    } else {
                        showNotice('Произошла какая-то ошибка');
                    }
                }
            });
        }
    }).on('click', '.new-message', function () {
        $(this).parents('.comment-wrapper').find('.leave-comment').show().find('textarea').focus();
    }).on('click', '.send-message-button', function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var user_id = that.parents('.comment-wrapper').find('.comment').data('id');
            var message = encodeURIComponent($.trim(that.parents('.leave-comment').find('textarea').val()));
            var quote = that.parents('.leave-comment').find('input[type="checkbox"]').val();
            var message_id = that.parents('.leave-comment').data('id');
            var data = 'user_id=' + user_id
                + '&message=' + message
                + '&quote=' + quote
                + '&message_id=' + message_id;
            grecaptcha.ready(function () {
                grecaptcha.execute(recaptchaSiteKey, {action: 'send_message'}).then(function (token) {
                    if (token) {
                        data += '&g-recaptcha-response=' + token;
                    }
                    $.ajax({
                        url: '/profile/messages/send-message',
                        type: 'POST',
                        data: data,
                        success: function (data) {
                            if (data.status == 1) {
                                that.parents('.comment-wrapper').find('.message-viewed').trigger('click');
                                that.parents('.leave-comment').fadeOut().find('textarea').val('');
                                showNotice(data.message);
                            } else {
                                showNotice(data.message, 'Ошибка', 'error');
                            }
                        },
                        error: function (request, status, error) {
                            showNotice('Произошла ошибка, попробуйте позже', 'Ошибка', 'error');
                        },
                        complete: function () {
                            that.removeClass('blocked');
                        }
                    });
                });
            });
        }

    });

    $('.send-message-popup').click(function () {
        var that = $(this);

        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var user_id = ~~window.location.pathname.substr(9);
            var message = that.parents('.modal-content').find('textarea').val().trim();

            if (message.length > 0) {
                var data = {
                    user_id: user_id,
                    message: message
                };
                grecaptcha.ready(function () {
                    grecaptcha.execute(recaptchaSiteKey, {action: 'send_message'}).then(function (token) {
                        if (token) {
                            data['g-recaptcha-response'] = token;
                        }
                        $.ajax({
                            url: '/profile/messages/send-message',
                            type: 'POST',
                            data: data,
                            success: function (data) {
                                if (data.status == 1) {
                                    showNotice('Ваше сообщение отправлено');
                                    $('#message-win').modal('destroy');
                                } else {
                                    showNotice(data.message);
                                }
                            },
                            error: function (request, status, error) {
                                showNotice('Произошла ошибка, попробуйте позже', 'Ошибка', 'error');
                            },
                            complete: function () {
                                that.removeClass('blocked');
                            }
                        });
                    });
                });
            } else {
                that.removeClass('blocked');
            }
        }

    });

    $('#viewed_all_messages').click(function () {
        $.ajax({
            type: 'post',
            url: '/profile/messages/inbox/viewed-all',
            success: function (data) {
                if (data.status == 1) {
                    $('.message-viewed').remove();
                    $('.comment-wrapper').removeClass('not-viewed');
                    $('.messages-number').remove();
                }
                showNotice(data.message);
            }
        });
    });

    $('#delete_all_messages').click(function () {
        if (confirm('Вы действительно хотите удалить все сообщения? Это действие нельзя будет отменить.')) {
            var type = $(this).data('type');
            $.ajax({
                type: 'post',
                url: '/profile/messages/' + type + '/delete-all',
                success: function (data) {
                    if (data.status == 1) {
                        $('.comments-block').html('Еще нет никаких сообщений');
                        $('.load-more-messages').remove();
                        $('.messages-number').remove();
                    }
                    showNotice(data.message);
                }
            });
        }
    });

    $('.chat-page #rules > .far').click(function () {
        $(this).parent().find('.chatt-rules').slideToggle();
    });

    $('.chat-block #rules > .far').click(function () {
        if ($('body').width() > 1024) {
            $(this).parent().find('.chatt-rules').toggleClass('open');
        } else {
            $(this).parent().find('.chatt-rules').slideToggle();
        }
    });

    $('#action_expand').click(function () {
        var chatBlock = $('.chat-block > div');
        if (chatBlock.length > 0) {
            if ($('#chatt-wrapper').toggleClass('expand-chat').hasClass('expand-chat')) {
                $(this).find('.far').removeClass('fa-expand-alt').addClass('fa-compress-alt');
                chatBlock.css('width', $('body').width() - chatBlock.offset().left);
            } else {
                $(this).find('.far').removeClass('fa-compress-alt').addClass('fa-expand-alt');
                chatBlock.css('width', '');
            }
        }
    });

    $('button.main-button.smiles').click(function () {
        $('div.smiles-wrapper').slideToggle();
    });

    $('.chat-header').click(function () {
        if ($('.chat-body').slideToggle().toggleClass('open').hasClass('open')) {
            var chat = $('#chatt-wrapper');
            if (chat.hasClass('expand-chat')) {
                chat.children(':eq(0)').css('width', $('body').width() - chat.offset().left);
            }
        } else {
            $('#chatt-wrapper > div').css('width', '');
        }
    });

    $('.close-icon').click(function () {
        $('.sidebar-block.fixed').remove();
    });

    function cookieFromCheckbox() {
        var ch = [];
        $("input:checkbox").each(function () {
            var $el = $(this);
            if ($el.prop("checked"))
                ch.push($el.attr("id"));
        });

        $.cookie("checkboxCookie", ch.join(','));
    }

    function checkboxFromCookie() {
        if ($.cookie("checkboxCookie") == null)
            return;
        var chMap = $.cookie("checkboxCookie").split(',');

        for (var i in chMap)
            $('#' + chMap[i]).prop("checked", true);
        if (chMap == 'chat-sound') {
            $('.chat-sound').removeClass('fa-bell-slash').addClass('fa-bell');
        } else {
            $('.chat-sound').removeClass('fa-bell').addClass('fa-bell-slash');
        }
    }

    checkboxFromCookie();

    $("#chat-sound").change(function () {
        if ($(this).prop('checked')) {
            $('.chat-sound').removeClass('fa-bell-slash').addClass('fa-bell');
        } else {
            $('.chat-sound').removeClass('fa-bell').addClass('fa-bell-slash');
        }
        cookieFromCheckbox();
    });

    $('.remove-black-list').click(function () {
        var that = $(this);
        var id = that.parents('.user-block').data('id');

        $.ajax({
            type: 'post',
            url: '/profile/messages/remove-black-list',
            data: 'id=' + id,
            success: function (data) {
                if (data.status == 1) {
                    that.parents('.user-block').remove();
                }
                showNotice(data.message);
            }
        });
    });

    $('.add-black-list').click(function () {
    });

    $('#add-black-list').click(function () {
        var user_id = $('#user_id').val();
        var data = 'user_id=' + parseInt(user_id);
        $.ajax({
            type: 'post',
            url: '/profile/add-to-black-list',
            data: data,
            success: function (data) {
                if (data.status == 1) {
                    $('.profile-buttons').hide();
                    $('.profile-buttons').before('<div class="pop-message">Вы не можете писать пользователю из черного списка</div>');
                }
                showNotice(data.message);
            }
        });
    });

    $('.accordion-item').click(function () {
        $(this).parent().children('.accordion-content').toggle();
    });

    $('#comment-alert').click(function () {
        $('.comment-overlay').remove();
        $('.leave-comment-body').removeClass('blur')
    });

    $.each($('.comment-date, .notif-date'), function () {
        var time = $(this).text();
        $(this).attr('title', convertTimeFull(time)).text(convertTime(time));
    });

    $('.remove-ban-list').click(function () {
        var that = $(this);
        var id = that.data('id');
        $.ajax({
            type: 'post',
            url: '/remove-ban-list',
            data: 'id=' + id,
            success: function (data) {
                showNotice(data.message);
                if (data.status) {
                    that.parents('tr').remove();
                }
            }
        })
    });

    $('select[name="why"]').change(function () {
        var id = $(this).data('id');
        var why = $(this).val();
        $.ajax({
            type: 'post',
            url: '/edit-ban-list',
            data: 'why=' + why + '&id=' + id,
            success: function (data) {
                showNotice(data.message);
            }
        });
    });

    $('.rules-link').click(function () {
        $('.rules-block').toggleClass('show');
    });

    var menu = $('header.header');
    var live_search = $('.search-block-wrapper:eq(1)').find('.live-search-wrapper');

    function scroll() {
        if ($(window).scrollTop() >= 250) {
            if (!menu.hasClass('fixed')) {
                menu.addClass('fixed').delay(10).queue(function () {
                    $(this).addClass('show').dequeue();
                });
                live_search.hide();
            }
        } else if (menu.hasClass('fixed')) {
            menu.removeClass('fixed').removeClass('show');
            live_search.show();
        }
    }

    document.onscroll = scroll;

    // $('.activate-premium').click(function () {
    //     var that = $(this);
    //     var data = 'id=' + that.data('id');
    //     $.ajax({
    //         type: 'post',
    //         url: '/profile/activate-premium',
    //         data: data,
    //         success: function (data) {
    //             if (data.success == 1) {
    //                 that.remove();
    //             }
    //             showNotice(data.message);
    //         }
    //     });
    // });

    $('.tips-header').click(function () {
        $('.tips-content').toggleClass('open');
        $(this).toggleClass('active');
    });

    //clear profile search
    $('.profile-filter-search-clear').click(function () {
        var that = $(this);
        that.hide();
        filterList(that.next().val(''));
    });

    //list-filter-button
    $('.profile-filter-button').click(function () {
        $('.profile-filter-body').toggleClass('show');
    });

    $('.profile-search').keyup(function () {
        var that = $(this);
        if (that.val().length > 0) {
            that.prev().show();
        } else {
            that.prev().hide();
        }
        filterList(that);
    });

    $('.profile-type').change(function () {
        filterList($(this));
    });

    $('.profile-categories').change(function () {
        filterList($(this));
    });

    function filterList(that) {
        that = that.parents('.tab-content');
        var search = $.trim(that.find('.profile-search').val()).toLowerCase();
        var type = that.find('.profile-type').val();
        var category = that.find('.profile-categories').val();
        var ul = that.find('.update-list');
        ul.find('li').hide();
        var selector = 'li';
        if (type > 0) {
            selector += '[data-typeid=' + type + ']';
        }
        if (category > 0) {
            selector += '[data-categoryid*=";' + category + ';"]';
        }
        var result = ul.find(selector);
        if (search !== '') {
            result = result.filter(function () {
                return $(this).text().toLowerCase().indexOf(search) > -1;
            })
        }
        result.show();
        if (result.length === 0) {
            if (ul.find('.filter-body').length === 0) {
                ul.append('<div class="filter-body" style="text-align: center; padding: 20px 15px">По заданным фильтрам нет результатов</div>')
            }
        } else {
            ul.find('.filter-body').remove()
        }
    }

    $('.profile-sort').change(function () {
        var sortId = ~~$(this).val();
        var ul = $(this).parents('.tab-content').find('.update-list');
        var collator = new Intl.Collator();
        switch (sortId) {
            case 1:
                $(ul.find('li'), ul).sort(function (a, b) {
                    return collator.compare($(a).text(), $(b).text());
                }).appendTo(ul);
                break;
            case 2:
                $(ul.find('li'), ul).sort(function (a, b) {
                    return collator.compare($(b).text(), $(a).text());
                }).appendTo(ul);
                break;
            case 3:
                $(ul.find('li'), ul).sort(function (a, b) {
                    return collator.compare($(b).data('createdat'), $(a).data('createdat'));
                }).appendTo(ul);
                break;
            case 4:
                $(ul.find('li'), ul).sort(function (a, b) {
                    if (+$(a).find('.title-rating').text() > +$(b).find('.title-rating').text()) return -1;
                    if (+$(a).find('.title-rating').text() < +$(b).find('.title-rating').text()) return 1;
                    return 0;
                }).appendTo(ul);
                break;
            case 5:
                $(ul.find('li'), ul).sort(function (a, b) {
                    if (~~$(a).find('.user-rating').text() > ~~$(b).find('.user-rating').text()) return -1;
                    if (~~$(a).find('.user-rating').text() < ~~$(b).find('.user-rating').text()) return 1;
                    return 0;
                }).appendTo(ul);
                break;
            default:
                break;
        }
    });

    $('#inner-lists .tabs > li').click(function () {
        var that = $(this);
        var id = that.data('listid');
        getList(id, that);
        $('select.slim-select').each(function () {
            var that = $(this);
            that.slimSet(that.data('default') || 0);
        });
        $('.profile-filter-search-clear').trigger('click');
    });

    function getList(id, that) {
        var list = $('.tab-content' + that.data('id')).find('.update-list')
            .html('<div class="filter-body" style="text-align: center; padding: 20px 15px"><i class="loading large"></i></div>');
        $.ajax({
            url: '/profile/get-list',
            type: 'get',
            data: 'list_id=' + id,
            success: function (data) {
                if (data) {
                    list.html('');
                    $.each(data, function (i, e) {
                        var html = '<li class="profile-list" data-typeid="' + e.type_id + '" data-categoryid=";' + e.categories + ';" data-createdat="' + e.time + '">';
                        html += '<a href="/catalog/item/' + e.alias + '">';
                        html += '<img src="' + e.image + '" class="update-img" loading="lazy">';
                        html += '<div class="update-list-block"><div class="update-list-flex">';
                        if (typeof e.ongoing != 'undefined') {
                            if (e.ongoing == 1) {
                                html += '<span class="dote review" title="Статус: онгоинг"></span>';
                            } else if (e.ongoing == 2) {
                                html += '<span class="dote attention" title="Статус: анонс"></span>';
                            } else if (e.ongoing == 3) {
                                html += '<span class="dote review" title="Статус: в прокате"></span>';
                            } else {
                                html += '<span class="dote" title="Статус: вышел"></span>';
                            }
                        }
                        html += ' <span class="update-title">' + e.name + '</span>';
                        html += '<div class="rating-container">';
                        if (e.rating != undefined) {
                            html += '<span title="Рейтинг аниме" class="title-rating">';
                            html += '<i class="fa fa-star"></i>' + e.rating.toFixed(2);
                            html += '</span>';
                        }
                        if (e.user_rating != undefined) {
                            html += '<span title="Мой рейтинг" data-id="' + e.anime_id + '" class="user-rating ';
                            if (e.user_rating < 6) {
                                html += 'bad-rating'
                            }
                            html += '"><i class="fa fa-star"></i> ' + e.user_rating + '</span>';
                        }
                        html += '</div></div>';
                        html += '</div>';
                        html += '</a>';
                        html += '<div class="list-buttons">';
                        html += '<div class="list-buttons-control list-button fa fa-cog"></div>';
                        html += '<div class="list-buttons-list">';

                        if (e.list_id === 1) {
                            html += '<button data-id="' + e.anime_id + '" title="Буду смотреть" class="list-will-watch list-button far fa-list"></button>';
                            if (e.ongoing !== 1 && e.ongoing !== 2) {
                                html += '<button data-id="' + e.anime_id + '" title="Просмотрено" class="list-watched list-button far fa-check"></button>';
                            }
                            html += '<button data-id="' + e.anime_id + '" title="Брошено" class="list-lost list-button far fa-eye-slash"></button>';
                            html += '<button data-id="' + e.anime_id + '" title="Удалить из списка" class="list-remove list-button far fa-trash-alt"></button>';
                        } else if (e.list_id === 2) {
                            if (e.ongoing !== 2)
                                html += '<button data-id="' + e.anime_id + '" title="Смотрю" class="list-watch-now far fa-eye"></button>';
                            if (e.ongoing !== 1 && e.ongoing !== 2)
                                html += '<button data-id="' + e.anime_id + '" title="Просмотрено" class="list-watched list-button far fa-check"></button>';
                            html += '<button data-id="' + e.anime_id + '" title="Удалить из списка" class="list-remove far fa-trash-alt"></button>';
                        } else if (e.list_id === 3) {
                            html += '<button data-id="' + e.anime_id + '" title="Любимое" class="addtofavourite far fa-heart' + ($('#favourite button[data-id=' + e.anime_id + ']').length > 0 ? ' active' : '') + '"></button>';
                            html += '<button data-id="' + e.anime_id + '" title="Удалить из списка" class="list-remove far fa-trash-alt"></button>';
                        } else if (e.list_id === 4) {
                            html += '<button data-id="' + e.anime_id + '" title="Удалить из списка" class="list-remove far fa-trash-alt"></button>';
                        } else if (e.list_id === 5) {
                            html += '<button data-id="' + e.anime_id + '" title="Смотрю" class="list-watch-now far fa-eye"></button>';
                            html += '<button data-id="' + e.anime_id + '" title="Удалить из списка" class="list-remove far fa-trash-alt"></button>';
                        }

                        html += '</div>';
                        html += '</div>';
                        html += '</li>';
                        list.append(html);
                    });
                    if (!data.length) {
                        list.append('<div class="filter-body" style="text-align: center; padding: 20px 15px">Данный список пуст</div>');
                    }
                    $('.tab-content.active').find('.profile-sort').trigger('change');
                    that.find('.count').html(data.length);
                    profileListDate();
                }
            }
        });
    }

    $('#remote-lists .tabs > li').click(function () {
        var that = $(this);
        var user_id = $('#user_id').val();
        var list_id = that.data('listid');
        if (!that.hasClass('loaded')) {
            that.addClass('loaded');
            getRemoteList(user_id, list_id, that);
        }
        $('select.slim-select').each(function () {
            var that = $(this);
            that.slimSet(that.data('default') || 0);
        });
        $('.profile-filter-search-clear').trigger('click');
    });

    function getRemoteList(user_id, list_id, that) {
        var list = $('.tab-content' + that.data('id')).find('.update-list')
            .html('<div class="filter-body" style="text-align: center; padding: 20px 15px"><i class="loading large"></i></div>');
        $.ajax({
            url: '/users/get-remote-list',
            type: 'get',
            data: 'user_id=' + user_id + '&list_id=' + list_id,
            success: function (data) {
                list.html('');
                $.each(data, function (i, e) {
                    var html = '<li class="profile-list" data-typeid="' + e.type_id + '" data-categoryid=";' + e.categories + ';" data-createdat="' + e.time + '">';
                    html += '<a href="/catalog/item/' + e.alias + '">';
                    html += '<img src="' + e.image + '" class="update-img" loading="lazy">';
                    html += '<div class="update-list-block"><div class="update-list-flex">';
                    if (typeof e.ongoing != 'undefined') {
                        if (e.ongoing == 1) {
                            html += '<span class="dote review" title="Статус: онгоинг"></span>';
                        } else if (e.ongoing == 2) {
                            html += '<span class="dote attention" title="Статус: анонс"></span>';
                        } else if (e.ongoing == 3) {
                            html += '<span class="dote review" title="Статус: в прокате"></span>';
                        } else {
                            html += '<span class="dote" title="Статус: вышел"></span>';
                        }
                    }
                    html += ' <span class="update-title">' + e.name + '</span>';
                    html += '<div class="rating-container">';
                    if (e.rating != undefined) {
                        html += '<span title="Рейтинг аниме" class="title-rating">';
                        html += '<i class="fa fa-star"></i>' + e.rating.toFixed(2);
                        html += '</span>';
                    }
                    if (e.user_rating != undefined) {
                        html += '<span title="Оценка пользователя" data-id="' + e.anime_id + '" class="user-rating ';
                        if (e.user_rating < 6) {
                            html += 'bad-rating'
                        }
                        html += '"><i class="fa fa-star"></i> ' + e.user_rating + '</span>';
                    }
                    html += '</div></div>';
                    html += '</div>';
                    html += '</a>';
                    html += '</li>';
                    list.append(html);
                });
                if (!data.length) {
                    list.append('<div class="filter-body" style="text-align: center; padding: 20px 15px">Данный список пуст</div>');
                }
                that.find('.count').html(data.length);
                profileListDate();
            }
        });
    }

    $('.drop-list-buttons').click(function () {
        $(this).find('.drop-list').toggleClass('open');
    });

    $('.drop-list .to-list').each(function () {
        if ($(this).hasClass('active')) {
            $('.drop-menu-click').addClass('active');
        }
    });

    $('.subscribe-video-button').click(function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var data = 'author_id=' + that.data('author') + '&type_id=' + that.data('type');
            $.ajax({
                type: 'post',
                data: data,
                url: '/profile/subscriptions',
                success: function (data) {
                    showNotice(data.message);
                    var count = $('.subscribe-count-number').text();
                    if (data.status == 'subscribed') {
                        that.addClass('subscribed').text('Я подписан');
                        $('.subscribe-count-number').text(++count);
                    } else if (data.status == 'unsubscribed') {
                        that.removeClass('subscribed').text('Подписаться');
                        $('.subscribe-count-number').text(--count);
                        that.parents('.user-block').remove()
                    }
                    that.removeClass('blocked');
                }
            });
        }

    });

    $('.remove-poster').click(function () {
        $('.poster-block').hide();
        $('input[name="remove_poster"]').val(1);
    });

    $('.preview-block .categories-list > ul').each(function () {
        var that = $(this);
        if (that.children().length > 5) {
            that.children(':eq(5)').before('<span class="more-alt-names">Ещё...</span>')
        }
    });

    $(document).on('click', '.more-alt-names', function () {
        $(this).remove();
    }).on('click', '.filter-button', function () {
        var that = $(this);
        if (!that.parent().hasClass('blocked')) {
            that.parent().addClass('blocked');
            if (that.hasClass('random')) {
                var data = 'action=random';
                that.parents('form.filter-block').serializeArray().forEach(function (e) {
                    if (e.value) {
                        data += '&' + e.name + '=' + e.value;
                    }
                });
                $.ajax({
                    url: '/filter',
                    type: 'GET',
                    dataType: 'json',
                    data: data,
                    success: function (data) {
                        if (data.status) {
                            window.location = data.link;
                        } else {
                            showNotice(data.message, 'Ошибка', 'error');
                        }
                    },
                    error: function (request, status, error) {
                        that.addClass('error');
                        showNotice(request.responseJSON.message, 'Ошибка', 'error');
                    }
                });

            } else if (that.hasClass('clear')) {
                var parent = that.parents('form.filter-block');
                parent.find('[name="date_range"]').data('dateRangePicker').clear();
                parent.find('select').slimSet(0);
                parent.find('input[type=checkbox]').prop('checked', false);
                that.parent().removeClass('blocked');
            } else {
                that.parents('form.filter-block').submit();
            }
        }
    }).on('click', '.more-text', function (e) {
        e.preventDefault();
        var that = $(this);
        var text = that.parent().find('.hide-text, .comment-text.hidden').removeClass('hide-text hidden');
        that.remove();
        commentResize(text)
    }).on('click', '.drop-menu-click', function (e) {
        var that = $(this);
        var hidden = that.parent().find('.drop-list');
        if (that.offset().left < hidden.width()) {
            hidden.addClass('left');
        } else {
            hidden.removeClass('left');
        }
        hidden.parent().toggleClass('invisible');

        $(document).on('click.hidden-menu', function (event) {
            if (!$(event.target).closest('.drop-menu-click, .hidden-menu').length) {
                $('.hidden-menu').addClass('invisible');
                $(document).off('click.hidden-menu');
            }
        });
    }).on('click', '.drop-menu-item', function (e) {
        $(this).parents('.hidden-menu').addClass('invisible');
    }).on('keydown', 'div[contenteditable="true"]', function (event) {
        if (window.getSelection && event.which == 8) {
            var selection = window.getSelection();
            if (!selection.isCollapsed || !selection.rangeCount) {
                return;
            }
            var curRange = selection.getRangeAt(selection.rangeCount - 1);
            if (curRange.commonAncestorContainer.nodeType == 3 && curRange.startOffset > 0) {
                return;
            }
            var range = document.createRange();
            if (selection.anchorNode != this) {
                range.selectNodeContents(this);
                range.setEndBefore(selection.anchorNode);
            } else if (selection.anchorOffset > 0) {
                range.setEnd(this, selection.anchorOffset);
            } else {
                return;
            }
            range.setStart(this, range.endOffset - 1);

            var previousNode = range.cloneContents().lastChild;
            if (previousNode && previousNode.contentEditable == 'false') {
                range.deleteContents();
                event.preventDefault();
            }
        }
    });

    profileListDate();

    $('#check-email').blur(function () {
        var text = $(this).val();
        $(this).val(text.replace('qmail.com', 'gmail.com')
            .replace('@mail.com', '@gmail.com')
            .replace('@gmail.cjm', '@gmail.com')
            .replace('@gmeil.com', '@gmail.com')
            .replace('@gmail.ccom', '@gmail.com')
            .replace('@gmail.cow', '@gmail.com')
            .replace('@gmail.ru', '@gmail.com')
            .replace('@gmail.om', '@gmail.com')
            .replace('@gamil.com', '@gmail.com')
            .replace('@gmmail.com', '@gmail.com')
            .replace('@ggmail.com', '@gmail.com')
            .replace('@gmail.c0m', '@gmail.com')
            .replace('@gnail.com', '@gmail.com')
            .replace('@googl.ru', '@gmail.com')
            .replace('@mail.rj', '@mail.ru')
            .replace('@mail.ry', '@mail.ru')
            .replace('@maill.ru', '@mail.ru')
            .replace('@mail.u', '@mail.ru')
            .replace('@mal.ru', '@mail.ru')
            .replace('@mai.ru', '@mail.ru')
            .replace('@mail.tu', '@mail.ru')
            .replace('@2mail.ru', '@mail.ru')
            .replace('@mil.ru', '@mail.ru')
            .replace('@dk.ru', '@bk.ru')
            .replace('@lisr.ru', '@list.ru')
            .replace('@ukr.ent', '@ukr.net')
            .replace('@gmail.con', '@gmail.com')
            .replace('@gmail.ry', '@gmail.com')
            .replace('@gmail.come', '@gmail.com')
            .replace('@gmail.comm', '@gmail.com')
            .replace('@gmail.cpm', '@gmail.com')
            .replace('@gmail.c0m', '@gmail.com')
            .replace('@gmail.comr', '@gmail.com')
            .replace('@yandex.ry', '@yandex.ru')
            .replace('@yandex.ok', '@yandex.ru')
            .replace('@online.ue', '@online.ua')
            .replace('@mail.rua', '@mail.ru')
            .replace('@gmail.cjv', '@gmail.com')
            .replace('@gmail.coom', '@gmail.com')
            .replace('@gmal.com', '@gmail.com')
            .replace('@gmale.com', '@gmail.com')
            .replace('@bk.r', '@bk.ru')
            .replace('@bk.ruu', '@bk.ru')
            .replace('@bk.ruuu', '@bk.ru')
            .replace('@mail.ruv', '@mail.ru')
            .replace('@gmail.vom', '@gmail.com')
            .replace('@gmial.com', '@gmail.com')
            .replace('@gmoil.com', '@gmail.com')
            .replace('@yandex.r', '@yandex.ru')
            .replace('@yandex.ri', '@yandex.ru')
            .replace('@yandex.ruu', '@yandex.ru')
            .replace('@gmail.ri', '@gmail.com')
            .replace('@gmail.com7', '@gmail.com')
            .replace('@ukr.ner', '@ukr.net')
            .replace('@gmail.cim', '@gmail.com')
            .replace('@inbox.tu', 'inbox.ru')
        );
    });

    $('#open-report-modal').modal();
    $('.rating-star').modal(function (e, m) {
        var title = e.parents('.rating-info').attr('title');
        if (title.length < 1) {
            title = $('h1').text();
        }
        m.find('.modal-header').text(title).attr('data-id', e.data('id'))
    });

    $('.subscribe-anime-block').click(function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var data = 'block_id=' + that.data('id');
            $.ajax({
                type: 'post',
                url: '/profile/subscribe-anime-block',
                data: data,
                success: function (data) {
                    if (data.action === 1) {
                        that.addClass('active');
                    } else if (data.action === 2) {
                        that.removeClass('active');
                    }
                    showNotice(data.message, data.status, data.class);
                    that.removeClass('blocked');
                }
            });
        }
    });

    $('.subscribe-anime-block-select').click(function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var block_id = that.parent().find('option:selected').val();
            $.ajax({
                type: 'post',
                url: '/profile/subscribe-anime-block',
                data: 'block_id=' + block_id,
                success: function (res) {
                    if (res.action == 1) {
                        that.addClass('active');
                        $('.subscribe-anime-block[data-id="' + block_id + '"]').addClass('active');
                    } else if (res.action == 2) {
                        that.removeClass('active');
                        $('.subscribe-anime-block[data-id="' + block_id + '"]').removeClass('active');
                    }
                    showNotice(res.message, res.status, res.class);
                    that.removeClass('blocked');
                }
            });
        }
    });

    // var selectedVideoBlock = $('#video-select').val();
    // if (!$('.block-episodes').hasClass('show')) {
    //     $('.block-episodes').hide();
    // }

    // $('.block-episodes[data-id=' + selectedVideoBlock + ']').addClass('show');

    // $('#video-select').change(function () {
    //
    //     var btn = $('.block-episodes[data-id=' + $(this).val() + '] .video-button');
    //     if ($('.block-episodes[data-id=' + $(this).val() + ']').hasClass('subscribed')) {
    //         if (!$('.subscribe-anime-block').hasClass('active')) {
    //             $('.subscribe-anime-block').addClass('active');
    //         }
    //     } else {
    //         $('.subscribe-anime-block').removeClass('active');
    //     }
    //
    //     if (btn.length === 1 && $('.content-main-info li[data-animeType="2"]').length > 0) {
    //         btn.trigger('click').hide();
    //     } else {
    //         $('.episodes-container').addClass('hidden');
    //         $('.episodes-container[data-id=' + $(this).val() + ']').removeClass('hidden');
    //     }
    //
    // });

    $('#dub-select').change(function () {
        var id = $(this).find(":selected").val();
        var select = $('#player-select');
        select.find('[data-dub]').css('display', 'none');
        select = select.find('[data-dub=' + id + ']').css('display', 'flex');
        selectEpisodes(select.find('select').val());
    });

    $('#player-select select').change(function () {
        selectEpisodes($(this).val());
    });

    //Authorized user
    if ($('#page_id').val()) {
        if ($('#user_id_chat').length > 0) {
            getAnimeFromAjax();
        } else {
            getAnimeFromCookie();
        }
    }

    $('.video-wrapper .video-button').click(function () {
        var that = $(this);
        if (saveEpisode) {
            var block = that.parents('.block-episodes').data('id');
            that.parents('.block-episodes').find('.video-button').removeClass('active')
                .parents('.episodes-container').find('.main-player iframe').attr('src', that.data('href'))
                .parents('.player').removeClass('hidden');
            that.addClass('active');

            saveEpisode(block, that.data('id'));
        }
    });

    function getAnimeFromAjax() {
        $.ajax({
            type: 'post',
            url: '/get-pressed-episodes',
            data: 'anime_id=' + $('#page_id').val(),
            success: function (data) {
                if (data.status) {
                    for (var j = 0; j < data.subscribed.length; j++) {
                        $('.subscribe-anime-block[data-id="' + data.subscribed[j] + '"]').addClass('active');
                    }
                    if (data.pressedButtons.length > 0) {
                        $.each(data.pressedButtons, function (i, e) {
                            var button = $('.block-episodes[data-id="' + e.block_id + '"] .video-button[data-id="' + e.episode_id + '"]').addClass('active');
                            if (i === 0) {
                                lastEp = button;
                            }
                        });
                        selectEpisodes(data.pressedButtons[0].block_id);
                    } else {
                        getAnimeFromCookie();
                    }
                    if ($('.video_select').length > 0) {
                        var players = $('#player-select');
                        for (var j = 0; j < data.subscribed.length; j++) {
                            players.find('select option[value=' + data.subscribed[j] + ']').each(function (i, e) {
                                $('.subscribe-anime-block-select[data-id="' + $(e).data('name') + '"]').addClass('active');
                            });
                        }
                        if (data.pressedButtons.length > 0) {
                            var select = players.find('select [value="' + data.pressedButtons[0].block_id + '"]').parents('select');
                            select.slimSet(data.pressedButtons[0].block_id);
                            $('#dub-select').slimSet(select.parent().data('dub'));
                        }
                    }
                }
            },
            complete: function () {
                saveEpisode = function (block_id, episode_id) {
                    var button = $('.video-block[data-block=' + block_id + '] .video-button[data-id=' + episode_id + ']');
                    if (!button.is(lastEp)) {
                        lastEp = button;
                        var anime_id = $('#page_id').val();
                        $.ajax({
                            type: 'post',
                            url: '/profile/save-episode',
                            data: 'episode_id=' + episode_id + '&block_id=' + block_id + '&anime_id=' + anime_id,
                            success: function (data) {
                                if (!data.status) {
                                    showNotice(data.message, 'Ошибка', 'error')
                                }
                            }
                        });
                    }
                }
            }
        });
    }

    function getAnimeFromCookie() {
        var path = window.location.pathname;
        if (path.indexOf('/catalog/item') === -1) {
            return false;
        }
        var cookie = $.cookie(path.substr(14));
        if (cookie !== undefined) {
            cookie = cookie.split('.');
            if ($('.video_updated').length > 0) {
                lastEp = $('.block-episodes[data-id="' + cookie[0] + '"] .video-button[data-id="' + cookie[1] + '"]').addClass('active');
                var players = $('#player-select');
                var select = players.find('select [value="' + cookie[0] + '"]').parents('select');
                select.slimSet(cookie[0]);
            } else {
                $('#video-select').slimSet(cookie[0]);
                $('.block-episodes[data-id="' + cookie[0] + '"] .video-button[data-id="' + cookie[1] + '"]').addClass('active');
                $('.block-episodes[data-id="' + cookie[0] + '"]').parents('.episodes-container').removeClass('hidden');
            }
        }

        saveEpisode = function (block_id, episode_id) {
            var button = $('.video-block[data-block=' + block_id + '] .video-button[data-id=' + episode_id + ']');
            if (!button.is(lastEp)) {
                lastEp = button;
                $.cookie(window.location.pathname.substr(14), block_id + '.' + episode_id, {
                    expires: 20,
                    path: window.location.pathname
                });
            }
        };
    }

    if ($('.video_select').length > 0) {
        if (localStorage.designSwitch === 'false') {
            $('#design-switch > .switch').toggleClass('active');
            $('.video-wrapper').toggleClass('video_select');
        }
    }

    if ($('.filter-block').length > 0) {
        $('.filter-block').removeClass('loading');
    }

    $('.block-episodes').addClass('show');

    $('#player-select').find('[data-dub]:visible select').change();

    $('.sub-menu-container').on('click', '.sub-menu-container-icon', function () {
        $('.sub-menu-inner-container').toggleClass('show');
    });

    $('#design-switch').click(function () {
        $(this).children('.switch').toggleClass('active');
        var isActive = $('.video-wrapper').toggleClass('video_select').hasClass('video_select');
        localStorage.designSwitch = isActive;
        if (isActive) {
            selectEpisodes($('#player-select > div:visible select').val());
        }
    });

    $('.filter-switch').click(function () {
        $('.filter-switch .switch').toggleClass('active');
        var isActive = $('.filter-block').addClass('ready').toggleClass('main').hasClass('main');
        if (!isActive) {
            filterExpand()
        } else {
            $('.filter-block .collapse').each(function () {
                var that = $(this);
                that.css('max-height', that.children().outerHeight())
            }).attr('style', '');
        }
        localStorage.filterSwitch = !isActive
    });

    $('.sort-order-button').click(function () {
        var that = $(this);
        var input = that.find('input');
        if (+input.val()) {
            that.children().attr('data-balloon', 'По убыванию');
            input.val(0)
        } else {
            that.children().attr('data-balloon', 'По возрастанию');
            input.val(1)
        }
    });

    $('.content').on('click', '.main-rating', function () {
        var that = $(this);

        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var votes_list = that.parents('.rating-info').next('.votes-list');
            if (votes_list.length > 0) {
                votes_list.remove();
                that.removeClass('blocked');
            } else {
                var anime_id = that.parents('.rating-info').find('.rating-star').data('id');
                $.ajax({
                    url: '/get-votes-list',
                    type: 'post',
                    data: 'anime_id=' + anime_id,
                    success: function (data) {

                        if (data.status === false) {

                            showNotice(data.message, 'Ошибка', 'error')

                        } else {

                            var max = 0;
                            for (var j = 0; j < data.data.length; j++) {
                                if (data.data[j].count > max) {
                                    max = data.data[j].count;
                                }
                            }
                            var html = '';
                            html += '<div class="stats-container votes-list">';
                            var titles = {
                                10: 'шедевр',
                                9: 'великолепно',
                                8: 'очень хорошо',
                                7: 'хорошо',
                                6: 'неплохо',
                                5: 'посредственно',
                                4: 'никак',
                                3: 'плохо',
                                2: 'ужасно',
                                1: 'ничтожно'
                            };
                            var title;
                            for (var i = 0; i < data.data.length; i++) {
                                if (data.data[i].count > max) {
                                    max = data.data[i].count;
                                }
                                var opacity = data.data[i].count / max;
                                var opacity_val = opacity.toFixed(2) * 0.4 + 0.6;
                                title = titles[data.data[i].rating];
                                html += '<div class="stats-item" title="' + title + '"><div class="stats-item-column"><i class="fa fa-star"></i></div><div class="stats-item-column">' + data.data[i].rating + '</div><div class="stats-item-column progress-bar-column"><div class="progress-bar"><div style="flex-basis: ' + (data.data[i].count * 100 / max) + '%; background: rgba(60, 206, 123,' + opacity_val + ')">' + data.data[i].count + '</div></div></div></div>';
                            }
                            html += '</div>';
                            that.parents('.rating-info').after(html);

                        }

                        that.removeClass('blocked');
                    }
                });

            }
        }

    }).on('click', '.user-rating', function (e) {
        e.preventDefault();
        var that = $(this);
        var anime_id = that.data('id');
        if (anime_id && confirm('Удалить свой рейтинг?')) {
            $.ajax({
                url: '/profile/remove-rating',
                type: 'post',
                data: 'anime_id=' + anime_id,
                success: function (data) {
                    if (data.status) {
                        that.parent().find('.main-rating').text(data.rating).parent().find('.main-rating-info').html(' <span>' + data.votes + '</span> голосов');
                        that.remove();
                    }
                    showNotice(data.message);
                }
            });
        }
    }).on('click', '.other-lists-button', function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {
            that.addClass('blocked');
            var list = that.parent().find('.other-lists');
            if (list.length > 0) {
                list.addClass('invisible');
                setTimeout(function () {
                    list.remove();
                    that.removeClass('blocked');
                }, 200)
            } else {
                var anime_id = $('#page_id').val();
                $.ajax({
                    url: '/get-other-lists',
                    type: 'post',
                    data: 'anime_id=' + anime_id,
                    success: function (data) {
                        if (data.status === false) {
                            showNotice(data.message, 'Ошибка', 'error')
                        } else {

                            var max = 0;
                            for (var j = 0; j < data.data.length; j++) {
                                if (data.data[j].count > max) {
                                    max = data.data[j].count;
                                }
                            }
                            var html = '<div class="stats-container other-lists invisible">';
                            var titles = {
                                1: 'Смотрю',
                                2: 'Буду смотреть',
                                3: 'Просмотрено',
                                4: 'Любимое',
                                5: 'Брошено'
                            };
                            var title;
                            for (var i = 0; i < data.data.length; i++) {
                                if (data.data[i].count > max) {
                                    max = data.data[i].count;
                                }
                                var opacity = data.data[i].count / max;
                                var opacity_val = opacity.toFixed(2) * 0.4 + 0.6;
                                title = titles[data.data[i].list_id];
                                html += '<div class="stats-item"><div class="stats-item-column progress-bar-column"><div class="progress-bar"><div style="flex-basis: ' + (data.data[i].count * 100 / max) + '%; background: rgba(60, 206, 123, ' + opacity_val + ');">' + data.data[i].count + '</div></div></div><div class="stats-item-column">' + title + '</div></div>';
                            }
                            html += '</div>';
                            that.parent().append(html);
                            setTimeout(function () {
                                that.parent().find('.invisible').removeClass('invisible');
                            }, 200)

                            $(document).on("click.otherLists", function (e) {
                                var el = $('.other-lists');
                                if ($(e.target).closest(el).length) return;
                                $(document).off("click.otherLists");
                                el.addClass('invisible');
                                setTimeout(function () {
                                    el.remove();
                                }, 200)

                            });
                        }

                        that.removeClass('blocked');
                    },
                    error: function (request, status, error) {
                        showNotice('Произошла ошибка, попробуйте позже', 'Ошибка', 'error')

                    }
                });

            }
        }

    });

    $('.claim-remove').click(function () {
        var $elem = $(this);
        if (!$elem.hasClass('blocked')) {
            $elem.addClass('blocked');
            var id = $elem.data('id');
            $.ajax({
                url: '/profile/claims/delete',
                type: 'POST',
                data: 'id=' + id,
                success: function (data) {
                    if (data.status) {
                        $elem.parents('li').fadeOut();
                        $elem.removeClass('blocked');
                    }
                    showNotice(data.message);
                }
            });
        }
    });

    var panel = $('.avatar-control-panel');
    var cropper;

    function readFile(input) {
        if (input.files && input.files[0]) {
            var reader = new FileReader();
            var img = $('#avatar').prepend('<img class="new-avatar">').children().first();
            reader.onload = function (e) {
                img.load(function () {
                    cropper = new Cropper(img[0], {
                        aspectRatio: 1,
                        viewMode: 3,
                        dragMode: 'move',
                        autoCropArea: 1,
                        cropBoxResizable: false,
                        cropBoxMovable: false,
                        minCropBoxWidth: 200,
                        minCropBoxHeight: 200,
                        guides: false,
                        center: false
                    });
                    $('.old-avatar').addClass('hidden');
                    panel.children().toggleClass('hidden');
                });
                img.attr('src', e.target.result);
            };
            reader.readAsDataURL(input.files[0]);
        } else {
            showNotice("Перезагрузите страницу и попробуйте снова", 'Ошибка', 'error');
        }
    }

    $('input[name="upload-avatar"]').change(function () {
        readFile(this);
    });

    $('#avatar-ok').click(function () {
        var that = $(this);
        if (!that.hasClass('blocked')) {

            that.addClass('blocked').html('<i class="loading"></i> загрузка');

            cropper.getCroppedCanvas({
                width: 200,
                minWidth: 200,
                imageSmoothingQuality: 'high'
            }).toBlob(function (blob) {
                var apiKey = 'dc5aed81560de23';
                var xhr = new XMLHttpRequest();
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        var data = JSON.parse(xhr.responseText);
                        var old = $('.old-avatar');
                        old.load(function () {
                            $('#avatar-delete').trigger('click');
                        });
                        old.attr('src', data.data.link);
                        $('input[name="avatar"]').attr('value', data.data.link);
                        showNotice('Новый аватар загружен на сервер, сохраните профиль');
                    } else {
                        $('#avatar-delete').trigger('click');
                        showNotice('Произошла ошибка, обратитесь в поддержку сайта', 'Ошибка', 'error');
                    }
                    that.removeClass('blocked').html('<i class="fas fa-thumbs-up"></i> применить');
                };
                xhr.open('post', 'https://api.imgur.com/3/image', false);
                xhr.crossDomain = true;
                xhr.processData = false;
                xhr.contentType = false;
                xhr.mimeType = 'multipart/form-data';
                xhr.setRequestHeader('Authorization', 'Client-ID ' + apiKey);
                xhr.setRequestHeader('Accept', 'application/json');
                xhr.send(blob);
            });

        }
    });

    $('#avatar-delete').click(function () {
        panel.children().toggleClass('hidden');
        cropper.destroy();
        $('.old-avatar').removeClass('hidden');
        $('.new-avatar').remove();
        $('input[name="upload-avatar"]').replaceWith('<input type="file" name="upload-avatar">');
        $('input[name="upload-avatar"]').change(function () {
            readFile(this);
        });
    });

    if ($('#notices-menu').length > 0) {
        $('#notices-menu li a[href="' + location.pathname + location.search + '"]').parent().addClass('active');
    }

    if ($('.comment-wrapper .message').length > 0) {
        $('.comment-wrapper .message').each(function () {
            $(this).find('.comment-text').html(autoLink($(this).find('.comment-text').html()));
            hideBigComment($(this))
        });
    }

    function declOfNum(number, titles) {
        var cases = [2, 0, 1, 1, 1, 2];
        return titles[(number % 100 > 4 && number % 100 < 20) ? 2 : cases[(number % 10 < 5) ? number % 10 : 5]];
    }

    var anime_type_id = $('#anime_type_id').val();

    var isFilm = [2, 3].includes(+anime_type_id);
    var isOneSeria = +$('#anime_num_series').val() === 1;
    if (isOneSeria || isFilm) {
        $('.video-block').each(function (i, e) {
            if ($(e).find('.video-button').length <= 1) {
                $(e).find('.block-episodes').removeClass('show');
                $(e).find('.player iframe').attr('src', $(e).find('.video-button').data('href'));
                $(e).find('.player').removeClass('hidden');
            }
        });
        if ($('.video-block').length <= 1 && $('.video-button').length <= 1) {
            $('#design-switch, .video-block-inner, .video-block-select').hide();
            $('.episodes-container').removeClass('hidden');
        }
    }

    if ($('.video-block-description').length > 0 && !isFilm) {
        $('.video-block-description').each(function (i, e) {
            var num = $(e).parents('.video-block').find('.video-button').length;
            $(e).append(declOfNum(num, [' (' + num + ' эпизод)', ' (' + num + ' эпизода)', ' (' + num + ' эпизодов)']));
        });
    }

    if ($('.animeVoices').length > 0) {
        $('.animeVoices > li').each(function () {
            var that = $(this);
            var cont = $('.content').width();
            var pos = that.find('.dub-body').width() + that.offset().left;
            if (cont < pos) {
                that.find('.dub-body').css('left', cont - pos);
            }
        });

        $('.content').resize(function () {
            var cont = $(this).width();
            $('.dropdown').each(function () {
                var that = $(this);
                var block = that.find('.dropdown-content');
                var pos = block.width() + that.position().left;
                if (cont < pos) {
                    block.css('left', cont - pos);
                }
            });
        });
    }

    if ([4, 5].includes(+$('#anime_age_rating').val())) (function () {
        if ($('#user_age').val() >= 18) return;
        var ageConfirmAnimes = JSON.parse(localStorage.ageConfirmAnimes || "{}");
        var thisConfirm = ageConfirmAnimes[$('#page_id').val()];
        if (!thisConfirm || thisConfirm < Date.now()) {
            if ($('#strong_age_verification').length > 0) {
                $('.main-player').append('<div class="player-alert-container"><div class="player-alert"><h1>18+</h1><p>Подтвердите, что вам уже есть 18 лет. Введите дату рождения:</p><input type="date"><div class="main-button" onclick="playerAgeCheck(this)">Подтвердить</div><span>Укажите возраст в профиле, чтобы не видеть этого окна</span></div></div>')
            } else {
                $('.main-player').append('<div class="player-alert-container"><div class="player-alert"><h1>18+</h1><p>Данный контент только для лиц старше 18-ти лет</p><div class="main-button" onclick="playerAgeConfirm()">Мне уже есть 18</div><span>Укажите возраст в профиле, чтобы не видеть этого окна</span></div></div>')
            }
        }
    })()


    $('.poster-block img').one('load', function () {
        var img = $(this);
        if (img[0].naturalWidth > 245) {
            $('.poster-block').append('<div class="scope-block update-list"><div title="Увеличить" class="poster-increase favourite-button far fa-search-plus"></div></div>');
            $('.poster-background img').attr('src', img[0].src);

            $('.poster-increase').click(function () {
                $('.poster-background').css({opacity: 0, display: 'flex'}).animate({
                    opacity: 1
                }, 500);
            });

            $('.poster-background').click(function () {
                $(this).fadeOut();
            })
        }
    }).each(function () {
        if (this.complete) {
            $(this).trigger('load');
        }
    });

    $('#profile-settings-list a').click(function () {
        var tabs = $('.list-with-icons a');
        tabs.parent().removeClass('active');
        $(this).parent().addClass('active');
        var index = tabs.index(this);
        var tabsBlock = $('.tabs-block');
        tabsBlock.hide();
        tabsBlock.eq(index).show();
        updateCarousell();
    });

    if ($('#about_me').length > 0) {
        var count = parseInt($('#about_me').val().length);
        if (count != 0) {
            $('#symbols_count').text('осталось ' + (1000 - count) + ' символов');
        }

        $('#about_me').keyup(function () {
            var count = parseInt($('#about_me').val().length);
            $('#symbols_count').text('осталось ' + (1000 - count) + ' символов');
        });
    }

    $('#show_hidden').change(function () {
        var url = window.location.href
            .replace(/show_hidden=\d/, '')
            .replace(/[&?]$/, '');
        if ($(this).is(':checked')) {
            window.location = url + (url.includes('?') ? '&' : '?') + 'show_hidden=1';
        } else {
            window.location = url
        }
    });

    $('.comment-text').each(function (e) {
        var text = $(this).text();
        text = bbToHtml(text);
        text = autoLink(text.replace(/\n/g, '<br>'))
        $(this).html(text);
    });

}); //ready

function playerAgeConfirm() {
    var ageConfirmAnimes = JSON.parse(localStorage.ageConfirmAnimes || "{}");
    ageConfirmAnimes[$('#page_id').val()] = (new Date).addHours('24').getTime();
    localStorage.ageConfirmAnimes = JSON.stringify(ageConfirmAnimes);
    $('.player-alert-container').remove()
}

function playerAgeCheck(that) {
    var parent = $(that).parent();
    var bdate = parent.find('input').val();
    if (bdate) {
        var years = (Date.now() - new Date(bdate)) / 1000 / 60 / 60 / 24 / 365.25;
        if (years >= 18) {
            playerAgeConfirm()
        } else {
            parent.html('<h2>Ошибка</h2><p>Вам ещё нет 18-ти лет, доступ закрыт</p>')
        }
    } else {
        showNotice('Дата рождения не указана', 'Ошибка', 'error')
    }
}

var lastEp = null;
var saveEpisode = null;

function selectEpisodes(id) {
    var select = $('.video-block');

    var iframe = select.find('iframe:visible')
    iframe.attr('src', iframe.attr('src'))

    select.find('.episodes-container[data-id]').addClass('hidden');
    select.find('.episodes-container[data-id=' + id + ']').removeClass('hidden');

    var block = $('.episodes:visible');
    var button = block.find('.video-button.active');
    if (button.length > 0) {
        var height = button.offset().top - button.parent().offset().top - button.parent().scrollTop();
        block.animate({
            scrollTop: height
        }, 0);
    }
    var isSerial = [2, 3].includes($('#anime_type_id').val());
    var isOneSeria = $('#anime_num_series').val() == 1;
    if ((isOneSeria || !isSerial) && block.find('.video-button').length === 1 && saveEpisode) {
        saveEpisode(block.parent().data('id'), block.find('.video-button').data('id'))
    }

    if ($('.subscribe-anime-block[data-id="' + id + '"]').hasClass('active')) {
        $('.subscribe-anime-block-select:visible').addClass('active')
    } else {
        $('.subscribe-anime-block-select:visible').removeClass('active')
    }
}

$('.spoiler-title').click(function () {
    $(this).find('.spoiler-toggle').toggleClass('hide-icon');
    $(this).next().toggle();
});

$('.dialog-item').click(function () {
    var that = $(this);
    var user_id = that.data('user-id');
    var user_name = that.find('.user-name').text();
    var avatar = that.find('.user-avatar img').attr('src');
    $.ajax({
        url: '/profile/messages/id' + user_id,
        success: function (data) {
            $('#dialog-title').text('Диалог с ' + user_name);
            var html = '';
            $.each(data.messages, function (i, e) {
                html += '<li>';
                html += '<div class="user-avatar-mini">';
                if (e.user_id == user_id) {
                    html += '<img src="' + avatar + '" loading="lazy" alt="">';
                } else {
                    html += '<img src="' + data.my_avatar + '" loading="lazy" alt="">';
                }
                html += '</div>';
                html += '<div class="message-info">';
                if (e.user_id == user_id) {
                    html += '<a target="_blank" href="/users/id' + e.user_id + '" class="user-name pull-left">' + user_name + '</a>';
                } else {
                    html += '<span class="user-name pull-left">Я</span>';
                }
                html += '<span class="pull-right">' + e.time + '</span>';
                html += '</div>';
                html += '<div class="message-item">' + e.message + '</div>';
                html += '</li>';
            });
            $('#messages').html(html);
            $('.dialog-item').removeClass('active-dialog');
            that.addClass('active-dialog');
            $('.messages-block').addClass('show');
        }
    });
});

function profileListDate() {
    $('.profile-list[data-createdat]:not([title])').each(function () {
        var cr = convertTime($(this).data('createdat'));
        $(this).attr('title', 'Добавлено в список ' + cr);
    });
}

var offset = 0;
var skip = 0;
var sort = 'new'; // available: new|nice

var commentParam = window.location.href.lastIndexOf('comment=');
commentParam = commentParam !== -1 ? window.location.href.substr(commentParam + 8) : null;

if ($('#comments-tab, #comments').length > 0) {
    if (commentParam == null) {
//         var c = 0;
//         var commentsBlock = $('#comments').offset().top;
//         $(document).scroll(function () {
//             if ($(window).scrollTop() + $(window).height() >= commentsBlock && c === 0) {
//                 getComments();
//                 c = 1;
//             }
//         });
    } else getComments();
}

var search_value = '';
var search_delay = false;
$('input[name="word"]').keyup(function (event) {
    if (event.keyCode != 40 && event.keyCode != 38) {
        var a = $(this).val();
        $('input[name="word"]').val(a);
        if (a.length > 0) {
            search_value != a && 3 < a.length && (clearInterval(search_delay), search_delay = setInterval(function () {
                search(a)
            }, 300))
        }
    }
}).keydown(function (event) {
    var activeSearch = $('.live-search');
    if (activeSearch.length > 0) {
        var active = activeSearch.find('li.active');
        if (event.which == 40) { //down
            if (active.length > 0) { //is active
                active.removeClass('active');
                active.next().addClass('active');
            } else { //no active
                activeSearch.find('li:first-child').addClass('active');
            }
        } else if (event.which == 38) { //top
            event.preventDefault();
            if (active.length > 0) { //is active
                active.removeClass('active');
                active.prev().addClass('active');
            } else { //no active
                activeSearch.find('li:last-child').addClass('active');
            }
        } else if (event.which == 13 && active.length > 0) {
            event.preventDefault();
            document.location = activeSearch.find('li.active a').attr('href');
        }
    }
});

function search(a) {
    clearInterval(search_delay);
    $.ajax({
        type: 'get',
        url: '/get-search-list',
        data: 'word=' + encodeURIComponent(a),
        success: function (data) {
            var html = '';
            if (data.animes.total > 0) {
                $.each(data.animes.data, function (i, e) {
                    if (i < 5) {
                        html += '<li><a href="/catalog/item/' + e.alias + '">' + e.name;
                        html += ' <span class="live-search-year">(' + e.year + ')</span></a></li>';
                    }
                });
                if (data.animes.total > 5) {
                    $('.live-search-results').attr('href', '/search?word=' + data.word).html('Открыть все результаты (' + data.animes.total + ') <i class="fa fa-search" aria-hidden="true"></i>');
                } else {
                    $('.live-search-results').attr('href', '#').html('Найдено ' + data.animes.total + ' аниме');
                }
            } else {
                $('.live-search-results').attr('href', '#').html('Ничего не найдено. Попробуйте указать другое название.');
            }

            $('.main-search .live-search').html(html).parent().addClass('open');

            $(document).one('click', function () {
                $('.main-search .live-search').parent().removeClass('open');
            });
        }
    });
    search_value = a;
}

var search_value_rec = '';
var search_delay_rec = false;
$('#recom-search').keyup(function () {
    var a = $(this).val();
    if (a.length > 0) {
        search_value != a && 3 <= a.length && (clearInterval(search_delay_rec), search_delay_rec = setInterval(function () {
            search_rec(a)
        }, 600))
    }
});

function search_rec(a) {
    clearInterval(search_delay_rec);
    var anime_id = $('#page_id').val();
    $.ajax({
        type: 'post',
        url: '/recom-search',
        data: 'search=' + a + '&anime_id=' + anime_id,
        success: function (data) {
            var html = '';
            if (data.length > 0) {
                $.each(data, function (index, elem) {
                    html += '<li data-id="' + elem.id + '">' + elem.name + '</li>';
                });
                $('.live-search-wrapper.recommended .live-search').html(html).parent().addClass('open');
            }

        }
    })
}

$('.expand-player').click(function () {
    $('body').toggleClass('big-player');
});

var chatt = $('.chat-body');

$('.light-button').click(function () {
    if ($('body').toggleClass('light-off').hasClass('light-off')) {
        if (chatt.is(':hidden')) {
            $('.chat-container').addClass('light-off');
        }
        var mouseMoveCountdown;
        $(document).on('mousemove.light', function () {
            $('.episodes, .player-controls, .video-block-select > *').css('opacity', '1');
            clearTimeout(mouseMoveCountdown);
            mouseMoveCountdown = setTimeout(function () {
                $('.episodes, .player-controls, .video-block-select > *').css('opacity', '');
            }, 5000);
        }).trigger('mousemove.light');
    } else {
        $('.chat-container').removeClass('light-off');
        $(document).off('mousemove.light');
    }
});

$('.dark-overlay').click(function () {
    $('.chat-container').removeClass('light-off');
    $('body').removeClass('light-off');
    $(document).off('mousemove.light');
});

// $('.light-button').click(function () {
//     if (!chatt.is(':hidden')) {
//         $('.chat-block').addClass('light-on');
//     }
//     $('.header').addClass('light-on');
//     $('.video-wrapper').addClass('light-on');
//     $('.dark-overlay').fadeIn();
// });
//
// $('.dark-overlay').click(function () {
//     if (!chatt.is(':hidden')) {
//         $('.chat-block').removeClass('light-on');
//     }
//     $('.header').removeClass('light-on');
//     $('.video-wrapper').removeClass('light-on');
//     $('.episodes-container').css({
//         'position': 'static'
//     });
//     $(this).fadeOut();
// });

function chat() {
    if ($('.sidebar').length > 0) {
        $('.chat-block').css('left', $('.sidebar').offset().left);
    } else {
        $('.chat-block').css('right', $('.content-block').offset().left);
    }
}

$('.live-search-wrapper.recommended').on('click', 'li', function () {
    var anime_id = $('#page_id').val();
    var anime_id_rec = $(this).data('id');
    $('.live-search-wrapper.recommended').removeClass('open');
    $('#recom-search').val('');
    $.ajax({
        type: 'post',
        url: '/recom-add',
        data: 'anime_id=' + anime_id + '&anime_id_rec=' + anime_id_rec,
        success: function (data) {
            if (data.message) {
                showNotice(data.message, 'Ошибка', 'error')
            } else {
                var html = '';
                html += '<div class="anime-column" data-rec-id="' + data.id + '">';
                html += '<a class="image-block" href="/catalog/item/' + data.alias + '">';
                html += '<span class="year-block">' + data.year + '</span>';
                if (data.ongoing == 1) {
                    html += '<div class="status-label">Онгоинг</div>';
                }
                html += '<img src="' + data.image + '" loading="lazy" alt="' + data.name + '"/></a>';
                html += '<div class="anime-column-info">';
                html += '<a class="anime-title" href="/catalog/item/' + data.alias + '">' + data.name + '</a>';
                html += '<div class="recommended-info">';
                html += '<div class="recommended-btn recommended-plus fas fa-thumbs-up" data-action="1"><span>1</span></div>';
                html += '<div class="recommended-btn recommended-minus far fa-thumbs-down" data-action="0"><span>0</span></div>';
                html += '</div></div></div>';
                $('.recommend-block gap:first').before(html);
                showNotice('Спасибо, рекомендация добавлена')
            }
        }
    });
});

$('.recommend-block').on('click', '.recommended-btn', function () {
    var that = $(this);
    if (!that.hasClass('blocked')) {
        that.addClass('blocked');
        var anime_id = $('#page_id').val();
        var anime_rec_id = $(this).parents('.anime-column').data('rec-id');
        var action = $(this).data('action');
        $.ajax({
            type: 'post',
            url: '/recom-edit',
            data: 'anime_id=' + anime_id + '&anime_rec_id=' + anime_rec_id + '&action=' + action,
            success: function (data) {
                if (data.message) {
                    $('#result').css('color', '#ff6666').text(data.message);
                } else {
                    // if (action == 1) {
                    //     that.parent().find('.recommended-btn').removeClass('far')
                    // } else {
                    //     that.parent().find('.recommended-btn').removeClass('far')
                    // }
                    that.parent().find('.recommended-btn').removeClass('fas').addClass('far');
                    that.addClass('fas');
                    that.parent().find('.recommended-plus span').text(data.likes);
                    that.parent().find('.recommended-minus span').text(data.dislikes);
                }
                that.removeClass('blocked');
            }
        });
    }

});


$('#view-list-button').click(function () {
    var regExp = /(.*\..*?|)(\/.*)/;
    var link = regExp.exec(window.location.href)[2];
    var viewList = $(this).parent().find('.view-list');
    var viewListA = viewList.find('a');
    $.each(viewListA, function () {
        var elemLink = regExp.exec($.trim($(this).attr('href')))[2];
        if (elemLink == link) {
            $(this).addClass('current')
        }
    });
    viewList.toggle();
});

var offset_m = 1;
var skip_m = 20;

function soundClick() {
    var audio = new Audio();
    audio.src = '/js/notification.mp3';

    if ($.cookie("checkboxCookie") === 'chat-sound') {
        try {
            audio.play();
        } catch (e) {
            // user didnt interact with document
        }
    }
}

function byNew(button) {
    if ($('.more-comments').length > 0) {
        offset = 0;
        skip = 0;
        sort = 'new';
        $('.sort-block.comments-sort .sub-menu-inner-container').removeClass('show')
            .find('.default-button').removeClass('active');
        $(button).addClass('active');
        $('.comments-block').html('');
        getComments();
    }
}

function byNice(button) {
    if ($('.more-comments').length > 0) {
        offset = 0;
        skip = 0;
        sort = 'nice';
        $('.sort-block.comments-sort .sub-menu-inner-container').removeClass('show')
            .find('.default-button').removeClass('active');
        $(button).addClass('active');
        $('.comments-block').html('');
        getComments();
    }
}

function byOld(button) {
    if ($('.more-comments').length > 0) {
        offset = 0;
        skip = 0;
        sort = 'old';
        $('.sort-block.comments-sort .sub-menu-inner-container').removeClass('show')
            .find('.default-button').removeClass('active');
        $(button).addClass('active');
        $('.comments-block').html('');
        getComments();
    }
}

function getComments() {
    var page_type = $('#page_type').val();
    var page_id = $('#page_id').val();
    var moreContainer = $('.more-comments-container');
    if (moreContainer.children().length > 0) {
        var ajaxData = 'skip=' + skip + '&sort=' + sort;
        if (commentParam !== null && skip === 0) {
            ajaxData += '&comment=' + commentParam;
        }
        moreContainer.html('<div class="main-button disabled"><i class="loading"></i> Загрузка...</div>');
        $.ajax({
            url: '/comments/' + page_type + '/' + page_id,
            dataType: 'json',
            type: 'GET',
            data: ajaxData,
            success: function (data) {
                var old_scroll = $(window).scrollTop();
                $('.sort-block.comments-sort').removeClass('hidden');
                var commentsBlock = $('.comments-block');
                if (data.comment) {
                    commentsBlock.append(createComment(data.comment, data.isMod));
                    hideBigComment($('.comment:last').css('background', 'rgba(150,150,150,.5)').addClass('comment-linked'));
                }
                if (data.comments.length === 0 && offset === 0) {
                    $('.sort-block.comments-sort').html('Еще никто не комментировал. Будь первым!');
                }

                offset++;
                skip = offset * 20;

                $.each(data.comments, function () {
                    commentsBlock.append(createComment(this, data.isMod));
                    hideBigComment($('.comment:last'));
                });

                if (data.comment) {
                    var comment = $('.comment-linked');
                    if (comment.length > 0) {
                        comment.css('transition', '3s').css('background', '');
                        $('html').animate({
                            scrollTop: comment.offset().top + (comment.height() - $(window).height()) / 2
                        }, 500);
                    }
                }

                if (data.comments.length < 20) {
                    moreContainer.html('<div class="more-comments hidden"</div>');
                } else {
                    moreContainer.html('<div class="more-comments main-button" onclick="getComments()">Еще комментарии</div>');
                }

                $(window).scrollTop(old_scroll);
            }
        });
    }
}

function moreComments(button, comment_id, isMod) {
    var that = $(button);
    if (!that.hasClass('blocked')) {
        that.addClass('blocked');
        if (!that.hasClass('done')) {
            that.html('<i class="loading"></i> Загрузка');
            var skip = (that.data('skip') || 0);
            var data = 'skip=' + skip;
            skip += 10;
            if (skip > that.data('num')) data += '&check=1';
            $.ajax({
                url: '/comment-childs/' + comment_id,
                dataType: 'json',
                type: 'GET',
                data: data,
                success: function (data) {
                    if (data.comments.length > 0) {
                        var childs = that.parents('.comment-block').find('.comment-childs');
                        $.each(data.comments, function () {
                            childs.prepend(createComment(this, isMod));
                            hideBigComment(childs.find('.comment-block:first .comment'));
                        });
                        childs.parent().css('max-height', childs.outerHeight());
                        setTimeout(function () {
                            childs.parent().css('overflow', 'visible').css('max-height', 'none');
                        }, 300);
                        that.addClass('show pressed');
                        that.data('skip', skip);
                        if (data.count != null) {
                            that.data('num', data.count.childs_count);
                        }
                        if (skip < parseInt(that.data('num'))) {
                            var left = parseInt(that.data('num')) - skip;
                            that.html('<i class="fa fa-caret-down"></i> Показать ещё (осталось <span>' + left + '</span>)');
                        } else {
                            that.data('num', childs.children().length);
                            that.html('<i class="fa fa-caret-up"></i> Скрыть ответы (<span>' + that.data('num') + '</span>)').addClass('done');
                        }
                        if (document.activeElement.tagName === 'TEXTAREA') {
                            window.scroll({
                                top: childs.offset().top + childs.outerHeight() - (screen.height / 3),
                                left: 0,
                                behavior: 'smooth'
                            });
                        }
                    } else {
                        that.html('Ответов нет');
                    }
                    setTimeout(function () {
                        that.removeClass('blocked')
                    }, 400);
                }
            });
        } else {
            var commentBlock = that.parents('.comment-block');
            var childs = commentBlock.find('.comment-childs');
            if (!that.hasClass('show')) {
                that.html('<i class="fa fa-caret-up"></i> Скрыть ответы (<span>' + that.data('num') + '</span>)');
                childs.parent().css('max-height', childs.outerHeight());
                setTimeout(function () {
                    childs.parent().css('overflow', 'visible').css('max-height', 'none');
                }, 400);
            } else {
                that.html('<i class="fa fa-caret-down"></i> Показать ответы (<span>' + that.data('num') + '</span>)');
                childs.parent().css('max-height', childs.outerHeight());
                setTimeout(function () {
                    childs.parent().css('overflow', '').css('max-height', 0);
                }, 0);
            }
            that.toggleClass('show');
            setTimeout(function () {
                that.removeClass('blocked')
            }, 400);
        }
    }
}

function replyTo(button, comment_id, user_name) {
    var that = $(button);
    if (!that.hasClass('blocked')) {
        that.addClass('blocked');

        var commentField = $('.leave-comment-body-wrapper:first');

        if (commentField.length === 0) {
            showNotice('Вы не можете оставлять комментарии пока штраф не будет снят', 'Отправка комментария', 'error')
            return;
        }
        var commentBlock = that.parents('.comment-block:last');
        if (commentBlock.find('.leave-comment-body-wrapper').length === 0) {
            commentBlock.append(commentField.clone());
        }
        var leaveComment = commentBlock.find('.leave-comment-body-wrapper');
        var textarea = leaveComment.find('.comment-textarea')
        commentBlock.find('.reply').remove();
        leaveComment.prepend('<div class="reply" data-id="' + comment_id + '">Ответ на сообщение <b>' + user_name + '</b> <i class="remove-reply far fa-times"></i></div>');
        var editable = '';
        if (getMobileOperatingSystem() !== 'Android') {
            editable = ' contenteditable="false"'
        }
        textarea.html('<nick class="nick-label"' + editable + '>' + user_name + '</nick>&nbsp;');
        placeCaretAtEnd(textarea[0]);
        var btn = commentBlock.find('.comment-more-button');
        if (btn.hasClass('done')) {
            btn.addClass('show');
            commentBlock.find('.comment-childs').show();
            window.scroll({
                top: textarea.offset().top - (screen.height / 2),
                left: 0,
                behavior: 'smooth'
            });
        } else {
            if (!btn.hasClass('pressed'))
                btn.trigger('click');
        }
        that.removeClass('blocked');
    }
}

function hideBigComment(comment) {
    var text = comment.find('.comment-text:not(.hidden)');
    if (text.length > 0) {
        if ((text.height() * 3) + (text.width() / 2) > 750) {
            text.addClass('hide-text');
            text.after('</div><a href="#" class="more-text">Показать весь текст</a>')
        }
    }
}

var user_id = $('#user_id_chat').val(),
    login = $('#login').html(),
    loginRegex;

if (login != null) {
    login = login.replace(/([\(\)\[\]\.\\])/g, '\\$1');
    loginRegex = new RegExp("([ ]|^)(" + login + ")([ ,.]|$)", "g")
}

function createComment(data, isMod) {
    if ($('#comments-tab .comment[data-id=' + data.id + ']').length === 0) {

        var html = '<div class="comment-block">';

        html += '<div class="comment';
        if (~~data.spoiler == 1) {
            html += ' spoiler-comment';
        }
        if (typeof user_id !== 'undefined') {
            if (user_id == data.user_id) {
                html += ' my-comment';
            }
        } else html += ' non-auth';
        html += '" data-id="' + data.id + '">';

        html += '<a href="/users/id' + data.user_id + '" class="comment-img"><img src="' + data.avatar + '" loading="lazy" alt=""/></a>';
        html += '<div class="comment-head"><div class="comment-top">'

        html += '<a href="/users/id' + data.user_id + '" class="comment-author';
        if (data.user_group == 1) {
            html += ' label ';
            if (data.user_id == 25) {
                html += 'bot';
            } else html += 'admin';
        }
        html += '">' + escapeHtml(data.name) + '</a>';

        if (data.deleted_at != null || data.user_id == 25) {
            html += '<div class="comment-date" title="' + convertTimeFull(data.time) + '">' + convertTime(data.time) + '</div></div></div>';
            html += '<div class="comment-text"><div class="bot-text">Этот комментарий был удален пользователем или администрацией</div></div>';
        } else {
            if (typeof user_id !== 'undefined' && user_id != data.user_id) {
                html += '<div class="reply-button" onclick="replyTo(this, ' + data.id + ', \'' + data.name.replace(/'/g, '\\\'') + '\')">Ответить</div>';
            }

            html += '<div class="comment-date" title="' + convertTimeFull(data.time) + '">' + convertTime(data.time);
            html += '</div></div>';

            if (typeof user_id !== 'undefined') {
                html += '<div class="comment-controls"><span class="drop-menu-click far fa-fw fa-ellipsis-h"></span>';
                html += '<div class="hidden-menu invisible"><div class="drop-list">'
                if (user_id == data.user_id) {
                    if (data.likes == 0 && data.dislikes == 0) {
                        html += '<div class="drop-menu-item edit-comment">Редактировать</div>';
                    }
                    html += '<div class="drop-menu-item remove-comment">Удалить</div>';
                } else {
                    if (isMod) {
                        html += '<div class="drop-menu-item moder-remove-comment">Удалить</div>';
                    } else {
                        html += '<div class="drop-menu-item send-claim">Пожаловаться</div>';
                    }
                }
                html += '</div></div>'
                html += '</div>';
            }
            html += '</div>';

            html += '<div class="comment-body">';
            var text = data.text.toString().replace(/\n{3,}/g, '<br><br>').replace(/\n/g, '<br>');

            text = bbToHtml(text);
            text = autoLink(text);

            if (~~data.spoiler == 1) {
                html += '<div class="comment-text hidden">' + text + '</div>';
                html += '<a href="#" class="more-text">Комментарий содержит спойлер. Показать?</a>';
            } else if (data.dislikes - data.likes > 10) {
                html += '<div class="comment-text hidden">' + text + '</div>';
                html += '<a href="#" class="more-text">Комментарий скрыт из-за низкого рейтинга. Показать?</a>';
            } else {
                html += '<div class="comment-text">' + text + '</div>';
            }
            html += '</div>';

            html += '<div class="comment-karma"><div>';
            var o = ['r', 'r'];
            if (data.vote != null) o = data.vote ? ['s', 'r'] : ['r', 's'];
            html += '<span class="likes fa' + o[0] + ' fa-thumbs-up">' + data.likes + '</span>';
            html += '<span class="dislikes fa' + o[1] + ' fa-thumbs-down">' + data.dislikes + '</span>';

            html += '</div>';
            if (typeof user_id !== 'undefined' && user_id != data.user_id) {
                html += '<div class="reply-button comment-mobile" onclick="replyTo(this, ' + data.id + ', \'' + data.name.replace(/'/g, '\\\'') + '\')">Ответить</div>';
            }
            html += '</div>';
        }
        html += '</div>';
        if (data.childs_count > 0) {
            html += '<div class="comment-more-button" data-num="' + data.childs_count + '" onclick="moreComments(this, ' + data.id + (isMod ? ', 1' : '') + ')"><i class="fa fa-caret-down"></i> Показать ответы (<span>' + data.childs_count + '</span>)</div>';
        }
        if (!data.parent_id) {
            html += '<div class="comment-childs-container"><div class="comment-childs"></div></div>';
        }
        html += '</div>';

        return html;
    }
}

function convertTime(UNIX_timestamp) {
    var a = new Date(UNIX_timestamp * 1000);
    var now = new Date();
    var months = ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
    var str = ('0' + a.getDate()).slice(-2);
    str += ' ' + months[a.getMonth()] + ' ';
    if (now.getFullYear() !== a.getFullYear()) {
        str += a.getFullYear();
    } else {
        str += ('0' + a.getHours()).slice(-2) + ':' + ('0' + a.getMinutes()).slice(-2);
    }
    return str;
}

function convertTimeFull(UNIX_timestamp) {
    var a = new Date(UNIX_timestamp * 1000);
    var str = ('0' + a.getDate()).slice(-2);
    str += '.' + ('0' + (a.getMonth() + 1)).slice(-2);
    str += '.' + a.getFullYear();
    str += ' ' + ('0' + a.getHours()).slice(-2);
    str += ':' + ('0' + a.getMinutes()).slice(-2);
    str += ':' + ('0' + a.getSeconds()).slice(-2);
    return str;
}

$('#recommended-button').click(function () {
    var id = $('#page_id').val();
    var user_id = $('#user_id_chat').val();
    $.ajax({
        type: 'post',
        url: '/recommendation',
        data: 'id=' + id,
        success: function (data) {
            var container = $('.recommend-block');
            var html = '';
            if (data == 0) {
                container.html('<span class="marker">Еще никто не добавлял похожие аниме.</span>');
                return;
            } else {
                $.each(data, function (i, e) {
                    html += '<div class="anime-column" data-rec-id="' + e.id + '">';
                    html += '<a class="image-block" href="/catalog/item/' + e.alias + '">';
                    html += '<span class="year-block">' + e.year + '</span>';
                    if (e.ongoing == 1) {
                        html += '<div class="status-label">Онгоинг</div>';
                    }
                    html += '<img src="' + e.image + '" loading="lazy" alt="' + e.name + '"/>';
                    html += '</a>';
                    html += '<div class="anime-column-info">';
                    html += '<a class="anime-title" href="/catalog/item/' + e.alias + '">' + e.name + '</a>';

                    html += '<div class="recommended-info">';

                    if (typeof user_id !== 'undefined') {
                        html += '<div class="recommended-btn recommended-plus fa-thumbs-up';
                        if (e.is_selected && e.action == 1) {
                            html += ' fas'; //added class active
                        } else {
                            html += ' far';
                        }
                        html += '" data-action="1"><span>' + e.likes + '</span></div>';

                        html += '<div class="recommended-btn recommended-minus fa-thumbs-down';
                        if (e.is_selected && e.action === 0) {
                            html += ' fas'; //added class active
                        } else {
                            html += ' far';
                        }
                        html += '" data-action="0"><span>' + e.dislikes + '</span></div>';
                    } else {
                        html += '<div class="recommended-btn recommended-plus far fa-thumbs-up" data-action="1"><span>' + e.likes + '</span></div>';
                        html += '<div class="recommended-btn recommended-minus far fa-thumbs-down" data-action="0"><span>' + e.dislikes + '</span></div>';
                    }

                    html += '</div>';
                    html += '</div>';
                    html += '</div>';
                });
            }
            html += '<gap/><gap/><gap/>';
            container.html(html);
        }
    });
});


$(function () {
    $('.menu a').each(function () {
        if ((window.location.href == $(this).attr('href')) || ($(this).attr('href') == window.location.protocol + '//' + window.location.host && window.location.pathname == '/')) {
            $(this).parent().addClass('active');
        }
    }).click(function () {
        var that = $(this);
        if (that.attr('href') !== '#') {
            that.parent().addClass('active');
        }
    });
});

$('#default-avatar').click(function () {
    $.ajax({
        type: 'post',
        url: '/default-avatar',
        data: 'user_id=' + $('#user_id').val(),
        success: function (data) {
            showNotice(data.message);
        }
    });
});


$('.comments-block').on('click', '.banned-win-close', function () {
    $(this).parents('.comment').find('.banned-overlay').remove();
    $(this).parents('.comment').find('.banned-win').remove();
}).on('change', '.why-delete', function () {
    var id = $(this).find('option:selected').data('id');
    if (id == 'admin_comment') {
        $(this).parent().find('.custom').html('<input name="admin_comment" type="text" placeholder="Свой комментарий">');
    } else {
        $(this).parent().find('.custom').html('');
    }
});

function addVote(that, type) {
    var comment = that.parents('.comment');
    if ($('#user_id_chat').length < 1) {
        showNotice('Для голосования вы должны быть зарегистрированы', 'Ошибка', 'error');
        return false;
    }
    if (!comment.hasClass('blocked')) {
        comment.addClass('blocked');
        var another = that.prev();
        if (type === 1) another = that.next();
        var check = another.hasClass('fas');
        that.toggleClass('far').toggleClass('fas');
        another.removeClass('fas').addClass('far');
        $.ajax({
            url: '/comment/vote/' + comment.data('id') + '?type=' + type,
            type: 'POST',
            success: function (data) {
                if (data.success) {
                    if (data.vote) {
                        that.html(parseInt(that.html()) + 1);
                        if (check) another.html(parseInt(another.html()) - 1);
                        showNotice('Спасибо, ваш голос учтен');
                    } else {
                        that.html(parseInt(that.html()) - 1);
                        showNotice('Голос удалён');
                    }
                } else {
                    showNotice(data.error);
                    that.toggleClass('fas').toggleClass('far')
                }
                comment.removeClass('blocked');
            }
        });
    }
}

$('#comments-tab, #comments').on('click', '.send-comment', function () {
    var that = $(this);
    if (!that.hasClass('blocked')) {
        that.addClass('blocked').html('<i class="loading"></i> Отправка');
        var parent = that.parents('.leave-comment-body-wrapper');
        var parent_id = parseInt(that.parents('.comment-block:last').children(':first').data('id'));

        var reply_elem = parent.find('.reply');
        var add_to_post = '';
        if (reply_elem.length > 0) {
            add_to_post = '&reply_to_comment=' + parseInt(reply_elem.data('id'));
            add_to_post += '&parent_comment=' + parent_id;
        }
        var message = $.trim(parent.find('.comment-textarea').html());
        message = htmlToBb(message);
        message = escapeEncode(message);
        message = removeEmptybb(message);
        // var checkMessage = message.replace(/<\/?[^>]+(>|$)/g, "").replace(/\s/g, "").replace(/\u00a0/g, "").replace(/&#39;/g, "");
        var checkMessage = checkOnSend(message);
        if (checkMessage === 'true') {

            var check = true;

            $.getJSON('/js/black_list.json', function (data) {

                var symbols = /[',', '.', '(', ')', '/', '-']/g;
                var text = message.toLowerCase().replace(symbols, ' ').split(' ');

                $.each(text, function (i, val) {
                    if (data.brutals.indexOf(val) !== -1) {
                        showNotice('В вашем комментарии используется нецензурная лексика, которая на сайте запрещена!', 'Ошибка отправки комментария', 'error');
                        that.removeClass('blocked').html('Отправить');
                        check = false;
                        return false;
                    }
                });

                if (!checkAcceptedLinks(message, commentsLinkWhiteList)) {
                    that.removeClass('blocked').html('Отправить');
                    check = false;
                }

                if (check) {
                    var page_type = $('#page_type').val();
                    var page_id = $('#page_id').val();
                    var send_data = 'text=' + encodeURIComponent(message) + add_to_post;

                    var spoiler = $('#spoiler:checked').length;
                    if (spoiler > 0) {
                        send_data += '&spoiler=1';
                    } else {
                        send_data += '&spoiler=0';
                    }

                    grecaptcha.ready(function () {
                        grecaptcha.execute(recaptchaSiteKey, {action: 'send_comment'}).then(function (token) {
                            if (token) {
                                send_data += '&g-recaptcha-response=' + token;
                            }
                            $.ajax({
                                url: '/comments/' + page_type + '/' + page_id,
                                type: 'POST',
                                dataType: 'json',
                                data: send_data,
                                success: function (data) {
                                    if (data.status) {
                                        data.text = message;
                                        data.likes = 0;
                                        data.dislikes = 0;
                                        data.parent_id = parent_id;
                                        data.time = new Date().getTime() / 1000;
                                        var html = createComment(data);
                                        if (reply_elem.length > 0) {
                                            var commentBlock = that.parents('.comment-block:last');
                                            commentResize(commentBlock.find('.comment-childs').append(html));
                                            var moreBtn = commentBlock.find('.comment-more-button');
                                            if (moreBtn.length > 0) {
                                                var btnNum = moreBtn.data('num') + 1;
                                                moreBtn.data('num', btnNum);
                                                moreBtn.data('skip', (moreBtn.data('skip') || 0) + 1);
                                                if (!moreBtn.hasClass('pressed') || moreBtn.hasClass('done')) {
                                                    moreBtn.find('span').html(btnNum);
                                                }
                                            } else {
                                                commentBlock.find('.comment-childs-container').before('<div class="comment-more-button show pressed done" data-num="1" onclick="moreComments(this)"><i class="fa fa-caret-up"></i> Скрыть ответы (<span>1</span>)</div>');
                                            }
                                        } else $('.comments-block').prepend(html);
                                        parent.find('.comment-textarea').html('');
                                        parent.find('.remove-reply').trigger('click');
                                        that.removeClass('blocked').html('Отправить');
                                        if (offset === 0) {
                                            getComments();
                                        }
                                    } else {
                                        showNotice(data.message, 'Ошибка', 'error');
                                    }
                                },
                                error: function (request, status, error) {
                                    that.addClass('error');
                                    showNotice(request.message || 'Произошла ошибка, попробуйте позже', 'Ошибка', 'error');
                                }
                            });
                        });
                    });
                } else {
                    that.removeClass('blocked');
                }
            });
        } else {
            that.removeClass('blocked').html('Отправить');
            showNotice(checkMessage, 'Ошибка отправки комментария', 'error');
        }
    }
}).on('click', 'span.likes', function () {
    addVote($(this), 1);
}).on('click', 'span.dislikes', function () {
    addVote($(this), 0);
}).on('click', '.send-claim', function () {
    var comment = $(this).parents('.comment');
    var html = '<div class="banned-win">';
    html += '<div class="banned-win-close far fa-times-circle"></div>';
    html += '<div class="banned-user">Жалоба на комментарий</div>';
    html += '<select class="why-delete">' +
        '<option value="0" data-placeholder="true">Причина</option>' +
        '<option value="1">спойлер</option>' +
        '<option value="3">нецензурная лексика</option>' +
        '<option value="4">оскорбление других участников</option>' +
        '<option value="5">комментарий не по теме или не имеет смысла</option>' +
        '<option value="8">ссылка на сторонний сайт</option>' +
        '</select>';
    html += '<div class="claim-ok main-button">Отправить</div>';
    html += '</div>';
    html += '<div class="banned-overlay"></div>';
    if (comment.find('.banned-win').length < 1) {
        comment.append(html).find('select.why-delete').slimSelect();
    }
}).on('click', '.claim-ok', function () {
    var that = $(this);
    var $comment = that.parents('.comment');
    var reason = that.parent().find('.why-delete').val();
    if (+reason) {
        var data = 'why=' + reason;
        $.ajax({
            url: '/comment/claim/' + $comment.data('id'),
            type: 'POST',
            dataType: 'json',
            data: data,
            success: function (data) {
                $comment.find('.banned-win').remove();
                $comment.find('.banned-overlay').remove();
                if (data.success) {
                    showNotice('Спасибо, ваша жалоба принята');
                } else {
                    showNotice(data.error);
                }
            }
        })
    } else {
        showNotice('Укажите причину жалобы');
    }
}).on('click', '.remove-comment', function () {
    if (confirm('Вы действительно хотите удалить этот комментарий? Это действие нельзя будет отменить')) {
        var that = $(this);
        var id = that.parents('.comment').data('id');
        $.ajax({
            type: 'post',
            url: '/profile/remove-comment',
            data: 'id=' + id,
            success: function (data) {
                if (data.success) {
                    if (that.parents('.comment-childs').length !== 0) {
                        var btn = that.parents('.comment-childs-container').prev();
                        var btnNum = btn.data('num') - 1;
                        btn.data('num', btnNum);
                        if (btnNum > 0) {
                            btn.find('span').html(btnNum);
                        } else that.fadeOut();
                        commentResize(that);
                    }
                    that.parents('.comment-block:first').fadeOut();
                } else {
                    showNotice(data.error);
                }
            }
        });
    }
}).on('click', '.edit-comment', function () {
    var that = $(this);
    var comment = that.parents('.comment').addClass('edit');
    comment.find('.comment-karma, .comment-text, .more-text').hide();
    comment.find('.comment-text a').contents().unwrap();
    var text = comment.find('.comment-text')[0].innerHTML;
    text = spoilerToBb(text);
    var html = '<div><div class="comment-textarea edit-message" data-placeholder="Текст комментария" contenteditable="true">' + text + '</div><div class="comment-menu"><div class="bbcode"> <div class="default-button bb-b" data-bb="bold"> <i class="far fa-fw fa-bold"></i> </div> <div class="default-button bb-i" data-bb="italic"> <i class="far fa-fw fa-italic"></i> </div> <div class="default-button bb-u" data-bb="underline"> <i class="far fa-fw fa-underline"></i> </div> <div class="default-button bb-s" data-bb="strikethrough"> <i class="far fa-fw fa-strikethrough"></i> </div> <div class="default-button bb-spoiler" data-bb="spoiler"> <i class="far fa-fw fa-low-vision"></i> </div></div><div><button class="main-button send-edit col">Сохранить</button><button class="main-button transparent send-cancel col">Отмена</button></div> </div></div>';
    comment.find('.comment-body').after(html);
    commentResize(that);
    if (comment.hasClass('spoiler-comment'))
        comment.find('input[type=checkbox]').prop('checked', true);
}).on('click', '.send-cancel', function () {
    var comment = $(this).parents('.comment').removeClass('edit');
    comment.find('.comment-karma, .comment-text, .more-text').show();
    comment.find('.comment-body').next().remove();
    var text = comment.find('.comment-text');
    text.html(autoLink(text[0].innerHTML));
    commentResize(comment)
}).on('click', '.send-edit', function () {
    var that = $(this);
    if (!that.hasClass('blocked')) {
        that.addClass('blocked');
        var comment = that.parents('.comment');
        var id = comment.data('id');
        var text = $.trim(comment.find('.edit-message').html());

        if (!checkAcceptedLinks(text, commentsLinkWhiteList)) {
            that.removeClass('blocked');
            return false;
        }
        text = htmlToBb(text);
        text = escapeEncode(text);
        text = text.replace(/\n{3,}/g, '\n\n');

        var checkMessage = checkOnSend(text);
        if (checkMessage === 'true') {
            var send_data = 'id=' + id + '&text=' + encodeURIComponent(text);
            var spoiler = comment.find('input[name="spoiler"]:checked').length;
            if (spoiler > 0) {
                send_data += '&spoiler=1';
            } else {
                send_data += '&spoiler=0';
            }

            $.ajax({
                type: 'post',
                url: '/profile/update-comment',
                data: send_data,
                success: function (data) {
                    if (data.success) {
                        text = bbToHtml(text.replace(/\n/g, '<br>'));
                        text = autoLink(text);
                        comment.removeClass('edit').find('.comment-text').html(text);
                        comment.find('.comment-karma, .comment-text, .more-text').show();
                        if (spoiler > 0) {
                            comment.addClass('spoiler-comment');
                        }
                        comment.find('.comment-body').next().remove();
                        commentResize(comment)
                    } else {
                        showNotice(data.error);
                    }
                    that.removeClass('blocked');
                }
            });
        } else {
            showNotice(checkMessage, 'Ошибка отправки комментария', 'error');
            that.removeClass('blocked');
        }
    }
}).on('click', '.remove-reply', function () {
    var parent = $(this).parents('.leave-comment-body-wrapper');
    parent.remove();
}).on('paste', '.comment-textarea', function (e) {
    e.preventDefault();
    var text = e.originalEvent.clipboardData.getData('text/plain');
    document.execCommand('inserttext', false, text);
}).on('mouseup', '.comment-textarea', function (e) {
    var buttons = $(this).parents('.comment, .leave-comment-body').find('.bbcode > div');
    buttons.each(function () {
        var that = $(this);
        that.toggleClass('active', document.queryCommandState(that.data('bb')));
    })
}).on('mousedown', '.bbcode > div', function (e) {
    e.preventDefault()
    var tag = $(this).data('bb');
    var textArea = $(this).parents('.comment, .leave-comment-body').find('.comment-textarea');
    textArea.focus()

    if (tag !== 'spoiler') {
        document.execCommand(tag, false);
        $(this).toggleClass('active', document.queryCommandState(tag))
    } else {
        var text = ' [спойлер="Спойлер!"] [/спойлер] ';
        var selObj = window.getSelection();
        if (selObj.rangeCount > 0) {
            var range = selObj.getRangeAt(0);
            if ($(range.commonAncestorContainer).closest(textArea).length > 0) {
                text = ' [спойлер="Спойлер!"] ' + selObj.toString() + ' [/спойлер] '
            }
        }
        document.execCommand('inserttext', false, text);
    }
}).on('click', '.spoiler-button', function () {
    var that = $(this);
    that.hide();
    that.next().css('display', 'initial');
    commentResize(that)
}).on('click', 'spoiler', function () {
    var that = $(this);
    that.hide();
    that.prev().css('display', 'initial');
    commentResize(that)
}).on('click', '.moder-remove-comment', function () {
    var comment = $(this).parents('.comment');
    var html = '<div class="banned-win">';
    html += '<div class="banned-win-close far fa-times-circle"></div>';
    html += '<div class="banned-user">Удалить комментарий</div>';
    html += '<select class="why-delete">' +
        '<option value="0" data-placeholder="true">Причина</option>' +
        '<option value="1">спойлер</option>' +
        '<option value="3">нецензурная лексика</option>' +
        '<option value="4">оскорбление других участников</option>' +
        '<option value="5">комментарий не по теме или не имеет смысла</option>' +
        '<option value="8">ссылка на сторонний сайт</option>' +
        '<option value="7">комментарий, на который вы отвечали был удален</option>' +
        '</select>';
    html += '<label class="checkbox"><input name="remove_childs" type="checkbox" value="1"><div></div> Удалить дочерние</label>';
    html += '<div class="remove-ok main-button">Удалить</div>';
    html += '</div>';
    html += '<div class="banned-overlay"></div>';
    if (comment.find('.banned-win').length < 1) {
        comment.append(html).find('.why-delete').slimSelect();
    }
}).on('click', '.remove-ok', function () {
    var that = $(this);
    var comment = that.parents('.comment');
    var reason = comment.find('.why-delete').val();
    if (+reason) {
        var data = 'id=' + comment.data('id');
        data += '&reason=' + reason;
        if (comment.find('[name="remove_childs"]').is(':checked')) {
            data += '&remove_childs=1';
        }
        data += '&action=0';
        comment.find('.banned-win, .banned-overlay').remove();
        $.ajax({
            type: 'post',
            url: '/moderate/comment/update',
            data: data,
            success: function (data) {
                if (data.success) {
                    if (data.code === 1) {
                        comment.find('.default-button').css('visibility', 'hidden');
                        comment.find('.comment-top, .comment-body, .comment-img').css('opacity', '.6');
                        comment.find('.comment-body').append('<div class="attention-text">Спойлер</div>')
                    } else {
                        comment.find('.comment-body').append('<div class="attention-text">Комментарий скрыт</div>')
                    }
                    comment.find('.drop-list').append('<div class="drop-menu-item moder-restore-comment">Восстановить</div>')
                    comment.find('.moder-viewed-comment, .moder-remove-comment').remove()
                } else {
                    showNotice('Что-то пошло не так', 'Ошибка', 'error')
                }
            },
            error: function (request, status, error) {
                showNotice('Что-то пошло не так', 'Ошибка', 'error');
            },
        });
    } else {
        showNotice('Укажите причину удаления', 'Ошибка', 'error');
    }
}).on('click', '.moder-restore-comment', function () {
    var that = $(this);
    var parent = that.parents('.comment');
    if (confirm('Вы уверены, что хотите восстановить комментарий?')) {
        var data = {
            'id': parent.data('id')
        };
        $.ajax({
            type: 'post',
            url: '/moderate/comment/restore',
            data: data,
            success: function (data) {
                if (parent.find('.moder-remove-comment').length == 0) {
                    that.after('<div class="drop-menu-item moder-remove-comment">Удалить</div>');
                }
                that.remove()
                parent.find('.attention-text').remove();
                showNotice('Комментарий восстановлен', 'Успех', 'success')
            },
            error: function () {
                showNotice('Что-то пошло не так', 'Ошибка', 'error');
            }
        });
    }
});

function commentResize(that) {
    var childs = that;
    if (!childs.hasClass('comment-childs')) {
        childs = childs.parents('.comment-childs');
    }
    childs.parent().css('overflow', '').css('max-height', childs.outerHeight());
    setTimeout(function () {
        childs.parent().css('overflow', 'visible').css('max-height', 'none');
    }, 300);
}

function counter(el) {
    return el.replace(/<\/?[^>]+(>|$)/g, "")
        .replace(/\s/g, "")
        .replace(/&nbsp;/g, "")
        .replace(/&#39;/g, "")
        .length;
}

function checkAcceptedLinks(text, array) {
    if (!array) {
        array = linkWhiteList
    }
    var checkLink = true;
    Autolinker.link(text, {
        replaceFn: function (match) {
            if (!new RegExp(array.join('|')).test(match.getAnchorHref())) {
                checkLink = false;
            }
        }
    });
    if (!checkLink) {
        showNotice('В комментариях запрещены все ссылки на сторонние сайты, за исключением ' + array.slice(1).join(', '), 'Ошибка отправки комментария', 'error');
        return false;
    }
    return true;
}

function checkBrutals(text) {
    // var brutals = [];
    $.getJSON('/js/black_list.json', function (data) {

        $.each(data.brutals, function (i, val) {

            if (text.indexOf(val) !== -1) {
                return 'false';
            }

        });
    }).complete(function () {
        return 'true';
    });

}

//to top button
$(window).scroll(function () {
    var that = $(this);
    if (that.width() > 1520 && !$('body').hasClass('block-scroll')) {
        if (that.scrollTop() > 200) {
            $('#to-top').addClass('visible');
        } else {
            $('#to-top').removeClass('visible');
        }
    }
});
$('#to-top').click(function () {
    $(this).hide();
    $('body').addClass('block-scroll');
    $('body,html').animate({
        scrollTop: 0
    }, 300, function () {
        $('body').removeClass('block-scroll');
    });
});

$('.view-button').click(function () {
    if (!$(this).hasClass('active')) {
        var view = $(this).data('view');
        $('body').removeClass('view-page-list view-page-grid').addClass('view-page-' + view);
        $('.view-button').removeClass('active');
        $(this).addClass('active');
        localStorage.viewPageTop = view;
    }
});

$('.saw').click(function (e) {
    // e.preventDefault();
});

$('#upload-avatar').click(function () {
    $('input[name="upload-avatar"]').click();
});

$('#remove-avatar').click(function () {
    $('.old-avatar, .cr-image').attr('src', '/img/no-photo.jpg');
    $('input[name="avatar"]').attr('value', '/img/no-photo.jpg');
    showNotice("Аватар удалён, сохраните профиль", 'Удаление аватарки', 'success');
});

$('.accept-request').click(function () {
    var that = $(this);
    var user_id = $(this).parents('.user-block').data('id');
    $.ajax({
        type: 'post',
        url: '/accept-request',
        data: 'user_id=' + user_id,
        success: function () {
            that.text('Заявка принята').attr('class', 'main-button disabled');
        }
    });
});

$('.decline-request').click(function () {
    var that = $(this);
    var user_id = $(this).parents('.user-block').data('id');
    $.ajax({
        type: 'post',
        url: '/decline-request',
        data: 'user_id=' + user_id,
        success: function () {
            that.text('Заявка отклонена').attr('class', 'main-button disabled');
        }
    });
});

$('.remove-request').click(function () {
    var that = $(this);
    var user_id = $(this).parents('.user-block').data('id');
    $.ajax({
        type: 'post',
        url: '/remove-request',
        data: 'user_id=' + user_id,
        success: function () {
            that.text('Заявка удалена').attr('class', 'main-button disabled');
        }
    });
});

$('.rating-list li').click(function () {
    var that = $(this);
    var anime_id = ~~that.parents('.modal').find('.modal-header').attr('data-id');
    var data = 'idBox=' + anime_id;
    data += '&rate=' + ~~that.data('rate');
    $.ajax({
        type: 'post',
        url: '/profile/rating',
        data: data,
        success: function (data) {
            that.modal('destroy');
            showNotice(data.message);
            if (data.status) {
                var ratingBlock = $('.rating-star[data-id="' + anime_id + '"]');
                var rateClass = '';
                if (data.rate < 6) {
                    rateClass = 'bad-rating';
                }
                ratingBlock.parent().find('.main-rating-block').html('<span class="main-rating">' + data.new_rating.rating + '</span> <span class="main-rating-info"> ' + data.new_rating.votes + ' голосов</span>').parent().find('.user-rating').removeClass('bad-rating').addClass(rateClass).html('<i class="fa fa-star"></i> ' + data.rate);
                if (ratingBlock.parent().find('.user-rating').length > 0) {
                    ratingBlock.parent().find('.user-rating').removeClass('bad-rating').addClass(rateClass).html('<i class="fa fa-star"></i> ' + data.rate);
                } else {
                    ratingBlock.parent().append('<span title="Мой рейтинг" data-id="' + anime_id + '" class="user-rating ' + rateClass + '"><i class="fa fa-star"></i> ' + data.rate + '</span>');
                }
            }
        }
    });
});

function setTheme(el) {
    $('.transparent-item').removeClass('active');
    el.addClass('active');
    var theme = el.data('type');
    var id = el.data('bg');

    var body = $('body');
    body.addClass('theme-change').attr({'data-theme': theme, 'data-theme-id': id});

    $('input[name="params[default_theme_bg]"]').val(id);
    setTimeout(function () {
        body.removeClass('theme-change');
    }, 600)
}

$('#default-theme').change(function () {
    var val = $(this).find('option:selected').val();
    if (val == 2) {
        $('#transparent-bg').removeClass('hidden');
        updateCarousell()
        setTheme($('.transparent-item.active'));
    } else {
        $('#transparent-bg').addClass('hidden');
        var body = $('body');
        body.addClass('theme-change').attr({'data-theme': +val ? 'dark' : 'light', 'data-theme-id': 0});
        setTimeout(function () {
            body.removeClass('theme-change');
        }, 600)
    }
});

$('select#anime_id').slimSelectAjax(function (search, callback) {
    $.ajax({
        type: 'get',
        url: '/anime-search',
        data: 'search=' + search,
        success: function (data) {
            var result = [];
            $.each(data, function (index, elem) {
                result.push({value: elem['id'], text: elem['name']})
            });
            callback(result)
        },
        error: function () {
            callback(false)
        }
    })
});

//ajax anime search
// var search_val = '';
// var search_del = false;
// $('#anime_name').keyup(function () {
//     var a = $(this).val();
//     if (a.length > 0) {
//         search_val != a && 3 < a.length && (clearInterval(search_del), search_del = setInterval(function () {
//             search_rev(a)
//         }, 600))
//     } else {
//         $('input[name="anime_id"]').val('');
//     }
// });

// function search_rev(a) {
//     clearInterval(search_del);
//     $.ajax({
//         type: 'get',
//         url: '/anime-search',
//         data: 'search=' + a,
//         success: function (data) {
//             var html = '';
//             if (data.length > 0) {
//                 $.each(data, function (index, elem) {
//                     html += '<li data-id="' + elem.id + '">' + elem.name + '</li>';
//                 });
//             } else {
//                 html += '<a href="#" class="live-search-results">Ничего не найдено, попробуйте другое название</a>';
//             }
//             $('#anime-search').html(html).parent().addClass('open');
//         }
//     })
// }

$('.notice-viewed').click(function () {
    var that = $(this);
    if (!that.hasClass('blocked')) {
        that.addClass('blocked');
        var id = that.data('id');
        $.ajax({
            url: '/profile/notice/' + id + '/viewed',
            type: 'POST',
            dataType: 'json',
            success: function (data) {
                if (data.success) {
                    that.parents('li').removeClass('not-viewed');
                    that.remove();
                    var num = parseInt($('.notifications-number:first').data('num')) - 1;
                    if (num < 1) {
                        $('.notifications-number').remove();
                    } else {
                        $('.notifications-number').each(function () {
                            $(this).data('num', num).text(num > 99 ? '99+' : num)
                        });
                    }
                }
                that.removeClass('blocked');
            }
        });
    }
});

$('.notice-remove').click(function () {
    var that = $(this);
    if (!that.hasClass('blocked')) {
        that.addClass('blocked');
        var id = that.data('id');
        var li = that.parents('li');
        $.ajax({
            url: '/profile/notice/' + id + '/delete',
            type: 'POST',
            dataType: 'json',
            success: function (data) {
                if (data.success) {
                    if (li.hasClass('not-viewed')) {
                        var num = parseInt($('.notifications-number:first').data('num')) - 1;
                        if (num < 1) {
                            $('.notifications-number').remove();
                        } else {
                            $('.notifications-number').each(function () {
                                $(this).data('num', num).text(num > 99 ? '99+' : num)
                            });
                        }
                    }
                    var total = $('#total-notices');
                    var totalNum = parseInt(total.text()) - 1;
                    total.text(totalNum < 0 ? 0 : totalNum);
                    li.remove();
                }
            }
        });
    }
});
$('#viewed_all_notices').click(function () {
    var $_GET = {};

    if (document.location.search.indexOf('?') !== -1) {
        var query = document.location.search
            .replace(/^.*?\?/, '')
            .replace(/#.*$/, '')
            .split('&');

        for (var i = 0, l = query.length; i < l; i++) {
            var aux = decodeURIComponent(query[i]).split('=');
            $_GET[aux[0]] = aux[1];
        }
    }

    var stringTypeId = '';

    if ($_GET['type']) {
        stringTypeId = '?type=' + $_GET['type'];
    }

    $.ajax({
        type: 'post',
        url: '/profile/notices/viewed-all-notices' + stringTypeId,
        success: function (data) {
            if (data) {
                $('li.not-viewed').removeClass('not-viewed');
                $('.notice-viewed').remove();
                $('.notifications-number').remove();
            }
        }
    });
});

$('#delete_all_notices').click(function () {
    if (confirm('Вы действительно хотите удалить все уведомления в этой категории? Это действие нельзя будет отменить.')) {
        var $_GET = {};

        if (document.location.search.indexOf('?') !== -1) {
            var query = document.location.search
                .replace(/^.*?\?/, '')
                .replace(/#.*$/, '')
                .split('&');

            for (var i = 0, l = query.length; i < l; i++) {
                var aux = decodeURIComponent(query[i]).split('=');
                $_GET[aux[0]] = aux[1];
            }
        }

        var stringTypeId = '';

        if ($_GET['type']) {
            stringTypeId = '?type_id=' + $_GET['type'];
        }

        $.ajax({
            type: 'post',
            url: '/profile/notices/delete-all-notices' + stringTypeId,
            success: function (data) {
                if (data.status) {
                    $('.notif-list').remove();
                    $('.pagination-block').remove();
                    $('#total-notices').parents('.col').text('Пока нет никаких уведомлений.');

                    if (data.unread_count > 0) {
                        if (data.unread_count < 100) {
                            $('.notifications-number').text(data.unread_count);
                        }
                    } else {
                        $('.notifications-number').remove();
                    }
                }
                showNotice(data.message);
            }
        });
    }
});

$('#profile-menu').click(function () {
    $('.profile-menu').toggle();
});

$('.video_updated .video-block-description').click(function () {
    $(this).parent().parent().find('.episodes-container').toggleClass('hidden');
});

$('.video-block-description').click(function () {
    $(this).parent().find('.episodes-container').toggleClass('hidden');
});

// var seria;
//
// function onPlayerNextEpisode(data) {
//     var src = 'https://streamguard.cc/serial/' + data.serial_token + '/iframe?season=' + data.serial_season + '&nocontrols=1&episode=' + data.serial_episode + '?origin=yummyanime.com';
//     seria = $("[data-href='" + src + "']");
//     if (seria.length === 0) {
//         src = 'https://streamguard.cc/video/' + data.video_token + '/iframe?origin=yummyanime.com';
//         seria = $("[data-href='" + src + "']");
//         if (seria.length === 0)
//             seria = null;
//     }
// }
//
// function onPlayerStartEpisode() {
//     if (seria !== null) {
//         if (!seria.hasClass("active")) {
//             var block = seria.parents('.block-episodes');
//             if (block.parents('.video-wrapper').hasClass('video_updated') === true) {
//                 if ($('#user_id_chat').length > 0) {
//                     $.ajax({
//                         type: 'post',
//                         url: '/profile/save-episode',
//                         data: 'episode_id=' + seria.data('id') + '&block_id=' + block.data('id') + '&anime_id=' + anime_id + $('#anime_id').val(),
//                         success: function (data) {
//                             block.find('.video-button').removeClass('active');
//                             seria.addClass('active');
//                         }
//                     });
//                 } else {
//                     $.cookie($('#anime_alias').val(), block.data('id') + '.' + seria.data('id'), {
//                         expires: 20,
//                         path: window.location.pathname
//                     });
//                     block.find('.video-button').removeClass('active');
//                     seria.addClass('active');
//                 }
//             } else {
//                 if ($('#user_id_chat').length > 0) {
//                     $.ajax({
//                         type: 'post',
//                         url: '/saved/' + $('#anime_id').val() + '/' + seria.data('id'),
//                         success: function () {
//                             block.find('.video-button').removeClass('active');
//                             seria.addClass('active');
//                         }
//                     });
//                 } else {
//                     $.cookie($('#anime_alias').val(), seria.data('id'), {
//                         expires: 20
//                     });
//                     block.find('.video-button').removeClass('active');
//                     seria.addClass('active');
//                 }
//             }
//         }
//     }
// }
//
// $('.video-button').on('click', function () {
//     seria = null;
// });
//
// function mwPlayerMessageReceive(event) {
//     if (event.data && event.data.message == 'MW_PLAYER_START_VIDEO') {
//         onPlayerNextEpisode(event.data.value);
//     } else if (event.data && event.data.message == 'MW_PLAYER_DURATION') {
//         onPlayerStartEpisode();
//     }
// }
//
// $(function () {
//     if (window.addEventListener) {
//         window.addEventListener('message', mwPlayerMessageReceive);
//     } else {
//         window.attachEvent('onmessage', mwPlayerMessageReceive);
//     }
//     var tab = $('#schedule');
//     if (tab.length > 0) {
//         var child = tab.children().get(new Date().getDay() - 1);
//         tab[0].scroll({
//             top: 0,
//             left: child.offsetLeft - (tab.width() / 2 - child.offsetWidth / 2.9),
//             behavior: 'smooth'
//         });
//         child.click();
//     }
// });

function escapeHtml(text) {
    if (text) {
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    } else {
        return '';
    }
}

function escapeEncode(text) {
    if (text) {
        return text
            .replace(/&nbsp;/g, ' ')
            .replace(/&amp;/g, '&')
            .replace(/&gt;/g, '>')
            .replace(/&lt;/g, '<');
    } else {
        return '';
    }
}

function htmlToBb(text) {
    var map = {
        'b': 'ж',
        'i': 'к',
        'u': 'п',
        's': 'з',
        'strike': 'з',
        'nick': 'ник'
    };
    text = stripHtml(text)
        .replace(/<(\/?)(nick|strike|[bius])( .+?)?>/g, function (match, e1, e2) {
            return '[' + e1 + map[e2] + ']';
        }).replace(/<button.*?>(.+?)<\/button><spoiler.*?>((?:.|\n)*?)<\/spoiler>/g, '[спойлер="$1"]$2[/спойлер]')
        .replace(/<div>/g, '\n').replace(/<\/div>/g, '')

    var div = document.createElement("div");
    div.innerHTML = text;
    text = div.textContent || div.innerText || "";
    return text;
}

function bbToHtml(text) {
    var map = {
        'ж': 'b',
        'к': 'i',
        'п': 'u',
        'з': 's',
    };
    var editable = '';
    if (getMobileOperatingSystem() !== 'Android') {
        editable = ' contenteditable="false"'
    }
    text = text
        .replace(/\[ник](.+?)\[\/ник]/gm, function (match, m1) {
            var c = 'nick-label';
            if (m1 === login) {
                c += ' my-nick';
            }
            return '<nick class="' + c + '"' + editable + '>' + m1 + '</nick>';
        }).replace(/\[(\/?)([жкпз])]/g, function (match, e1, e2) {
            return '<' + e1 + map[e2] + '>';
        }).replace(/\[спойлер(?:=(?:&quot;|")(.+?)(?:&quot;|"))?]((?:.|\n)+?)\[\/спойлер]/g, function (match, e1, e2) {
            if (!e1) e1 = 'Спойлер!';
            return '<button class="spoiler-button">' + e1 + '</button><spoiler>' + e2 + '</spoiler>'
        }).replace(/\[\/?спойлер(=.+?)?]/g, '')
        .replace(/&nbsp;/g, ' ');
    return stripHtml(text);
}

function spoilerToBb(text) {
    text = stripHtml(text)
        .replace(/<button.*?>(.+?)<\/button><spoiler.*?>((?:.|\n)*?)<\/spoiler>/g, '[спойлер="$1"]$2[/спойлер]');
    return text;
}

function stripHtml(html) {
    var doc = new DOMParser().parseFromString(html, 'text/html');
    return doc.body.innerHTML || "";
}

function removeEmptybb(message) {
    var text = message;
    while (/\[ж]\s*?\[\/ж]|\[к]\s*?\[\/к]|\[п]\s*?\[\/п]|\[з]\s*?\[\/з]|\[спойлер(=.+?)?]\s*?\[\/спойлер]/.test(text)) {
        var r = /\[ж]\s*?\[\/ж]|\[к]\s*?\[\/к]|\[п]\s*?\[\/п]|\[з]\s*?\[\/з]|\[спойлер(=.+?)?]\s*?\[\/спойлер]/g;
        text = text.replace(r, '');
    }
    return text;
}

function checkOnSend(message) {
    if (message.length > 5000)
        return 'Максимальная длина комментария 5000 символов';
    if (message.replace(/\[(?:\/?[жкпз]|\/?спойлер(?:=.+?)?)]/g, "").length < 10)
        return 'Минимальная длина комментария 10 символов';
    if (/\[спойлер=[^\]]{32,}]/.test(message))
        return 'Максимальная длина заголовка спойлера 30 символов';
    return 'true';
}

$('form.search-block').submit(function (e) {
    var that = $(this);
    var text = that.find('input[type=text]').val();
    if (text.length === 0 || text.length < 3) {
        that.before('<div class="search-tooltip right-tooltip red-tooltip"><div class="tooltip-block-before"></div><div class="tooltip-block">Запрос дожен содержать не менее 3-х символов</div></div>').parent().find(".tooltip-block").parent().delay(4000).fadeOut();
        return false;
    }
});

function addAnimes(block, animes, lists) {
    var ongoing = {1: 'Онгоинг', 2: 'Анонс', 3: 'В прокате'};
    var listData = {1: ' watch-now', 2: ' position', 5: ' lost'};

    animes.forEach(function (a) {
        var html = '<div class="anime-column"><a class="image-block" href="/catalog/item/' + a.alias + '">';
        if (a.ongoing) {
            html += '<div class="status-label">' + ongoing[a.ongoing] + '</div>'
        } else if (a.is_series == 0) {
            html += '<div class="status-label">Без видео</div>'
        }
        if (lists) {
            lists.forEach(function (list) {
                if (list.anime_id === a.id) {
                    html += '<div class="saw' + (listData[list.list_id] || '') + '"></div>'
                }
            });
        }
        if (a.year) {
            html += '<span class="year-block">' + a.year + '</span>';
        }
        html += '<img src="' + a.image + '" loading="lazy" alt="' + a.name + '">';
        html += '</a>';
        html += '<div class="anime-column-info">';
        html += '<a class="anime-title" href="/catalog/item/' + a.alias + '">' + a.name + '</a>';
        if (a.type_title) {
            html += '<div>' + a.type_title + '</div>'
        }
        html += '<div class="icons-row">';
        html += '<div title="Количество просмотров">';
        html += '<i class="fa fa-eye"></i> ';
        html += a.hits.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
        html += '</div>';
        if (a.is_rating) {
            html += '<div title="Количество голосов"><i class="fa fa-star"></i> ';
            html += a.votes.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
            html += '</div>';
        }
        html += '</div>';
        if (a.is_rating) {
            html += '<div><div class="rating-info" title="' + a.name + '">';
            html += '<span class="fa fa-star rating-star" data-id="' + a.id + '" data-modal="rating-modal"></span>';
            html += '<span class="main-rating">' + (a.rating ? a.rating.toFixed(2) : '0.00') + '</span>';
            html += '</div></div>';
        } else {
            html += '<p class="preview-rating">Рейтинг недоступен</p>';
        }
        html += '</div>';
        html += '</div>';
        block.append(html);
    });

    block.append('<gap></gap><gap></gap><gap></gap>');
}

function addUsers(block, data) {
    data.forEach(function (u) {
        var html = '<div class="anime-column" data-id="' + u.id + '">';
        html += '<a class="image-block" title="' + u.name + '" href="/users/id' + u.id + '">';
        html += '<img src="' + u.avatar + '" alt=""></a><div>';
        html += '<a href="/users/id' + u.id + '" class="friend-name">' + u.name + '</a>';
        html += '</div></div>';
        block.append(html);
    });

    block.append('<gap></gap><gap></gap><gap></gap>');
}

function getPagination(current_page, last_page) {
    if (last_page > 1) {
        var href = location.href.replace(/&page=[^&]+/, '');

        var pages = {};

        for (var i = 1; i <= last_page && i <= 2; i++) {
            pages[i] = current_page === i ? '' : href + '&page=' + i
        }

        for (var i = last_page; i >= last_page - 1 && i > 2; i--) {
            pages[i] = current_page === i ? '' : href + '&page=' + i
        }

        for (var i = 0; i <= 8; i++) {
            for (var j = -1; j < 2; j += 2) {
                var page = current_page + i * j;
                if (page > 2 && page < last_page - 1 && Object.keys(pages).length < 10) {
                    pages[page] = current_page === page ? '' : href + '&page=' + page
                }
            }
        }

        var prev_page = '',
            next_page = '';
        if (current_page > 1) {
            prev_page = href + '&page=' + (current_page - 1)
        }
        if (current_page < last_page) {
            next_page = href + '&page=' + (current_page + 1)
        }

        return makePagination(pages, current_page, prev_page, next_page)
    }
}

function makePagination(pages, current_page, prev_page, next_page) {
    var html = '<ul class="pagination">';
    if (prev_page) {
        html += '<li><a href="' + prev_page + '"><i class="fa fa-chevron-left"></i></a></li>';
    } else {
        html += '<li class="disabled"><span><i class="fa fa-chevron-left"></i></span></li>';
    }
    var prev = 0;
    for (var i in pages) {
        if (i - 1 != prev) {
            html += '<li class="disabled"><span>...</span></li>'
        }
        prev = i;
        if (pages[i]) {
            html += '<li data-pos="' + (i - current_page) + '"><a href="' + pages[i] + '">' + i + '</a></li>'
        } else {
            html += '<li class="active"><span>' + i + '</span></li>'
        }
    }
    if (next_page) {
        html += '<li><a href="' + next_page + '"><i class="fa fa-chevron-right"></i></a></li>';
    } else {
        html += '<li class="disabled"><span><i class="fa fa-chevron-right"></i></span></li>';
    }
    html += '</ul>';
    return html;
}

function autoLink(message) {
    return Autolinker.link(message, {
        newWindow: true,
        stripPrefix: false,
        truncate: 50,
        replaceFn: function (match) {
            if (new RegExp(linkWhiteList.join('|')).test(match.getAnchorHref())) {
                return '<a target="_blank" href="' + match.getAnchorHref() + '">' + match.getAnchorText() + '</a>';
            }
            return '<a target="_blank" href="/redirect?to=' + match.getAnchorHref() + '">' + match.getAnchorText() + '</a>';
        }
    });
}

$(window).bind('load', function () {
    $('#slider span').each(function () {
        ellipsizeTextBox(this);
    });
});

function ellipsizeTextBox(el) {
    var wordArray = el.innerHTML.split('');
    while (el.scrollHeight > el.offsetHeight) {
        wordArray.pop();
        el.innerHTML = $.trim(wordArray.join('')) + '...';
    }
}

function placeCaretAtEnd(el) {
    el.focus();
    if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
        var range = document.createRange();
        range.selectNodeContents(el);
        range.collapse(false);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    } else if (typeof document.body.createTextRange != "undefined") {
        var textRange = document.body.createTextRange();
        textRange.moveToElementText(el);
        textRange.collapse(false);
        textRange.select();
    }
    el.scrollLeft = el.scrollWidth;
}

$('.login-form, .register-form').submit(function (e) {
    var that = $(this);
    if (!that.attr('final')) {
        e.preventDefault();
        var inputs = that.find('input[type=text], input[type=password]');
        var focus = that.find('input:focus');
        var index = inputs.index(focus);
        if (index !== -1 && index < inputs.length - 1) {
            inputs.eq(index + 1).focus();
        } else {
            if (that.find('.recaptcha').length > 0) {
                grecaptcha.ready(function () {
                    grecaptcha.execute(recaptchaSiteKey, {action: that.data('action')}).then(function (token) {
                        if (token) {
                            that.find('.recaptcha').val(token);
                        }
                        that.attr('final', true).submit()
                    });
                });
            } else {
                that.attr('final', true).submit()
            }
        }
    }
});

try {
    window.history.replaceState({}, document.title, window.location.href.replace(/__cf_chl_jschl_tk__=[^&]+/, ''));
} catch (e) {
    console.error(e); // Старый браузер
}
var container = null;

function showNotice(message, caption, level) {
    if (!message) return;
    caption = caption || 'Новое уведомление';
    level = level || 'normal';

    container.append('<div class="notice-slot"></div>');
    var last = container.find('.notice-slot:last');
    last.html('<div class="notice-popup ' + level + '"><div class="n-caption">' + caption + '</div><div class="n-body">' + message + '</div></div>');
    last.css('max-height', last.children().outerHeight()).delay(6000).queue(function (next) {
        var that = $(this);
        if (that.css('opacity') == 1) {
            that.css('pointer-events', 'none').css('opacity', '0').css('margin-bottom', last.children().outerHeight());
            next();
        }
    }).delay(1000).queue(function () {
        $(this).remove();
    })
}

$(document).ready(function () {
    container = $('.notice-container');

    container.on('click', '.notice-slot', function () {
        var that = $(this);
        that.css('transition', 'all .3s').css('max-height', 0).css('opacity', 0).css('margin', 0).delay(300).queue(function () {
            that.remove();
        });
    });
});
function validate(field) {
    $('body,html').animate({scrollTop: 0}, 400);
    $('.content-page').before('<div class="pop-message"><div>' + field + '</div></div>');
}

$('#send-review').click(function () {
    if (!$(this).hasClass('disabled')) {
        $('.pop-message').remove();
        var error = 0;
        var anime_id = $.trim($('select[name="anime_id"]').val());
        var text = $.trim($('textarea[name="text"]').val());
        if (!anime_id) {
            validate('Поле "Рецензия к аниме" - обязательное');
            error = 1;
        }
        if (text == '') {
            validate('Поле "Текст рецензии" - обязательное');
            error = 1;
        } else {
            var newText = text.replace(/<\/?[^>]+(>|$)/g, "")
                .replace(/\s/g, "")
                .replace(/\u00a0/g, "")
                .replace(/&#39;/g, "");
            if (newText.length < 1000) {
                validate('Минимальная длина рецензии - 1 000 символов без пробелов');
                error = 1;
            }
            if (error == 0 || $('.pop-message').length < 0) {
                $(this).addClass('disabled');
                $('#form').submit();
            }
        }
    }
});

var ratingList = {
    0: 'невыбрано',
    1: 'ничтожно',
    2: 'ужасно',
    3: 'плохо',
    4: 'никак',
    5: 'посредственно',
    6: 'неплохо',
    7: 'хорошо',
    8: 'очень хорошо',
    9: 'великолепно',
    10: 'шедевр'
};

if ($('.rate-review-item').length > 0) {
    $.each($('.rate-review-item'), function (i, e) {
        $(e).attr('title', ratingList[$(e).data('id')]);
    });
}

$('#middle-rating').change(function () {
    var rating = ~~$(this).val();
    var reg = /^([0-9]|10)$/;
    var newRating;
    if (reg.test(rating)) {
        newRating = ratingList[rating];
        $(this).parent().parent().find('#rating-average').val(rating);
    } else {
        newRating = ratingList[0];
        $(this).parent().parent().find('#rating-average').val(0);
        $(this).val(0);
    }
    $(this).parent().parent().find('.rate-review-select').text(newRating);
});

$('#reviews-button').click(function () {
    $.ajax({
        url: '/reviews/' + page_id,
        dataType: 'json',
        type: 'post',
    });
});

$('.vote-review:not(.active)').click(function () {
    var that = $(this);
    if (!that.hasClass('disabled')) {
        var rating = that.data('rating');
        var id = $('#page_id').val();
        $.ajax({
            url: '/reviews/' + id + '/vote',
            dataType: 'json',
            type: 'post',
            data: 'rating=' + rating,
            beforeSend: function () {
                that.addClass('disabled');
            },
            success: function (data) {
                showNotice(data.message);
                if (data.status) {
                    $('.review-rating-block > div').removeClass('active');
                    that.addClass('active');
                    $('#review_rating_likes').text(data.likes);
                    $('#review_rating_dislikes').text(data.dislikes);
                }
                that.removeClass('disabled');
            },
            error: function (request, status, error) {
                if (request.status === 401) {
                    showNotice('Ставить оценку могут только авторизованные пользователи', 'Ошибка')
                } else {
                    showNotice('Произошла ошибка, попробуйте позже', 'Ошибка', 'error')
                }
            }
        });
    }

});

$('.claim-review-btn').click(function () {
    $(this).parent().find('.claim-message').toggle();
});

$('.claim-review-send').click(function () {
    var text = $(this).parent().find('textarea').text().trim();
    if (text.length > 0) {
        $.ajax({
            type: 'post',
            url: '/reviews/' + $('#page_id').val() + '/add-claim',
            data: data,
            success: function (data) {
                console.log(data);
            }
        });
    }
});

$('#add-rating-category').click(function () {
    var html = '';
    html += '<div class="rate-review-block-wrapper">';
    html += '<div class="rate-review-top">';
    html += '<span class="rate-review-title editable-title" title="Длина названия не больше 25 символов" contenteditable="true">Название критерия</span> - ';
    html += '<span class="rate-review-select">невыбрано</span>';
    html += '<input type="hidden" class="rating-category" name="rating[category][Название_критерия]" value="0" disabled>';
    html += '</div>';
    html += '<ul class="rate-review-block">';
    html += '<li class="rate-review-item" data-id="1">1</li>';
    html += '<li class="rate-review-item" data-id="2">2</li>';
    html += '<li class="rate-review-item" data-id="3">3</li>';
    html += '<li class="rate-review-item" data-id="4">4</li>';
    html += '<li class="rate-review-item" data-id="5">5</li>';
    html += '<li class="rate-review-item" data-id="6">6</li>';
    html += '<li class="rate-review-item" data-id="7">7</li>';
    html += '<li class="rate-review-item" data-id="8">8</li>';
    html += '<li class="rate-review-item" data-id="9">9</li>';
    html += '<li class="rate-review-item" data-id="10">10</li>';
    html += '<li class="rate-review-item" data-id="0">х</li>';
    html += '</ul>';
    html += '</div>';
    $('.rate-review-block-outer').append(html);
});

var editableTitle;
$('.rate-review-block-outer').on('focus', '.editable-title', function () {
    editCategoryTitle($(this));
}).on('focusout', '.editable-title', function () {
    editCategoryTitle($(this));
}).on('click', '.rate-review-item', function () {
        var rating = ~~$(this).data('id');
        var reg = /^([0-9]|10)$/;
        var newRating;
        if (reg.test(rating)) {
            newRating = ratingList[rating];
        } else {
            newRating = ratingList[0];
            $(this).val(0);
        }
        $(this).parent().parent().find('.rate-review-select').text(newRating);
        $(this).parent().find('.rate-review-item').removeClass('active');
        if (rating !== 0) {
            $(this).addClass('active');
            $(this).parent().parent().find('.rating-category').val(rating).attr('disabled', false);
        } else {
            $(this).parent().parents('.rate-review-block-wrapper').remove();
        }
        var summ = 0;
        if ($('.rate-review-item.active').length > 0) {
            $.each($('.rate-review-item.active'), function (i, e) {
                summ += $(e).data('id');
            });
            $('#middle-rating').val((summ / $('.rate-review-item.active').length).toFixed(0)).trigger('change');
        } else {
            $('#middle-rating').val(0).parent().parent().find('.rate-review-select').text(ratingList[0]);
            $('#rating-average').val(0);
        }
    }
);

function editCategoryTitle(e) {
    editableTitle = e.text().trim()
        .replace(/<\/?[^>]+(>|$)/g, "")
        .replace(/\u00a0/g, "")
        .replace(/&#39;/g, "")
        .slice(0, 25);
    if (editableTitle.length < 1) {
        editableTitle = 'Название_критерия';
    }
    e.text(editableTitle);
    e.parent().find('.rating-category').attr('name', 'rating[category][' + editableTitle + ']');
}

$('.content-page').on('click', '.remove-review', function () {
    var that = $(this);
    if (confirm('Вы уверены, что хотите удалить эту рецензию?')) {
        var level = 'error', caption = 'Удаление рецензии';
        $.ajax({
            url: '/profile/reviews/remove/' + that.parents('.comment').data('id'),
            success: function (data) {
                var message = data.message;
                if (data.status == 1) {
                    level = 'success';
                    var comment = that.parents('.comment');
                    comment.css({'opacity': 0, 'margin-top': comment.outerHeight() * -1});
                    setTimeout(function () {
                        that.parents('.comment').remove();
                    }, 1000);
                }
                showNotice(message, caption, level);
            }
        });
    }
}).on('click', '.review-controls .fa-trash-alt', function (e) {
    e.preventDefault();
    if (confirm('Вы уверены, что хотите удалить эту рецензию?')) {
        window.location = $(this).attr('href');
    }
});

var offset_r = 0;
var skip_r = 0;
var sort_r = 'new'; // available: new|nice|old
var init_reviews = false;

function byNewR(button) {
    offset_r = 0;
    skip_r = 0;
    sort_r = 'new';
    $('.sort-block.reviews-sort .sub-menu-inner-container').removeClass('show')
        .find('.default-button').removeClass('active');
    $(button).addClass('active');
    $('.reviews-block').html('');
    getReviews();
}

function byNiceR(button) {
    offset_r = 0;
    skip_r = 0;
    sort_r = 'nice';
    $('.sort-block.reviews-sort .sub-menu-inner-container').removeClass('show')
        .find('.default-button').removeClass('active');
    $(button).addClass('active');
    $('.reviews-block').html('');
    getReviews();
}

function byOldR(button) {
    offset_r = 0;
    skip_r = 0;
    sort_r = 'old';
    $('.sort-block.reviews-sort .sub-menu-inner-container').removeClass('show')
        .find('.default-button').removeClass('active');
    $(button).addClass('active');
    $('.reviews-block').html('');
    getReviews();
}

function smart_substr(str, len) {
    var temp = str.substr(0, len);
    if (temp.lastIndexOf('<') > temp.lastIndexOf('>')) {
        temp = str.substr(0, 1 + str.indexOf('>', temp.lastIndexOf('<')));
    }
    return temp;
}

function getReviews() {
    var page_id = $('#page_id').val();
    $.ajax({
        url: '/reviews/anime/' + page_id,
        dataType: 'json',
        type: 'GET',
        data: 'skip=' + skip_r + '&sort=' + sort_r,
        beforeSend: function () {
            $('.more-reviews').remove();
        },
        success: function (data) {
            var old_scroll = $(window).scrollTop();
            if (data.reviews.length === 0 && offset_r === 0) {
                $('.sort-block.reviews-sort').html('<div class="status-bg alert-bg">Еще нет проверенных рецензий</div>');
            }
            $('.sort-block.reviews-sort').removeClass('hidden');
            if (data.reviews.length >= 10) {
                $('.more-reviews-container').append('<div class="more-reviews main-button" onclick="getReviews()">Еще рецензии</div>');
            }

            offset_r++;
            skip_r = offset_r * 10;

            var user_id = $('#user_id_chat').val();

            $.each(data.reviews, function () {
                var html = '<div class="comment non-auth" data-id="' + this.id + '">';
                html += '<a href="/users/id' + this.user_id + '" class="comment-img"><img src="' + this.avatar + '" alt=""></a>';
                html += '<div>';
                var reviewer = '';
                if (this.user_activity === 3) {
                    reviewer = ' reviewer';
                }
                html += '<div class="comment-head">';
                html += '<div class="comment-top">';
                html += '<a href="/users/id' + this.user_id + '" class="comment-author' + reviewer + '">' + escapeHtml(this.name) + '</a>';
                html += '<div class="comment-date">' + convertTime(this.time) + '</div>';

                html += '</div>';
                if (typeof user_id !== 'undefined' && user_id == this.user_id) {
                    html += '<div class="comment-controls"><span class="drop-menu-click far fa-fw fa-ellipsis-h"></span>';
                    html += '<div class="hidden-menu invisible"><div class="drop-list">'
                    html += '<a href="/profile/reviews/edit/' + this.id + '" class="drop-menu-item">Редактировать</a>';
                    html += '<div class="drop-menu-item remove-review">Удалить</div>';
                    html += '</div></div>'
                    html += '</div>';
                }
                html += '</div>';

                if (this.text.length > 2000) {
                    html += '<div class="comment-text fr-basic">' + smart_substr(this.text, 2000) + '... ';
                    html += '</div>';
                    html += '<a href="/reviews/' + this.id + '" class="read-more-link" title="Ссылка откроется в новом окне" target="_blank"><i class="fa fa-external-link"></i> Читать полный текст рецензии</a>';
                } else {
                    html += '<div class="comment-text fr-basic">' + this.text + '</div>';
                    html += '<a class="discussion-button" title="Ссылка откроется в новом окне" target="_blank" href="/reviews/' + this.id + '"><i class="far fa-comments"></i> Обсудить рецензию</a>';
                }

                if (this.rating) {
                    var rating = JSON.parse(this.rating);

                    html += '<div class="rating-block">';

                    if (rating.category) {
                        var htmlRating = '';
                        $.each(rating.category, function (i, e) {
                            var rate_class = '';
                            if (e < 5) {
                                rate_class = 'bad';
                            } else if (e > 5) {
                                rate_class = 'good';
                            }
                            htmlRating += '<li class="rating-category-item ' + rate_class + '">';
                            htmlRating += '<div class="rating-category-key">' + i + '</div>';
                            htmlRating += '<div class="rating-category-value">';
                            htmlRating += '<div class="rating-category-num">';
                            htmlRating += '<span class="rating-category-num-item">' + e + '</span> <span>/ 10</span>';
                            htmlRating += '</div>';
                            htmlRating += '<div class="rating-category-text">' + ratingList[parseInt(e)] + '</div>';
                            htmlRating += '</div>';
                            htmlRating += '</li>';
                        });
                        html += '<ul class="rating-block-item rating-category">';
                        html += htmlRating;
                        html += '</ul>';
                    }

                    html += '<div class="rating-block-item rating-average rating-category-item">';
                    html += '<div class="rating-category-key">Итоговая оценка:</div>';
                    html += '<div class="rating-category-value">';
                    var ratingAverage = 0;
                    if (!rating.category && rating.average) {
                        ratingAverage = rating.average;
                        html += '<span class="average-rating" class="">' + ratingAverage + '</span>';
                    } else {
                        var summ = 0;
                        $.each(rating.category, function (i, e) {
                            summ += parseInt(e);
                        });
                        ratingAverage = (summ / Object.keys(rating.category).length).toFixed(0);
                        html += '<span class="average-rating" class="">' + ratingAverage + '</span>';
                    }
                    html += '<span class="rating-average-full"> / 10</span>';
                    html += '<span class="under-average-rating">' + ratingList[parseInt(ratingAverage)] + '</span>';
                    html += '</div>'; //.rating-category-value
                    html += '</div>'; //.rating-average
                    html += '</div>'; //.rating-block
                }

                // if (this.text.length <= 2000) {
                //     html += '<div><a class="default-button" title="Ссылка откроется в новом окне" target="_blank" href="/reviews/' + this.id + '">Обсудить рецензию <i class="far fa-comments"></i></a></div>';
                // }

                html += '</div></div>';

                $('.reviews-block').append(html);
                $('.rating-block').each(function () {
                    var average = ~~$(this).find('.average-rating').text();
                    var averageClass = '';
                    if (average < 5) {
                        averageClass = 'bad';
                    } else if (average > 5) {
                        averageClass = 'good';
                    }
                    $(this).addClass(averageClass);
                });
                $(window).scrollTop(old_scroll);
            });
        }
    });
}

$('.review-status-item').click(function () {
    var status = ~~$(this).data('status');
    var message = $('#update-review-status-message').val().trim();
    if (status == 2 && message.length < 1) {
        showNotice('При не одобрении публикации поле комментария обязательно', 'Ошибка', 'error');
    } else {
        var id = $('#page_id').val();
        var data = 'status=' + status + '&message=' + message;
        $.ajax({
            type: 'post',
            url: '/reviews/' + id + '/update-status',
            data: data,
            success: function (data) {
                if (data.status) {
                    $('#update-review-status').remove();
                }
                showNotice(data.message);
            }
        });
    }
});

$('.who-votes').click(function () {
    var that = $(this);
    if (!that.hasClass('disabled')) {
        var id = that.parents('.comment').data('id');
        $.ajax({
            type: 'post',
            url: '/reviews/who-votes/' + id,
            beforeSend: function () {
                that.addClass('disabled');
            },
            success: function (data) {
                if (!data.status) {
                    showNotice(data.message);
                }
                var html = '';
                if (data.votes.length > 0) {
                    $.each(data.votes, function () {
                        html += '<div class="comment">';
                        html += '<div class="">';
                        html += '<a href="/users/id' + this.user_id + '" class="comment-author">' + escapeHtml(this.name);
                        html += '</a>';
                        html += '<div class="comment-date">' + convertTime(this.time);
                        html += '</div>';
                        if (this.status == 1) {
                            html += '<div class="comment-text">Статус: одобрено</div>';
                        } else if (this.status == 2) {
                            html += '<div class="comment-text">Статус: отклонено</div>';
                        }
                        if (this.message.length > 0) {
                            html += '<div class="comment-text">Комментарий: ' + this.message.replace(/\n/g, '<br>') + '</div>';
                        }
                        html += '</div></div>';
                    });
                } else {
                    html += 'Эту рецензию еще никто не проверял';
                }
                that.parent().find('.who-votes-block').html(html);
                that.removeClass('disabled');
            }
        });
    }
});

$('#reviews-status-history').click(function () {
    var that = $(this);
    if (!that.hasClass('active') && !that.hasClass('disabled')) {
        that.addClass('active');
        var id = $('#page_id').val();
        $.ajax({
            type: 'post',
            url: '/reviews/who-votes/' + id,
            beforeSend: function () {
                that.addClass('disabled');
            },
            success: function (data) {
                if (!data.status) {
                    showNotice(data.message);
                }
                var html = '';
                if (data.votes.length > 0) {
                    $.each(data.votes, function () {
                        html += '<li>';
                        html += '<span data-vote_id="' + this.vote_id + '" title="Показать текст рецензии на момент голосования" class="fa fa-history old-version"></span>';
                        html += '<a target="_blank" href="/users/id' + this.user_id + '">' + this.name + '</a>';
                        html += '<span>';
                        if (this.status == 1) {
                            html += ': одобрено ';
                        } else if (this.status == 2) {
                            html += ': отклонено ';
                        } else {
                            html += ': не проверено ';
                        }
                        html += '</span>';
                        html += '<span class="comment-date">(' + convertTime(this.time) + ')</span>';
                        if (this.message.length > 0) {
                            html += '<span class="review-status-message">Комментарий: ' + this.message.replace(/\n/g, '<br>') + '</span>';
                        }
                        html += '</li>';
                    });
                } else {
                    html += 'Эту рецензию еще никто не проверял';
                }
                $('#who-votes').html(html);
                that.removeClass('disabled');
            }
        });
    } else {
        that.removeClass('active');
        $('#who-votes').html('');
    }

});

$('.content-page').on('click', '.old-version', function () {
    var vote_id = $(this).data('vote_id');
    var id = $('#page_id').val();
    $.ajax({
        type: 'post',
        url: '/reviews/old-version/' + id,
        data: 'vote_id=' + vote_id,
        success: function (data) {
            if (!data.status) {
                showNotice(data.message);
            } else {
                if (data.review_text && data.review_text.length > 0) {
                    $('.post-text').addClass('col col-50').find('.marker').removeClass('hidden');
                    $('#old-version').html('<p class="marker">Старая версия</p>' + data.review_text).removeClass('hidden');
                    $('.content-img-block').addClass('hidden');
                } else {
                    showNotice('Для этого пункта нет сохраненной версии рецензии');
                }
            }
        }
    });
});

$('.claim-review-send').click(function () {
    var message = $.trim($('textarea[name="claim_review_message"]').val());
    if (message.length > 0) {
        var data = 'review_id=' + $('#page_id').val() + '&message=' + message;
        $.ajax({
            type: 'post',
            url: '/review-report',
            data: data,
            success: function (data) {
                if (data.status) {
                    $('.claim-message').hide();
                    $('textarea[name="claim_review_message"]').val('');
                    showNotice('Спасибо, ваша жалоба отправлена', 'Отправка жалобы', 'success');
                } else {
                    showNotice('Произошла ошибка', 'Ошибка', 'error');
                }
            }
        });
    } else {
        showNotice('Сообщение не может быть пустым', 'Ошибка', 'error');
    }

});


var revClick = 0;
$('#reviews').click(function () {
    if (!revClick) {
        getReviews();
        revClick = 1;
    }
});

$(document).ready(function () {

    /*if ($('#reviews').length > 0) {
        var r = 0;
        var reviewsBlock = $('#reviews').offset().top;
        $(document).scroll(function () {
            if ($(window).scrollTop() + $(window).height() >= reviewsBlock && r === 0) {
                getReviews();
                r = 1;
            }
        });
    }*/

    if ($('#average-rating').length > 0) {
        var summ = 0,
            review_class,
            average;

        if ($('.rating-category-num-item').length > 0) {
            $('.rating-category-num-item').each(function (i, e) {
                var rate_class = '';
                var rate = parseInt($(e).text());
                if (rate < 5) {
                    rate_class = 'bad';
                } else if (rate > 5) {
                    rate_class = 'good';
                }
                $(e).parents('.rating-category-item').addClass(rate_class);
                summ += rate;
                $(e).parents('.rating-category-value').find('.rating-category-text').text(ratingList[parseInt($(e).text())]);
            });

            average = (summ / $('.rating-category-num-item').length).toFixed(0);

        } else {
            average = parseInt($('#average-rating').text());
        }

        if (average < 5) {
            review_class = 'bad';
        } else if (average > 5) {
            review_class = 'good';
        }

        $('.rating-block').addClass(review_class);
        $('#average-rating').text(average);
        $('.under-average-rating').text(ratingList[average]);

    }

    if ($('.rate-review-item.active').length > 0) {
        $('.rate-review-item.active').each(function (i, e) {
            $(e).trigger('click');
        });
    } else {
        $('#middle-rating').trigger('change');
    }

    if ($('.n-replace').length > 0) {
        var text = $('.n-replace').html();
        text = text.replace(/\n/g, '<br>');
        $('.n-replace').html(text);
    }

}); //ready
if ($(window).width() <= 768) {
    $('.category-list-inner').each(function () {
        var that = $(this);
        if (that.children().length > 1) {
            that.css('display', 'grid').hide();
        } else that.parent().addClass('one')
    })
}

$('.drop-icon').click(function () {
    var parent = $(this).parents('.drop-list-inner');
    if (!parent.hasClass('block')) {
        parent.addClass('block');
        if (!parent.find('.category-list-inner').height()) {
            openDropList(parent);
            $('.drop-list-inner.open').not(parent).each(function () {
                closeDropList($(this))
            });
        } else {
            closeDropList(parent);
        }
    }
});

function openDropList(block) {
    $('.category-list > li').css('z-index', '');
    block.parents('li').css('z-index', '4');
    var list = block.addClass('open').find('.category-list-inner');
    list.show().css({height: list[0].scrollHeight});
    block.find('.drop-icon').addClass('open');
    setTimeout(function () {
        block.removeClass('block');
        list.css({height: 'auto'});
    }, 300);
}

function closeDropList(block) {
    var list = block.find('.category-list-inner');
    list.css({height: list[0].scrollHeight});
    setTimeout(function () {
        list.css({height: ''});
    },0);
    block.find('.drop-icon').removeClass('open');
    setTimeout(function () {
        list.hide();
        block.removeClass('block open')
    }, 300);
}

$('.main-category').click(function () {
    var list = $(this).next();
    if (!list.hasClass('block')) {
        list.addClass('block').css('overflow', 'hidden');
        if (!list.height()) {
            list.css({height: list[0].scrollHeight});
            setTimeout(function () {
                list.removeClass('block').css({overflow: 'visible', height: 'auto'});
            }, 300);
        } else {
            list.removeClass('block').css({height: list[0].scrollHeight});
            setTimeout(function () {
                list.css({height: ''});
            }, 0);
            list.find('.drop-list-inner.open .drop-icon').not(this).each(function () {
                toggleDropList($(this))
            });
        }
    }
});